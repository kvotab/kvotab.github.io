<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <link rel="icon" type="image/png" sizes="16x16" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB8lBMVEUARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARHUARHUARHUARHUCRncUVIETU4AIS3oTU4ABRXYARHYANGlBdJkhXYi/0NypwNE8cZbC095OfqAAM2kAK2Ohus1Ug6Pf6O6OrcI2bJPr8fSzx9YAOGyguswpY4zf5+5XhKQyaZHs8fWctsoANWoAMmg/c5gsZY62ythKe57p7/NMfZ8AMGcAPG86b5VZhqbj6/Bah6br8PStw9MAN2sAKmKatslVg6Pg6O7k6/CpwNEANGo0a5IeW4aqwdGswtJEd5uwxtUvaJAAN2wDRncBRXYJS3sJS3sESHgJTHsARXYARXYARHUARHUARXYARXYARHUARHUARXYARHUARHUARXYARXYARHYARHUNTn0VVIEGSHgRUX8LTHsWVYIQUX+8ztvW4emBo7ulvc6MqsHX4enF1eDw9Pe9ztvf6O7g6O7k6/DI1+Hi6u/y9vh8oLlGeJz////6+/y+z9zX4urJ1+Katsn6/Pz4+vve5+1tlbGmvs/r8fTP3OW0yNbz9vjN2+Tn7fLI1uHX4unp7/Otw9PE1N96nreXs8eOrcLG1eCov9AHSnkKTHsISnoHSnoLTXwHSXlgx+EhAAAAanRSTlMLYnd2Um5xUXUZ0/6w7vOv/NSx/e7z/dSx7vOw/dQZGdSx7vOw/dQZGdSx7vOw/dQZ1LHu87D91BkZ1LHzsP3UGRnUsfOw/dQZGdSx7vPUGdSx7vOw/dQZ/rDu87D8DGR6eXpUcHRTd3tlDK+lHQAAAAFiS0dEhRXXaucAAAAHdElNRQfmCB4IBCY0DSgTAAAA8klEQVQY02NgYGRiZmZhZWZmY+dgZmJkYODkyuLm5uHNyuLjF+DO4uJk4BTMysoSAgnwCGdlCRInkJ2TJSSSky3KI5aTAxIQz83Ll5AsKJSSlikqlpVjkFcoKS1TVCqvUFZRraxSU2fQ0KyuqdXSrqvX0dVraNQ3YNAwbGpuMTJubTMxNWvvMLdgsLTqrO6yNu7usbG1a+q1d2BwdOrrn+CsPbHKxdVtUqm7B4On1+QpU719ptX4utpNn+FnweAfMHPW7MCgOXODQ0LnzQ8LB7pjwcKIyKhFi6NjYpcsFedkiItPSExKTklMSE1LT8zIjAMAkOZIz65wIlsAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjItMDgtMzBUMDg6MDQ6MzgrMDA6MDCWf9PgAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIyLTA4LTMwVDA4OjA0OjM4KzAwOjAw5yJrXAAAAFd6VFh0UmF3IHByb2ZpbGUgdHlwZSBpcHRjAAB4nOPyDAhxVigoyk/LzEnlUgADIwsuYwsTIxNLkxQDEyBEgDTDZAMjs1Qgy9jUyMTMxBzEB8uASKBKLgDqFxF08kI1lQAAAABJRU5ErkJggg=="/>
  <link rel="mask-icon" type="image/svg" href="data:image/svg;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iNzg0LjAwMDAwMHB0IiBoZWlnaHQ9Ijc4NC4wMDAwMDBwdCIgdmlld0JveD0iMCAwIDc4NC4wMDAwMDAgNzg0LjAwMDAwMCIKIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiPgo8bWV0YWRhdGE+CkNyZWF0ZWQgYnkgcG90cmFjZSAxLjE0LCB3cml0dGVuIGJ5IFBldGVyIFNlbGluZ2VyIDIwMDEtMjAxNwo8L21ldGFkYXRhPgo8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCw3ODQuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApIgpmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiPgo8cGF0aCBkPSJNNTMwIDM5MTUgbDAgLTM2MjUgMTA3NSAwIDEwNzUgMCAwIDM2MjUgMCAzNjI1IC0xMDc1IDAgLTEwNzUgMCAwCi0zNjI1eiBtMTczNCAyMDkgbDIzNiAtMjQ3IDAgLTI2OCAwIC0yNjkgLTM4MCAwIC0zODAgMCAtMiAyMTggLTMgMjE3IC0xMDcgMwotMTA4IDMgMCAtMzQ1IDAgLTM0NiAyMyAtNSBjMTIgLTMgMTIzIC0yNiAyNDcgLTUwIGwyMjUgLTQ1IDIzOCAtMjM4IDIzNwotMjM3IDAgLTUxMCAwIC01MTEgLTIwOCAtMjA3IC0yMDkgLTIwNyAtNDgwIDAgLTQ3OSAwIC0xOTcgMjI0IC0xOTcgMjI0IDAKMzAxIDAgMzAxIDM5OCAtMiAzOTcgLTMgMyAtMjI3IDIgLTIyOCAxMDUgMCAxMDUgMCAwIDMzNCBjMCAzMTAgLTEgMzM1IC0xNwozNDAgLTEwIDMgLTEyOCAyNiAtMjYzIDUxIC0xMzUgMjUgLTI1MiA0OSAtMjYxIDUzIC04IDQgLTExOCAxMTEgLTI0MiAyMzkKbC0yMjcgMjMyIDAgNTI0IDAgNTIzIDIzOCAyMDEgMjM3IDIwMiA0MTcgMCA0MTcgMSAyMzUgLTI0NnoiLz4KPHBhdGggZD0iTTI4NjAgMzkxNSBsMCAtMzYyNSAxMDc1IDAgMTA3NSAwIDAgMzYyNSAwIDM2MjUgLTEwNzUgMCAtMTA3NSAwIDAKLTM2MjV6IG05NzAgLTI4IGw1IC00ODggMTg1IDQ4NSAxODUgNDg2IDMzOSAwIDMzOCAwIC02IC0yMiBjLTMgLTEzIC05MyAtMzEzCi0yMDEgLTY2NyBsLTE5NiAtNjQ1IDI4IC0yNiBjMTUgLTE1IDEwMyAtOTYgMTk2IC0xODAgbDE2NyAtMTUyIDAgLTc5OSAwCi03OTkgLTQwNSAwIC00MDUgMCAtMiA2ODIgLTMgNjgzIC0xMTIgMyAtMTEzIDMgMCAtNjg2IDAgLTY4NSAtNDIwIDAgLTQyMCAwCjAgMTY1MCAwIDE2NTAgNDE4IC0yIDQxNyAtMyA1IC00ODh6Ii8+CjxwYXRoIGQ9Ik01MTkwIDM5MTUgbDAgLTM2MjUgMTA2MCAwIDEwNjAgMCAwIDM2MjUgMCAzNjI1IC0xMDYwIDAgLTEwNjAgMCAwCi0zNjI1eiBtMTc0NyAyNDMgbDIxMyAtMjEzIDAgLTQzNSAwIC00MzYgLTIwMiAtMTYwIGMtMTEyIC04OCAtMjAzIC0xNjUgLTIwMwotMTcxIDAgLTYgOTAgLTgwIDIwMCAtMTY1IGwyMDAgLTE1NCAzIC00MzkgMiAtNDQwIC0yNDcgLTIzNyAtMjQ4IC0yMzcgLTY0NwotMSAtNjQ4IDAgMCAxNjUwIDAgMTY1MCA2ODIgMCA2ODMgMCAyMTIgLTIxMnoiLz4KPHBhdGggZD0iTTYxODAgMzM5NSBsMCAtMzc1IDEyMCAwIDEyMCAwIC0yIDM3MyAtMyAzNzIgLTExNyAzIC0xMTggMyAwIC0zNzZ6Ii8+CjxwYXRoIGQ9Ik02MTgwIDIwODUgbDAgLTM3NiAxMTggMyAxMTcgMyAzIDM3MyAyIDM3MiAtMTIwIDAgLTEyMCAwIDAgLTM3NXoiLz4KPC9nPgo8L3N2Zz4K" color="#5bbad5">
  <title>HDF5 File Viewer</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    :root {
      --color-kvot-bright:#f3b87b; 	/* beige*/
      --color-kvot-accent:#bb6c5d;	/*red-brown*/
      --color-kvot-background:#352921;/*dark-brown*/
      --color-kvot-primary:#344126;	/*dark-green*/
      
      /* New harmonized palette */
      --color-panel-bg: #faf8f6;
      --color-panel-border: #e5ddd5;
      --color-text-primary: #2d2416;
      --color-text-secondary: #6b5d4f;
      --color-text-muted: #9b8d7f;
      --color-hover-bg: #f5ede5;
      --color-selected-bg: #ede3d8;
      --color-selected-text: #2d2416;
    }
    @font-face {
      font-family: RawengulkSans;
      src: url(./vendors/font/RawengulkSans-094.otf);
    }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
      margin: 0; 
      padding: 0;
      background: #ebe3db; 
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      color: var(--color-text-primary);
    }
    
    #dropOverlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(243, 184, 123, 0.15);
      border: 4px dashed var(--color-kvot-bright);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      pointer-events: none;
    }
    
    #dropOverlay.active {
      display: flex;
    }
    
    #dropOverlay .message {
      background: white;
      padding: 40px;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(53, 41, 33, 0.25);
      font-size: 24px;
      color: var(--color-kvot-primary);
      font-weight: 600;
    }
    
    .tabs-container {
      background: var(--color-kvot-background);
      border-bottom: 1px solid var(--color-kvot-bright);
      padding: 8px 16px 0 0px;
      display: flex;
      align-items: flex-end;
      gap: 4px;
      min-height: 48px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    
    .file-tab {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid var(--color-kvot-accent);
      border-bottom: none;
      border-radius: 6px 6px 0 0;
      cursor: pointer;
      user-select: none;
      font-size: 13px;
      transition: all 0.2s;
      position: relative;
      max-width: 200px;
      color: rgba(243, 184, 123, 0.7);
    }
    
    .file-tab:hover {
      background: rgba(255, 255, 255, 0.15);
      color: var(--color-kvot-bright);
    }
    
    .file-tab.enabled {
      background: var(--color-kvot-bright);
      color: var(--color-kvot-background);
      border-color: var(--color-kvot-bright);
    }
    
    .file-tab.enabled:hover {
      background: #f5c690;
    }
    
    .file-tab.disabled {
      opacity: 0.5;
      background: rgba(255, 255, 255, 0.05);
    }
    
    .file-tab.disabled:hover {
      opacity: 0.7;
    }
    
    .file-tab-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .file-tab-close {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      line-height: 1;
      flex-shrink: 0;
      transition: background 0.2s;
    }
    
    .file-tab-close:hover {
      background: rgba(0, 0, 0, 0.2);
    }
    
    .file-tab.enabled .file-tab-close:hover {
      background: rgba(53, 41, 33, 0.15);
    }
    
    .add-file-btn {
      padding: 8px 16px;
      background: var(--color-kvot-primary);
      color: var(--color-kvot-bright);
      border: none;
      border-radius: 6px 6px 0 0;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.2s;
      margin-left: auto;
    }
    
    .add-file-btn:hover {
      background: #405533;
    }
    
    .container { 
      display: grid; 
      grid-template-columns: 350px 1fr; 
      gap: 16px;
      padding: 16px;
      flex: 1;
      overflow: hidden;
    }
    
    .panel { 
      background: var(--color-panel-bg);
      border-radius: 8px; 
      padding: 16px; 
      box-shadow: 0 2px 8px rgba(53, 41, 33, 0.1);
      border: 1px solid var(--color-panel-border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .panel h3 {
      margin: 0 0 12px 0;
      color: var(--color-kvot-primary);
      font-size: 16px;
      font-weight: 600;
    }
    
    #tree { 
      flex: 1;
      overflow-y: auto; 
      font-size: 13px;
      padding: 4px;
    }
    
    .tree-item { 
      margin: 2px 0; 
      padding: 6px 8px;
      display: flex;
      align-items: center;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.15s ease;
      user-select: none;
      color: var(--color-text-primary);
    }
    
    .tree-item:hover {
      background: var(--color-hover-bg);
    }
    
    .tree-item.group { 
      font-weight: 500;
      color: var(--color-kvot-primary);
    }
    
    .tree-item.group:hover {
      background: var(--color-hover-bg);
      color: var(--color-kvot-background);
    }
    
    .tree-item.group.expanded {
      background: var(--color-selected-bg);
      color: var(--color-kvot-background);
      border-left: 3px solid var(--color-kvot-accent);
      padding-left: 5px;
    }
    
    .tree-item.dataset { 
      color: var(--color-text-secondary);
      font-size: 12px;
    }
    
    .tree-item.dataset:hover { 
      background: var(--color-hover-bg); 
      color: var(--color-text-primary);
    }
    
    .tree-item.dataset.selected { 
      background: var(--color-selected-bg); 
      color: var(--color-selected-text);
      font-weight: 500;
      border-left: 3px solid var(--color-kvot-accent);
      padding-left: 5px;
    }
    
    .tree-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      margin-right: 4px;
      font-size: 10px;
      transition: transform 0.2s;
      flex-shrink: 0;
      color: var(--color-text-muted);
    }
    
    .tree-toggle.collapsed {
      transform: rotate(-90deg);
    }
    
    .tree-icon {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 6px;
      flex-shrink: 0;
      position: relative;
    }
    
    .tree-icon::before {
      content: '';
      width: 14px;
      height: 14px;
      display: block;
    }
    
    .tree-icon.folder::before {
      background: var(--color-kvot-accent);
      clip-path: polygon(0% 15%, 40% 15%, 45% 0%, 100% 0%, 100% 100%, 0% 100%);
    }
    
    .tree-icon.dataset::before {
      background: var(--color-kvot-bright);
      clip-path: polygon(
        0% 0%, 100% 0%, 100% 70%, 70% 100%, 0% 100%,
        15% 25%, 15% 40%, 85% 40%, 85% 25%,
        15% 50%, 15% 65%, 85% 65%, 85% 50%,
        15% 75%, 15% 85%, 50% 85%, 50% 75%
      );
    }
    
    .tree-label {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .tree-meta {
      color: var(--color-text-muted);
      font-size: 11px;
      margin-left: 8px;
      flex-shrink: 0;
    }
    
    .tree-group-children {
      margin-left: 0;
      border-left: 2px solid var(--color-panel-border);
      padding-left: 4px;
      display: none;
    }
    
    .tree-group-children.expanded {
      display: block;
    }
    
    .search-container {
      position: relative;
      margin-bottom: 12px;
      display: none; /* Hidden by default */
    }

    .search-container.visible {
      display: block;
    }

    .multi-select-hint {
        background: var(--color-kvot-bright);
        color: var(--color-kvot-background);
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    #treeSearch {
      width: 100%;
      padding: 8px 32px 8px 12px;
      border: 1px solid var(--color-panel-border);
      border-radius: 4px;
      font-size: 13px;
      font-family: inherit;
      background: white;
      color: var(--color-text-primary);
      transition: all 0.15s ease;
      outline: none;
    }

    #treeSearch:focus {
      border-color: var(--color-kvot-primary);
      box-shadow: 0 0 0 3px rgba(52, 65, 38, 0.1);
    }

    #treeSearch::placeholder {
      color: var(--color-text-muted);
    }

    .clear-search-btn {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: var(--color-text-muted);
      font-size: 20px;
      line-height: 1;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 3px;
      transition: all 0.2s;
      display: none;
    }

    .clear-search-btn:hover {
      background: var(--color-hover-bg);
      color: var(--color-text-primary);
    }

    .clear-search-btn.visible {
      display: block;
    }

    .tree-item.search-hidden {
      display: none !important;
    }

    .tree-item.search-match {
      background: rgba(243, 184, 123, 0.15);
    }

    .tree-item.search-match .tree-label {
      font-weight: 600;
    }

    .search-highlight {
      background: var(--color-kvot-bright);
      color: var(--color-kvot-background);
      padding: 1px 2px;
      border-radius: 2px;
    }

    .tree-group-children.search-expanded {
      display: block !important;
    }

    .right-panel-content {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }
    
    #plotlyChartContainer {
      margin-bottom: 16px;
      display: none;
    }
    
    #plotlyChartContainer.visible {
      display: block;
    }
    
    .chart-controls {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
      padding: 12px;
      background: var(--color-hover-bg);
      border-radius: 6px;
      flex-wrap: wrap;
      border: 1px solid var(--color-panel-border);
    }
    
    .chart-controls label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--color-text-primary);
      font-weight: 500;
    }
    
    .chart-controls select {
      padding: 6px 24px 6px 10px;
      border: 1px solid var(--color-panel-border);
      border-radius: 4px;
      font-size: 13px;
      background: var(--color-panel-bg);
      color: var(--color-text-primary);
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%232d2416' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 12px;
      transition: all 0.15s ease;
      outline: none;
    }
    
    .chart-controls select:hover {
      border-color: var(--color-kvot-accent);
      background-color: white;
    }
    
    .chart-controls select:focus {
      border-color: var(--color-kvot-primary);
      box-shadow: 0 0 0 3px rgba(52, 65, 38, 0.1);
    }
    
    .chart-controls button {
      padding: 6px 12px;
      background: var(--color-kvot-background);
      color: var(--color-kvot-bright);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      font-weight: 500;
    }
    
    .chart-controls button:hover {
      background: var(--color-kvot-primary);
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(53, 41, 33, 0.2);
    }
    
    .chart-controls button.secondary {
      background: var(--color-text-secondary);
      color: white;
    }
    
    .chart-controls button.secondary:hover {
      background: var(--color-text-primary);
    }
    
    #plotlyChart {
      min-height: 500px;
    }
    
    #info { 
      flex: 1;
    }
    
    .info-section { 
      margin-bottom: 16px; 
    }
    
    .info-label { 
      font-weight: 600; 
      margin-bottom: 6px; 
      color: var(--color-kvot-primary); 
      font-size: 13px;
    }
    
    .info-content { 
      background: var(--color-hover-bg); 
      padding: 10px; 
      border-radius: 4px; 
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace; 
      font-size: 12px; 
      max-height: 300px; 
      overflow-y: auto; 
      word-break: break-all;
      color: var(--color-text-secondary);
      border: 1px solid var(--color-panel-border);
    }
    
    .file-data-section {
      margin-bottom: 12px;
      padding: 12px;
      background: var(--color-hover-bg);
      border-radius: 6px;
      border-left: 3px solid var(--color-kvot-accent);
      border: 1px solid var(--color-panel-border);
      border-left: 3px solid var(--color-kvot-accent);
    }
    
    .file-data-section h4 {
      margin: 0 0 8px 0;
      color: var(--color-kvot-background);
      font-size: 13px;
      font-weight: 600;
    }
    
    .error { 
      background: #fef2f2; 
      color: #991b1b; 
      padding: 12px; 
      border-radius: 4px; 
      margin-top: 12px;
      border: 1px solid #fecaca;
    }
    
    .loading { 
      color: var(--color-text-muted); 
      font-style: italic; 
    }
    
    #fileInput {
      display: none;
    }
    
    .sortable-ghost {
      opacity: 0.4;
    }
    
    .sortable-drag {
      opacity: 0.8;
    }
    
    .smallsvg {
        fill: var(--color-kvot-bright);
        vertical-align: bottom;
        height: 15px;
        transition: all 0.2s;
        transform-origin: 50% 50%;
    }
    .smallsvg:hover {
        fill: var(--color-kvot-accent);
        transform: scale(1.1);
        cursor:pointer;
    }
    
    /* Footer styles */
    footer {
      height: 30px;
      border-top: var(--color-kvot-accent) solid 1px;
      background: var(--color-kvot-background);
      color: var(--color-kvot-bright);
      display: flex;
      align-items: center;
      justify-content: center; 
      padding: 0 16px;
      font-size: 15px;
      flex-shrink: 0;
      font-family:RawengulkSans;
    }

    footer ul {
      list-style-type: none;
      padding: 0;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    footer li {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    footer a {
      color: var(--color-kvot-bright);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      transition: color 0.2s;
    }
    
    footer a:hover {
      color: var(--color-kvot-accent);
    }
    
    .smallsvg {
      width: 14px;
      height: 14px;
      fill: currentColor;
      display: inline-block;
      vertical-align: middle;
    }
    
    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: var(--color-hover-bg);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: var(--color-text-muted);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: var(--color-text-secondary);
    }
    .logo {
     margin-left: 0px;
     margin-top: 0px;
     padding-bottom: 10px;
     text-align: left;
     height: 40px;
    }
    .logo:hover {
      fill: #bb6c5d;
      /*transform: scale(1.05);*/
    }
    .stRight{
      fill:#bb6c5d;
    }
    .stTop{
      fill:#f3b87b;
    }
    .stLeft{
      fill:#344126;
    }
  </style>
</head>
<body>
  <div id="dropOverlay">
    <div class="message">üìÅ Drop HDF5 files here</div>
  </div>
  
  <input id="fileInput" type="file" accept=".h5,.hdf5,.he5" multiple />
  
  <div class="tabs-container">
    <svg class="logo" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="489.1 191.5 776.9 457.6" xml:space="preserve">
      <a href="./index.html" title="kvot ab">
        <path class="stTop" d="M966.1,461.6l-14.5,14.5V191.5h14.5v197.3l114.1-114.1l7,13l-71.5,72l66.8,74.2c4.8,5.5,9,9.3,12.5,11.5c3.5,2.2,7.5,3.3,11.9,3.3h2v14.5c0,0-2,0-2,0c-6.8,0-12.7-1.5-17.8-4.5c-5.1-3-10.7-8-17-15l-66.8-73.6l-39.3,39.3V461.6z"/>
        <path class="stTop" d="M1066,219.9l16,0l76.2,149.9l76.8-151.2l16,0l-87.9,173.1h-9.6L1066,219.9z"/>
        <path class="stTop" d="M1030.2,455.3c25.5,0,47.4,9.5,65.5,28.4c18.2,18.9,27.3,41.7,27.3,68.2c0,17.4-4.1,33.5-12.4,48.3c-8.3,14.8-19.5,26.4-33.8,35c-14.3,8.6-29.8,12.9-46.6,12.9s-32.3-4.3-46.6-12.9c-14.3-8.6-25.5-20.3-33.8-35c-8.3-14.8-12.4-30.9-12.4-48.3c0-26.6,9.1-49.3,27.3-68.2C982.9,464.8,1004.7,455.3,1030.2,455.3z M951.9,551.9c0,22.6,7.7,41.8,23.1,57.8c15.4,16,33.8,23.9,55.3,23.9s39.9-8,55.3-23.9c15.4-16,23.1-35.2,23.1-57.8c0-22.6-7.7-41.9-23.1-58c-15.4-16.1-33.8-24.1-55.3-24.1s-39.9,8-55.3,24.1C959.6,510,951.9,529.4,951.9,551.9z"/>
        <path class="stTop" d="M1165.8,584.2c0,10.8,3.8,20,11.5,27.6c7.7,7.6,16.9,11.5,27.7,11.5c10,0,19.3-3,27.9-9.1l8.4,11.5c-10.4,8.1-22.5,12.1-36.3,12.1c-14.8,0-27.5-5.2-38-15.6c-10.5-10.4-15.7-23-15.7-37.8V463H1123v-14.5h28.3v-42.8h14.5v42.8h71.7V463h-71.7V584.2z"/>
        <polygon class="stRight" points="889.8,230.7 624.9,383 691.3,420.7 823.7,344.6 824.4,648.1 890.7,609.6"/>
        <polygon class="stTop" points="621.9,381.4 754.6,456.8 754.8,532.7 491,380.8 820.3,191.5 886.7,229.2"/>
        <polygon class="stLeft" points="820.5,346.1 754.3,384.2 754.7,536.1 489.1,384.8 489.1,465.4 821.3,649.2"/>
      </a>
    </svg>
    <div id="fileTabs" style="display: flex; gap: 4px; flex: 1;"></div>
    <button class="add-file-btn" onclick="document.getElementById('fileInput').click()">+ Add Files</button>
  </div>

  <div class="container">
    <div class="panel">
      <h3>File Structure</h3>
      <div class="search-container">
        <input 
          type="text" 
          id="treeSearch" 
          placeholder="Search tree (use * for wildcard)..." 
          autocomplete="off"
        />
        <button id="clearSearch" class="clear-search-btn" title="Clear search">√ó</button>
      </div>
      <div id="tree" class="loading">Drop HDF5 files or click "+ Add Files" to start...</div>
    </div>

    <div class="panel">
      <div class="right-panel-content">
        <div id="plotlyChartContainer">
          <h3>Chart</h3>
          <div class="chart-controls">
            <label>
              X-axis:
              <select id="xAxisScale" onchange="updateChartScales()">
                <option value="linear">Linear</option>
                <option value="log">Log</option>
              </select>
            </label>
            <label>
              Y-axis:
              <select id="yAxisScale" onchange="updateChartScales()">
                <option value="linear">Linear</option>
                <option value="log">Log</option>
              </select>
            </label>
            <label >
              <input type="checkbox" id="dynamicLegend" checked onchange="toggleDynamicLegend()">
              Dynamic Legend
            </label>
            <span id="legendStatus" style=" font-size: 12px; color: var(--color-text-muted);"></span>
            <button onclick="applyReleasePresetView()" style="margin-left: auto;">Apply Release View</button>
            <button onclick="applyDosePresetView()">Apply Dose View</button>
            <button class="secondary" onclick="downloadChartData()">Download Data (CSV)</button>
          </div>
          <div id="plotlyChart"></div>
        </div>
        
        <div>
          <h3>Dataset Information</h3>
            <div class="multi-select-hint" style="display: none;" id="multiSelectHint">
              üí° <strong>Tip:</strong> Hold Ctrl (‚åò on Mac) and click datasets to compare multiple
            </div>
            <div id="info">Select a dataset to view its details</div>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <ul>
      <li>
        <a href="./index.html" title="kvot ab">kvot ab</a> | 
        <svg onclick="toggleMap()" class="smallsvg" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="cursor: pointer;">
          <title>address</title>
          <path d="M 15.212,16.424c 2.874,0, 5.212-2.338, 5.212-5.212C 20.424,8.338, 18.086,6, 15.212,6S 10,8.338, 10,11.212 C 10,14.086, 12.338,16.424, 15.212,16.424z M 15.212,8c 1.77,0, 3.212,1.44, 3.212,3.212s-1.44,3.212-3.212,3.212S 12,12.982, 12,11.212 S 13.44,8, 15.212,8zM 14.484,31.458c 0.168,0.186, 0.33,0.306, 0.486,0.39c 0.002,0.002, 0.006,0.002, 0.008,0.004 c 0.108,0.056, 0.214,0.098, 0.314,0.098c 0.1,0, 0.206-0.042, 0.314-0.098c 0.002-0.002, 0.006-0.002, 0.008-0.004 c 0.156-0.084, 0.318-0.204, 0.486-0.39c0,0, 9.296-10.11, 10.23-18.87c 0.056-0.452, 0.094-0.91, 0.094-1.376 C 26.424,5.020, 21.404,0, 15.212,0S 4,5.020, 4,11.212c0,0.474, 0.038,0.936, 0.096,1.394C 5.054,21.362, 14.484,31.458, 14.484,31.458z M 15.212,2 c 5.080,0, 9.212,4.132, 9.212,9.212c0,0.338-0.024,0.698-0.082,1.164c-0.716,6.712-7.018,14.588-9.048,16.984 c-2.082-2.4-8.474-10.256-9.214-17C 6.026,11.918, 6,11.554, 6,11.212C 6,6.132, 10.132,2, 15.212,2z"/>
        </svg> 
        valhallagatan 16 &bull; 753 34 &bull; uppsala | 
        <a href="tel:0733822313">
          <svg class="smallsvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
            <title>phone</title>
            <path d="M164.9 24.6c-7.7-18.6-28-28.5-47.4-23.2l-88 24C12.1 30.2 0 46 0 64C0 311.4 200.6 512 448 512c18 0 33.8-12.1 38.6-29.5l24-88c5.3-19.4-4.6-39.7-23.2-47.4l-96-40c-16.3-6.8-35.2-2.1-46.3 11.6L304.7 368C234.3 334.7 177.3 277.7 144 207.3L193.3 167c13.7-11.2 18.4-30 11.6-46.3l-40-96z"/>
          </svg>
        </a> 
        <a href="mailto:pa@kvotab.se">
          <svg class="smallsvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
            <title>mail</title>
            <path d="M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48H48zM0 176V384c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V176L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"/>
          </svg>
        </a> 
        <a href="https://linkedin.com/in/per-anders-ekstrom" target="_blank" rel="noopener noreferrer">
          <svg class="smallsvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
            <title>linkedin</title>
            <path d="M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z"/>
          </svg>
        </a> 
        <a href="https://www.mathworks.com/matlabcentral/profile/authors/718179" target="_blank" rel="noopener noreferrer">
          <svg class="smallsvg" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <title>matlab</title>
            <path d="M4.323 16.248C3.13 15.354 1.64 14.31 0 13.118l5.814-2.236 2.385 1.789c-1.789 2.087-2.981 2.832-3.876 3.578zm15.95-6.26c-.447-1.193-.745-2.385-1.193-3.578-.447-1.342-.894-2.534-1.64-3.578-.298-.447-.894-1.491-1.64-1.491-.149 0-.298.149-.447.149-.447.149-1.043 1.043-1.193 1.64-.447.745-1.342 1.938-1.938 2.683-.149.298-.447.596-.596.745-.447.298-.894.745-1.491 1.043-.149 0-.298.149-.447.149-.447 0-.745.298-1.043.447-.447.447-.894 1.043-1.342 1.491 0 .149-.149.298-.298.447l2.236 1.64c1.64-1.938 3.578-3.876 4.919-7.602 0 0-.447 4.025-4.025 8.348-2.236 2.534-4.025 3.876-4.323 4.174 0 0 .596-.149 1.193.149 1.193.447 1.789 2.087 2.236 3.279.298.894.745 1.64 1.043 2.534 1.193-.298 1.938-.745 2.683-1.491s1.491-1.64 2.236-2.385c1.342-1.64 2.981-3.727 5.068-2.683.298.149.745.447.894.596.447.298.745.596 1.193 1.043.745.596 1.043 1.043 1.64 1.342-1.491-2.981-2.534-5.963-3.727-9.093z"/>
          </svg>
        </a> 
        <a href="https://github.com/kvotab" target="_blank" rel="noopener noreferrer">
          <svg class="smallsvg" viewBox="0 0 98 96" xmlns="http://www.w3.org/2000/svg">
            <title>github</title>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z"/>
          </svg>
        </a>
      </li>
    </ul>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/h5wasm@latest/dist/iife/h5wasm.min.js"></script>
  <script>
    // Placeholder for toggleMap function
    function toggleMap() {
      console.log('Map toggle clicked (not implemented)');
    }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/h5wasm@latest/dist/iife/h5wasm.min.js"></script>
  <script>
    let loadedFiles = {};
    let fileStates = {}; // Track enabled/disabled state
    let fileOrder = []; // Track tab order
    let selectedDatasetPath = null;
    let selectedIsRadionuclidesGroup = false; // Track if selected path is radionuclides group
    let currentChartData = null; // Store current chart data for export
    let currentTreeFile = null; // Track the current first enabled file
    let selectedDatasets = []; // Array to track multiple selected datasets
    let multiSelectMode = false; // Track if we're in multi-select mode

    async function waitForH5Wasm() {
      let attempts = 0;
      while (!window.h5wasm && attempts < 50) {
        await new Promise(r => setTimeout(r, 100));
        attempts++;
      }
      if (!window.h5wasm) throw new Error('h5wasm failed to load');
      if (window.h5wasm.ready instanceof Promise) await window.h5wasm.ready;
      return window.h5wasm;
    }

    function escapeHtml(text) {
      const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
      return String(text).replace(/[&<>"']/g, m => map[m]);
    }
    function escapeCSV(value) {
      if (value === null || value === undefined) {
        return '';
      }
      
      const str = String(value);
      
      // If the value contains comma, quote, or newline, wrap in quotes and escape quotes
      if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
        return '"' + str.replace(/"/g, '""') + '"';
      }
      
      return str;
    }
    function formatDataType(dtype) {
      if (!dtype) return 'unknown';
      
      let name = '';
      
      if (typeof dtype === 'object' && dtype.name) {
        name = dtype.name;
      } else if (typeof dtype === 'string') {
        name = dtype;
      } else {
        return String(dtype);
      }
      
      const typeMap = {
        'i': 'Integer', 'u': 'Unsigned Integer', 'f': 'Float', 'c': 'Complex',
        'S': 'String (fixed)', 'U': 'Unicode String', 'V': 'Void/Compound',
        'O': 'Object Reference', 'b': 'Boolean', 't': 'Time', 'm': 'Timedelta',
        'M': 'Datetime', 'a': 'Bytes', 'A': 'Any', 'd': 'Float'
      };
      
      name = name.replace(/^[<>|=]/, '');
      
      const match = name.match(/^([a-zA-Z])(\d+)$/);
      if (match) {
        const [, type, bytes] = match;
        const baseType = typeMap[type] || type;
        const bitSize = parseInt(bytes) * 8;
        return `${baseType} (${bitSize}-bit)`;
      }
      
      const singleTypeMatch = name.match(/^([a-zA-Z])$/);
      if (singleTypeMatch) {
        const type = singleTypeMatch[1];
        return typeMap[type] || name;
      }
      
      return name;
    }

    function getEnabledFiles() {
      return fileOrder.filter(key => fileStates[key]);
    }
    function toggleGroupExpansion(event, path) {
      event.stopPropagation(); // Prevent group selection
      
      const toggle = event.currentTarget;
      const groupItem = toggle.closest('.tree-item.group');
      const childrenDiv = groupItem.nextElementSibling;
      
      // Only handle expand/collapse, don't select the group
      if (childrenDiv && childrenDiv.classList.contains('tree-group-children')) {
        const isExpanded = childrenDiv.classList.contains('expanded');
        
        if (isExpanded) {
          childrenDiv.classList.remove('expanded');
          toggle.classList.add('collapsed');
          // Remove expanded class from group item (visual indicator)
          groupItem.classList.remove('expanded');
        } else {
          childrenDiv.classList.add('expanded');
          toggle.classList.remove('collapsed');
        }
      }
    }
    function getTreeFile() {
      const enabledFiles = getEnabledFiles();
      return enabledFiles.length > 0 ? enabledFiles[0] : null;
    }

    function checkIfPathExistsInFile(fileName, path) {
      try {
        const file = loadedFiles[fileName];
        if (!file) return false;
        const node = file.get(path);
        return node !== null && node !== undefined;
      } catch (e) {
        return false;
      }
    }

    function refreshInfoAndChart() {
      if (!selectedDatasetPath) {
        return;
      }

      const treeFile = getTreeFile();
      
      // Check if selected path exists in new first file
      if (!treeFile || !checkIfPathExistsInFile(treeFile, selectedDatasetPath)) {
        // Clear selection
        document.getElementById('info').innerHTML = 'Select a dataset to view its details';
        document.getElementById('plotlyChartContainer').classList.remove('visible');
        currentChartData = null;
        selectedDatasetPath = null;
        selectedIsRadionuclidesGroup = false;
        
        // Remove selection highlighting
        document.querySelectorAll('.tree-item.dataset').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.tree-item.group').forEach(el => el.classList.remove('expanded'));
        return;
      }

      // Path exists, refresh the info and chart
      if (selectedIsRadionuclidesGroup) {
        showNodeAttributes(selectedDatasetPath, true);
        createRadionuclidesChart(selectedDatasetPath);
      } else {
        showNodeAttributes(selectedDatasetPath, false);
        
        // Check if the dataset is time-dependent
        try {
          const file = loadedFiles[treeFile];
          const dataset = file.get(selectedDatasetPath);
          if (dataset && dataset.type.toLowerCase() === 'dataset' && isTimeDependent(dataset)) {
            createPlotlyChart(selectedDatasetPath);
          }
        } catch (e) {
          console.warn('Error checking if dataset is time-dependent:', e);
        }
      }
    }

    function updateTabs() {
      const tabsContainer = document.getElementById('fileTabs');
      const previousTreeFile = currentTreeFile; // Use stored value
      
      tabsContainer.innerHTML = fileOrder.map(key => {
        const isEnabled = fileStates[key];
        return `
          <div class="file-tab ${isEnabled ? 'enabled' : 'disabled'}" data-file="${escapeHtml(key)}">
            <div class="file-tab-name" title="${escapeHtml(key)}">${escapeHtml(key)}</div>
            <div class="file-tab-close" onclick="event.stopPropagation(); removeFile('${key.replace(/'/g, "\\'")}')">√ó</div>
          </div>
        `;
      }).join('');
      
      // Add click handlers
      document.querySelectorAll('.file-tab').forEach(tab => {
        const fileName = tab.getAttribute('data-file');
        tab.addEventListener('click', (e) => {
          if (!e.target.classList.contains('file-tab-close')) {
            toggleFileState(fileName);
          }
        });
      });
      
      // Initialize sortable
      if (window.Sortable && tabsContainer.children.length > 0) {
        Sortable.create(tabsContainer, {
          animation: 150,
          ghostClass: 'sortable-ghost',
          dragClass: 'sortable-drag',
          onEnd: function(evt) {
            // Capture previous before updating order
            const previousFirst = currentTreeFile;
            
            // Update file order based on new tab positions
            const newOrder = Array.from(tabsContainer.children).map(
              tab => tab.getAttribute('data-file')
            );
            fileOrder = newOrder;
            
            // Update current tree file
            const newTreeFile = getTreeFile();
            currentTreeFile = newTreeFile;
            
            const treeFileChanged = previousFirst !== newTreeFile;
            
            console.log('Drag ended - Previous:', previousFirst, 'New:', newTreeFile, 'Changed:', treeFileChanged);
            
            // Update tree if first file changed
            if (treeFileChanged) {
              refreshTreeStructure();
            }
            
            // Always refresh info and chart
            refreshInfoAndChart();
          }
        });
      }
      
      // Check if first enabled file changed (for enable/disable actions)
      const newTreeFile = getTreeFile();
      const treeFileChanged = previousTreeFile !== newTreeFile;
      
      // Update the tracked current tree file
      currentTreeFile = newTreeFile;
      
      console.log('updateTabs - Previous:', previousTreeFile, 'New:', newTreeFile, 'Changed:', treeFileChanged);
      
      if (treeFileChanged) {
        refreshTreeStructure();
      }
      
      // Always refresh info and chart when tabs change
      refreshInfoAndChart();
    }

    function toggleFileState(fileName) {
      // Don't update currentTreeFile here - let updateTabs do it
      fileStates[fileName] = !fileStates[fileName];
      updateTabs();
    }

    async function removeFile(fileName) {
      delete loadedFiles[fileName];
      delete fileStates[fileName];
      fileOrder = fileOrder.filter(k => k !== fileName);
      
      const enabledFiles = getEnabledFiles();
      
      // Always update tabs - don't clear them completely
      updateTabs();
      
      if (enabledFiles.length > 0) {
        // Has enabled files - refresh tree
        // (updateTabs already called above)
      } else {
        // No enabled files - clear tree and info but keep tabs
        currentTreeFile = null;
        const tree = document.getElementById('tree');
        tree.innerHTML = '<div class="loading">Drop HDF5 files or click "+ Add Files" to start...</div>';
        tree.classList.add('loading');
        document.getElementById('info').innerHTML = 'Select a dataset to view its details';
        document.getElementById('plotlyChartContainer').classList.remove('visible');
        currentChartData = null;
        selectedDatasetPath = null;
        selectedIsRadionuclidesGroup = false;
        
        // Hide search bar
        document.querySelector('.search-container').classList.remove('visible');
        
        // Hide multi-select hint
        const hint = document.getElementById('multiSelectHint');
        if (hint) {
          hint.style.display = 'none';
        }
        
        // Don't clear tabs here - updateTabs() already called above
      }
    }
    
    function selectDataset(path, evt) {
      evt?.stopPropagation();
      
      const isCtrlKey = evt?.ctrlKey || evt?.metaKey; // Support both Ctrl (Windows/Linux) and Cmd (Mac)
      const datasetElement = evt?.target?.closest('.tree-item.dataset');
      
      if (isCtrlKey) {
        // Multi-select mode
        multiSelectMode = true;
        
        // Check if already selected
        const index = selectedDatasets.indexOf(path);
        if (index > -1) {
          // Deselect
          selectedDatasets.splice(index, 1);
          datasetElement?.classList.remove('selected');
        } else {
          // Add to selection
          selectedDatasets.push(path);
          datasetElement?.classList.add('selected');
        }
        
        // Clear group selection
        selectedIsRadionuclidesGroup = false;
        document.querySelectorAll('.tree-item.group').forEach(el => {
          el.classList.remove('expanded');
        });
        
        // Show info for all selected datasets
        if (selectedDatasets.length > 0) {
          showMultipleDatasetAttributes(selectedDatasets);
        } else {
          document.getElementById('info').innerHTML = 'Select a dataset to view its details';
          document.getElementById('plotlyChartContainer').classList.remove('visible');
          currentChartData = null;
        }
      } else {
        // Single select mode
        multiSelectMode = false;
        selectedDatasets = [path];
        selectedDatasetPath = path;
        selectedIsRadionuclidesGroup = false;
        
        // Clear all selections
        document.querySelectorAll('.tree-item.dataset').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.tree-item.group').forEach(el => el.classList.remove('expanded'));
        
        // Mark this dataset as selected
        datasetElement?.classList.add('selected');
        
        showNodeAttributes(path, false);
      }
    }
    
    function toggleGroup(event) {
      event.stopPropagation();
      const groupItem = event.currentTarget;
      
      // Don't do anything if clicking on the toggle triangle (handled separately)
      if (event.target.classList.contains('tree-toggle')) {
        return;
      }
      
      const path = groupItem.getAttribute('data-path');
      if (path) {
        // Clear multi-select mode
        multiSelectMode = false;
        selectedDatasets = [];
        
        selectedDatasetPath = path;
        selectedIsRadionuclidesGroup = true;
        
        // Clear all dataset selections
        document.querySelectorAll('.tree-item.dataset.selected').forEach(el => {
          el.classList.remove('selected');
        });
        
        // Remove 'expanded' class from ALL groups (this is the selection indicator)
        document.querySelectorAll('.tree-item.group').forEach(el => {
          el.classList.remove('expanded');
        });
        
        // Add 'expanded' class ONLY to this selected group (for selection styling)
        groupItem.classList.add('expanded');
        
        showNodeAttributes(path, true);
      }
    }

    async function refreshTreeStructure() {
      const tree = document.getElementById('tree');
      const searchContainer = document.querySelector('.search-container');
      const treeFile = getTreeFile();
      
      if (!treeFile) {
        tree.innerHTML = '<div class="loading">Drop HDF5 files or click "+ Add Files" to start...</div>';
        tree.classList.add('loading');
        document.getElementById('info').innerHTML = 'Select a dataset to view its details';
        document.getElementById('plotlyChartContainer').classList.remove('visible');
        searchContainer.classList.remove('visible'); // Hide search bar
        return;
      }
      
      console.log('Refreshing tree structure for:', treeFile);
      
      try {
        const file = loadedFiles[treeFile];
        const treeHtml = await buildTree(file);
        tree.innerHTML = treeHtml || '<div style="color:#999;">No items found</div>';
        tree.classList.remove('loading');
        searchContainer.classList.add('visible'); // Show search bar
      } catch (err) {
        tree.innerHTML = `<div class="error">Error loading tree: ${escapeHtml(err.message)}</div>`;
        console.error(err);
        searchContainer.classList.remove('visible'); // Hide search bar on error
      }
    }
    // Show multi-select hint when tree is loaded with data
    const originalRefreshTreeStructure2 = refreshTreeStructure;
    refreshTreeStructure = async function() {
      await originalRefreshTreeStructure2();
      const hint = document.getElementById('multiSelectHint');
      const tree = document.getElementById('tree');
      
      if (hint) {
        // Only show hint if:
        // 1. There are enabled files
        // 2. Tree is not in loading state
        // 3. Tree actually has content (datasets/groups)
        const hasEnabledFiles = getEnabledFiles().length > 0;
        const isNotLoading = !tree.classList.contains('loading');
        const hasTreeContent = tree.querySelector('.tree-item') !== null;
        
        if (hasEnabledFiles && isNotLoading && hasTreeContent) {
          hint.style.display = 'flex';
        } else {
          hint.style.display = 'none';
        }
      }
    };
    async function buildTree(group, prefix = '', isNested = false) {
      const childrenHtml = [];
      
      // Add root group item only at top level
      if (prefix === '') {
        const isRootSelected = selectedDatasetPath === '/' && selectedIsRadionuclidesGroup;
        const rootHtml = `<div class="tree-item group ${isRootSelected ? 'expanded' : ''}" onclick="toggleGroup(event)" data-path="/" style="font-weight: 600; color: var(--color-kvot-primary); margin-bottom: 8px;">
          <div class="tree-toggle ${isRootSelected ? '' : 'collapsed'}" onclick="event.stopPropagation(); toggleGroupExpansion(event, '/')">‚ñ∂</div>
          <div class="tree-icon folder"></div>
          <div class="tree-label">/ (root)</div>
        </div>`;
        childrenHtml.push(rootHtml);
        
        // Add a wrapper for root children
        const rootChildrenStart = `<div class="tree-group-children ${isRootSelected ? 'expanded' : ''}" style="margin-left: 20px;">`;
        childrenHtml.push(rootChildrenStart);
      }
      
      try {
        let keys = [];
        try {
          if (typeof group.keys === 'function') {
            keys = Array.from(group.keys());
          }
          keys.sort();
        } catch (e) {
          console.error('Error getting keys:', e.message);
          if (prefix === '') {
            childrenHtml.push('</div>'); // Close root children wrapper
          }
          return childrenHtml.join('');
        }
        
        if (keys.length === 0) {
          if (prefix === '') {
            childrenHtml.push('<div style="color:#999;padding:8px;font-size:12px;">(empty)</div>');
            childrenHtml.push('</div>'); // Close root children wrapper
          }
          return childrenHtml.join('');
        }
        
        for (const key of keys) {
          try {
            const obj = group.get(key);
            if (!obj) continue;
            
            const path = prefix ? `${prefix}/${key}` : `/${key}`;
            const objType = String(obj.type).toLowerCase();
            
            if (objType === 'group') {
              const isSelected = selectedDatasetPath === path && selectedIsRadionuclidesGroup;
              const groupHtml = `<div class="tree-item group ${isSelected ? 'expanded' : ''}" onclick="toggleGroup(event)" data-path="${escapeHtml(path)}">
                  <div class="tree-toggle ${isSelected ? '' : 'collapsed'}" onclick="event.stopPropagation(); toggleGroupExpansion(event, '${path.replace(/'/g, "\\'")}')">‚ñ∂</div>
                  <div class="tree-icon folder"></div>
                  <div class="tree-label">${escapeHtml(key)}</div>
                </div>`;
              childrenHtml.push(groupHtml);
              
              try {
                const subItems = await buildTree(obj, path, true);
                const childrenWrapper = `<div class="tree-group-children ${isSelected ? 'expanded' : ''}">${subItems || '<div style="color:#999;padding:8px;font-size:12px;">(empty)</div>'}</div>`;
                childrenHtml.push(childrenWrapper);
              } catch (subErr) {
                console.error('Error getting sub-items for', key, subErr);
                const errorWrapper = `<div class="tree-group-children"><div style="color:red;padding:8px;font-size:12px;">(error: ${escapeHtml(subErr.message)})</div></div>`;
                childrenHtml.push(errorWrapper);
              }
            } else if (objType === 'dataset') {
              const shape = obj.shape?.length ? `${obj.shape.join('√ó')}` : 'scalar';
              const formattedDtype = formatDataType(obj.dtype);
              const isSelected = selectedDatasetPath === path && !selectedIsRadionuclidesGroup;
              const datasetHtml = `<div class="tree-item dataset ${isSelected ? 'selected' : ''}" onclick="selectDataset('${path.replace(/'/g, "\\'")}', event)" data-path="${escapeHtml(path)}">
                <div class="tree-icon dataset"></div>
                <div class="tree-label">${escapeHtml(key)}</div>
                <div class="tree-meta">${escapeHtml(formattedDtype)} [${escapeHtml(shape)}]</div>
              </div>`;
              childrenHtml.push(datasetHtml);
            }
          } catch (e) {
            console.error('Error with key', key, ':', e.message);
            childrenHtml.push(`<div class="tree-item" style="color:red;font-size:12px;">‚ö†Ô∏è ${escapeHtml(key)}</div>`);
          }
        }
      } catch (e) {
        console.error('buildTree error:', e);
      }
      
      // Close root children wrapper
      if (prefix === '') {
        childrenHtml.push('</div>');
      }
      
      return childrenHtml.join('');
    }

    function checkDatasetExistsInFile(file, path) {
      try {
        const dataset = file.get(path);
        return dataset !== null && dataset !== undefined;
      } catch (e) {
        return false;
      }
    }

    function getTimeData(file) {
      try {
        const timeDataset = file.get('/time');
        if (timeDataset && typeof timeDataset.value !== 'undefined') {
          let timeData = timeDataset.value;
          if (timeData && typeof timeData === 'object' && timeData.length !== undefined) {
            return Array.from(timeData);
          }
          return [timeData];
        }
      } catch (e) {
        console.warn('Could not read /time dataset:', e.message);
      }
      return null;
    }

    function getTimeUnit(file) {
      try {
        const timeDataset = file.get('/time');
        if (timeDataset && timeDataset.attrs && typeof timeDataset.attrs === 'object') {
          for (const attrName in timeDataset.attrs) {
            if (attrName === 'unit') {
              const attrObj = timeDataset.attrs[attrName];
              if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                return attrObj.value;
              }
            }
          }
        }
      } catch (e) {
        console.warn('Could not read time unit:', e);
      }
      return '';
    }

    function isTimeDependent(dataset) {
      try {
        if (dataset.attrs && typeof dataset.attrs === 'object') {
          for (const attrName in dataset.attrs) {
            if (attrName === 'time_dependent') {
              const attrObj = dataset.attrs[attrName];
              if (attrObj && typeof attrObj.value !== 'undefined') {
                const value = attrObj.value;
                return value === true || value === 1 || value === 'TRUE' || value === 'True';
              }
            }
          }
        }
      } catch (e) {
        console.warn('Error checking time_dependent attribute:', e);
      }
      return false;
    }

    function getLineStyle(name) {
      const lineStyles = {
        'Ac-227': { color: 'rgb(128,0,0)', dash: 'solid' },
        'Ag-108m': { color: 'rgb(128,128,0)', dash: 'solid' },
        'Am-243': { color: 'rgb(72,209,204)', dash: 'solid' },
        'Am-242m': { color: 'rgb(72,209,204)', dash: 'dash' },
        'Am-241': { color: 'rgb(72,209,204)', dash: 'dashdot' },
        'Ar-39': { color: 'rgb(152,251,152)', dash: 'solid' },
        'Ba-133': { color: 'rgb(70,130,180)', dash: 'solid' },
        'Be-10': { color: 'rgb(65,105,225)', dash: 'solid' },
        'C-14': { color: 'rgb(0,0,255)', dash: 'solid' },
        'C-14-org': { color: 'rgb(0,0,255)', dash: 'solid' },
        'C-14-ind': { color: 'rgb(0,0,255)', dash: 'dash' },
        'C-14-inorg': { color: 'rgb(0,0,255)', dash: 'dot' },
        'Ca-41': { color: 'rgb(128,0,128)', dash: 'solid' },
        'Cd-113m': { color: 'rgb(124,252,0)', dash: 'solid' },
        'Cl-36': { color: 'rgb(210,105,30)', dash: 'solid' },
        'Cm-243': { color: 'rgb(175,238,238)', dash: 'solid' },
        'Cm-242': { color: 'rgb(175,238,238)', dash: 'dash' },
        'Cm-244': { color: 'rgb(175,238,238)', dash: 'dot' },
        'Cm-245': { color: 'rgb(175,238,238)', dash: 'dash' },
        'Cm-246': { color: 'rgb(175,238,238)', dash: 'dashdot' },
        'Co-60': { color: 'rgb(0,255,127)', dash: 'solid' },
        'Cs-135': { color: 'rgb(0,128,0)', dash: 'solid' },
        'Cs-137': { color: 'rgb(0,128,0)', dash: 'dash' },
        'Eu-152': { color: 'rgb(205,133,63)', dash: 'solid' },
        'Eu-150': { color: 'rgb(205,133,63)', dash: 'dash' },
        'Gd-148': { color: 'rgb(255,255,0)', dash: 'solid' },
        'H-3': { color: 'rgb(0,0,205)', dash: 'solid' },
        'Ho-166m': { color: 'rgb(100,149,237)', dash: 'solid' },
        'I-129': { color: 'rgb(30,144,255)', dash: 'solid' },
        'K-40': { color: 'rgb(139,69,19)', dash: 'solid' },
        'La-137': { color: 'rgb(255,248,220)', dash: 'solid' },
        'Mo-93': { color: 'rgb(0,255,0)', dash: 'solid' },
        'Nb-93m': { color: 'rgb(210,180,140)', dash: 'solid' },
        'Nb-94': { color: 'rgb(210,180,140)', dash: 'dash' },
        'Ni-59': { color: 'rgb(255,0,255)', dash: 'solid' },
        'Ni-63': { color: 'rgb(255,0,255)', dash: 'dash' },
        'Np-237': { color: 'rgb(218,165,32)', dash: 'solid' },
        'Pa-231': { color: 'rgb(85,107,47)', dash: 'solid' },
        'Pb-210': { color: 'rgb(148,0,211)', dash: 'dash' },
        'Pd-107': { color: 'rgb(216,191,216)', dash: 'solid' },
        'Po-210': { color: 'rgb(148,0,211)', dash: 'dot' },
        'Pu-239': { color: 'rgb(0,255,255)', dash: 'solid' },
        'Pu-242': { color: 'rgb(0,255,255)', dash: 'dash' },
        'Pu-238': { color: 'rgb(0,255,255)', dash: 'dot' },
        'Pu-240': { color: 'rgb(0,255,255)', dash: 'dash' },
        'Pu-241': { color: 'rgb(0,255,255)', dash: 'dashdot' },
        'Ra-226': { color: 'rgb(148,0,211)', dash: 'solid' },
        'Ra-228': { color: 'rgb(148,0,211)', dash: 'dash' },
        'Re-186m': { color: 'rgb(255,160,122)', dash: 'solid' },
        'Se-79': { color: 'rgb(112,128,144)', dash: 'solid' },
        'Si-32': { color: 'rgb(255,228,181)', dash: 'solid' },
        'Sm-151': { color: 'rgb(138,43,226)', dash: 'solid' },
        'Sn-126': { color: 'rgb(0,0,0)', dash: 'solid' },
        'Sr-90': { color: 'rgb(255,215,0)', dash: 'solid' },
        'Tb-157': { color: 'rgb(221,160,221)', dash: 'solid' },
        'Tb-158': { color: 'rgb(221,160,221)', dash: 'dash' },
        'Tc-99': { color: 'rgb(0,0,128)', dash: 'solid' },
        'Th-230': { color: 'rgb(75,0,130)', dash: 'solid' },
        'Th-228': { color: 'rgb(75,0,130)', dash: 'dash' },
        'Th-229': { color: 'rgb(75,0,130)', dash: 'dot' },
        'Th-232': { color: 'rgb(75,0,130)', dash: 'dash' },
        'Ti-44': { color: 'rgb(218,112,214)', dash: 'solid' },
        'U-238': { color: 'rgb(255,0,0)', dash: 'solid' },
        'U-235': { color: 'rgb(255,0,0)', dash: 'dash' },
        'U-234': { color: 'rgb(255,0,0)', dash: 'dot' },
        'U-233': { color: 'rgb(255,0,0)', dash: 'dash' },
        'U-236': { color: 'rgb(255,0,0)', dash: 'dashdot' },
        'U-232': { color: 'rgb(255,0,0)', dash: 'longdash' },
        'Zr-93': { color: 'rgb(144,238,144)', dash: 'solid' }
      };
      
      const defaultStyle = { color: null, dash: 'solid', width: 2 };
      
      if (name in lineStyles) {
        return { ...defaultStyle, ...lineStyles[name] };
      }
      
      return defaultStyle;
    }

    function checkGroupForRadionuclides(file, path) {
      try {
        const group = file.get(path);
        if (!group || group.type.toLowerCase() !== 'group') {
          return false;
        }
        
        let hasRadionuclidesIndex = false;
        let isTimeDependentGroup = false;
        
        if (group.attrs && typeof group.attrs === 'object') {
          for (const attrName in group.attrs) {
            if (attrName === 'IndexLists') {
              const attrObj = group.attrs[attrName];
              if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                const value = attrObj.value;
                if (Array.isArray(value) && value.includes('Radionuclides')) {
                  hasRadionuclidesIndex = true;
                } else if (typeof value === 'string' && value === 'Radionuclides') {
                  hasRadionuclidesIndex = true;
                }
              }
            }
            
            if (attrName === 'time_dependent') {
              const attrObj = group.attrs[attrName];
              if (attrObj && typeof attrObj.value !== 'undefined') {
                const value = attrObj.value;
                isTimeDependentGroup = value === true || value === 1 || value === 'TRUE' || value === 'True';
              }
            }
          }
        }
        
        return hasRadionuclidesIndex && isTimeDependentGroup;
      } catch (e) {
        console.warn('Error checking group for radionuclides:', e);
        return false;
      }
    }

    function updateChartScales() {
      if (!currentChartData) return;
      
      const xScale = document.getElementById('xAxisScale').value;
      const yScale = document.getElementById('yAxisScale').value;
      
      const update = {
        'xaxis.type': xScale,
        'yaxis.type': yScale
      };
      
      Plotly.relayout('plotlyChart', update);
    }

    function applyReleasePresetView() {
      if (!currentChartData) return;
      
      document.getElementById('xAxisScale').value = 'log';
      document.getElementById('yAxisScale').value = 'log';
      
      const update = {
        'xaxis.type': 'log',
        'xaxis.range': [Math.log10(100), Math.log10(100000)],
        'yaxis.type': 'log',
        'yaxis.range': [Math.log10(10000), Math.log10(1e9)]
      };
      
      Plotly.relayout('plotlyChart', update);
    }

    function applyDosePresetView() {
      if (!currentChartData) return;
      
      document.getElementById('xAxisScale').value = 'log';
      document.getElementById('yAxisScale').value = 'log';
      
      const update = {
        'xaxis.type': 'log',
        'xaxis.range': [Math.log10(1000), Math.log10(1e5)],
        'yaxis.type': 'log',
        'yaxis.range': [Math.log10(1e-10), Math.log10(1e-5)]
      };
      
      Plotly.relayout('plotlyChart', update);
    }

    function downloadChartData() {
      if (!currentChartData) {
        alert('No chart data available');
        return;
      }
      
      let csv = 'Series,X,Y\n';
      
      for (const trace of currentChartData.traces) {
        const name = trace.name;
        for (let i = 0; i < trace.x.length; i++) {
          csv += `"${name}",${trace.x[i]},${trace.y[i]}\n`;
        }
      }
      
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `chart_data_${Date.now()}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    function createPlotlyChart(path) {
      const plotDiv = document.getElementById('plotlyChart');
      const chartContainer = document.getElementById('plotlyChartContainer');
      plotDiv.innerHTML = '';
      
      const traces = [];
      const enabledFiles = getEnabledFiles();
      
      let timeUnit = '';
      let yAxisUnit = '';
      let yAxisName = path.split('/').pop();
      
      if (enabledFiles.length > 0) {
        const firstFile = loadedFiles[enabledFiles[0]];
        timeUnit = getTimeUnit(firstFile);
        
        // Get y-axis unit from dataset
        try {
          const dataset = firstFile.get(path);
          if (dataset && dataset.attrs && typeof dataset.attrs === 'object') {
            for (const attrName in dataset.attrs) {
              if (attrName === 'unit') {
                const attrObj = dataset.attrs[attrName];
                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                  yAxisUnit = attrObj.value;
                }
              }
            }
          }
        } catch (e) {
          console.warn('Could not read unit from dataset:', e);
        }
      }
      
      for (const fileKey of enabledFiles) {
        const file = loadedFiles[fileKey];
        
        if (!checkDatasetExistsInFile(file, path)) {
          continue;
        }
        
        try {
          const dataset = file.get(path);
          
          if (!isTimeDependent(dataset)) {
            continue;
          }
          
          const timeData = getTimeData(file);
          if (!timeData) {
            console.warn(`No /time dataset found in ${fileKey}`);
            continue;
          }
          
          let yData;
          if (typeof dataset.value !== 'undefined') {
            yData = dataset.value;
          } else if (typeof dataset.toArray === 'function') {
            yData = dataset.toArray();
          }
          
          if (yData) {
            let yArray;
            if (Array.isArray(yData)) {
              yArray = yData;
            } else if (yData && typeof yData === 'object' && yData.length !== undefined) {
              yArray = Array.from(yData);
            } else {
              yArray = [yData];
            }
            
            // Check if probabilistic and take mean
            let isProbabilistic = false;
            if (dataset.attrs && typeof dataset.attrs === 'object') {
              for (const attrName in dataset.attrs) {
                if (attrName === 'probabilistic') {
                  const attrObj = dataset.attrs[attrName];
                  if (attrObj && typeof attrObj.value !== 'undefined') {
                    const value = attrObj.value;
                    isProbabilistic = value === true || value === 1 || value === 'TRUE' || value === 'True';
                  }
                }
              }
            }
            
            if (isProbabilistic) {
              
              if (Array.isArray(yArray[0])) {
                // Data is [time, realizations] - take mean across realizations
                yArray = yArray.map(timeSlice => {
                  if (Array.isArray(timeSlice)) {
                    const sum = timeSlice.reduce((a, b) => a + b, 0);
                    return sum / timeSlice.length;
                  }
                  return timeSlice;
                });
              } else if (yArray.length > timeData.length && yArray.length % timeData.length === 0) {
                const numRealizations = Math.floor(yArray.length / timeData.length);
                                
                // If data layout is [t1_r1, t1_r2, ..., t1_rN, t2_r1, t2_r2, ...] (time-major)
                // then elements at boundary (t2_r1) should be different from t1_r1
                // If data layout is [r1_t1, r1_t2, ..., r1_tN, r2_t1, ...] (realization-major)
                // then elements at boundary (r2_t1) should be similar to r1_t1
                const means = [];
                // Layout is likely [t1_r1, t1_r2, ..., t2_r1, t2_r2, ...] (time-major)
                for (let t = 0; t < timeData.length; t++) {
                  let sum = 0;
                  for (let r = 0; r < numRealizations; r++) {
                    sum += yArray[t * numRealizations + r];
                  }
                  means.push(sum / numRealizations);
                }
                yArray = means;
              } else {
              }
              
            }

            if (timeData.length !== yArray.length) {
              console.warn(`Time data length (${timeData.length}) doesn't match data length (${yArray.length}) for ${fileKey}`);
              const minLength = Math.min(timeData.length, yArray.length);
              const trimmedTimeData = timeData.slice(0, minLength);
              const trimmedYData = yArray.slice(0, minLength);
              
              traces.push({
                x: trimmedTimeData,
                y: trimmedYData,
                mode: 'lines+markers',
                name: fileKey,
                type: 'scatter'
              });
            } else {
              traces.push({
                x: timeData,
                y: yArray,
                mode: 'lines+markers',
                name: fileKey,
                type: 'scatter'
              });
            }
          }
        } catch (e) {
          console.error(`Error creating trace for ${fileKey}:`, e);
        }
      }
      
      if (traces.length > 0) {
        const xScale = document.getElementById('xAxisScale').value;
        const yScale = document.getElementById('yAxisScale').value;
        
        const yAxisTitle = yAxisUnit ? `${yAxisName} (${yAxisUnit})` : yAxisName;
        
        const layout = {
          title: {
            text: path,
            font: { size: 14 },
            xanchor: 'left',
            x: 0
          },
          xaxis: { 
            title: timeUnit ? `Time (${timeUnit})` : 'Time',
            type: xScale
          },
          yaxis: { 
            title: yAxisTitle,
            type: yScale,
            showexponent: 'all',
            exponentformat: 'power'
          },
          hovermode: 'closest',
          showlegend: true,
          legend: {
            x: 1.02,
            y: 1,
            xanchor: 'left',
            yanchor: 'top'
          },
          margin: {
            r: 150
          }
        };
        
        const config = {
            displayLogo:false,
            scrollZoom: true,
            showLink:   false,
            plotlyServerURL:"https://chart-studio.plotly.com",
            modeBarButtonsToAdd: ['v1hovermode'],
            responsive: true,
            toImageButtonOptions: {
              format: 'svg',
              filename: 'chart',
              height: 600,
              width: 800,
              scale: 1
            }
        };

        currentChartData = { traces, layout, path };
        chartContainer.classList.add('visible');
        Plotly.newPlot('plotlyChart', traces, layout, config).then(() => {
          setupDynamicLegend(document.getElementById('plotlyChart'));
        });
      } else {
        chartContainer.classList.remove('visible');
        currentChartData = null;
      }
    }

    function createMultiDatasetChart(paths) {
      const plotDiv = document.getElementById('plotlyChart');
      const chartContainer = document.getElementById('plotlyChartContainer');
      plotDiv.innerHTML = '';
      
      const traces = [];
      const enabledFiles = getEnabledFiles();
      
      let timeUnit = '';
      const yAxisUnits = new Set();
      
      if (enabledFiles.length > 0) {
        const firstFile = loadedFiles[enabledFiles[0]];
        timeUnit = getTimeUnit(firstFile);
      }
      
      // Color palette for different datasets
      const colors = [
        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
        '#1abc9c', '#e67e22', '#34495e', '#c0392b', '#2980b9',
        '#27ae60', '#f1c40f', '#8e44ad', '#16a085', '#d35400'
      ];
      
      for (const [pathIndex, path] of paths.entries()) {
        const datasetName = path.split('/').pop();
        const baseColor = colors[pathIndex % colors.length];
        
        for (const [fileIndex, fileKey] of enabledFiles.entries()) {
          const file = loadedFiles[fileKey];
          
          if (!checkDatasetExistsInFile(file, path)) {
            continue;
          }
          
          try {
            const dataset = file.get(path);
            
            if (!isTimeDependent(dataset)) {
              continue;
            }
            
            // Get unit
            let yAxisUnit = '';
            if (dataset.attrs && typeof dataset.attrs === 'object') {
              for (const attrName in dataset.attrs) {
                if (attrName === 'unit') {
                  const attrObj = dataset.attrs[attrName];
                  if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                    yAxisUnit = attrObj.value;
                    yAxisUnits.add(yAxisUnit);
                  }
                }
              }
            }
            
            const timeData = getTimeData(file);
            if (!timeData) {
              console.warn(`No /time dataset found in ${fileKey}`);
              continue;
            }
            
            let yData;
            if (typeof dataset.value !== 'undefined') {
              yData = dataset.value;
            } else if (typeof dataset.toArray === 'function') {
              yData = dataset.toArray();
            }
            
            if (yData) {
              let yArray;
              if (Array.isArray(yData)) {
                yArray = yData;
              } else if (yData && typeof yData === 'object' && yData.length !== undefined) {
                yArray = Array.from(yData);
              } else {
                yArray = [yData];
              }
              
              // Handle probabilistic data (take mean)
              let isProbabilistic = false;
              if (dataset.attrs && typeof dataset.attrs === 'object') {
                for (const attrName in dataset.attrs) {
                  if (attrName === 'probabilistic') {
                    const attrObj = dataset.attrs[attrName];
                    if (attrObj && typeof attrObj.value !== 'undefined') {
                      const value = attrObj.value;
                      isProbabilistic = value === true || value === 1 || value === 'TRUE' || value === 'True';
                    }
                  }
                }
              }
              
              if (isProbabilistic) {
                if (Array.isArray(yArray[0])) {
                  yArray = yArray.map(timeSlice => {
                    if (Array.isArray(timeSlice)) {
                      const sum = timeSlice.reduce((a, b) => a + b, 0);
                      return sum / timeSlice.length;
                    }
                    return timeSlice;
                  });
                } else if (yArray.length > timeData.length && yArray.length % timeData.length === 0) {
                  const numRealizations = Math.floor(yArray.length / timeData.length);
                                    
                  const means = [];
                  
                  for (let t = 0; t < timeData.length; t++) {
                    let sum = 0;
                    for (let r = 0; r < numRealizations; r++) {
                      sum += yArray[t * numRealizations + r];
                    }
                    means.push(sum / numRealizations);
                  }
                  
                  yArray = means;
                }
              }

              const minLength = Math.min(timeData.length, yArray.length);
              const trimmedTimeData = timeData.slice(0, minLength);
              const trimmedYData = yArray.slice(0, minLength);
              
              // Adjust opacity and line style for multiple files
              let traceName = datasetName;
              let lineColor = baseColor;
              let lineWidth = 2;
              let lineDash = 'solid';
              
              if (enabledFiles.length > 1) {
                traceName = `${datasetName} (${fileKey})`;
                lineWidth = 1.5;
                // Use different dash styles for different files of same dataset
                const dashStyles = ['solid', 'dash', 'dot', 'dashdot'];
                lineDash = dashStyles[fileIndex % dashStyles.length];
              }
              
              traces.push({
                x: trimmedTimeData,
                y: trimmedYData,
                mode: 'lines+markers',
                name: traceName,
                line: {
                  color: lineColor,
                  dash: lineDash,
                  width: lineWidth
                },
                type: 'scatter',
                hovertemplate: `<b>${traceName}</b><br>Time: %{x}<br>Value: %{y}<extra></extra>`
              });
            }
          } catch (e) {
            console.error(`Error creating trace for ${path} in ${fileKey}:`, e);
          }
        }
      }
      
      if (traces.length > 0) {
        const xScale = document.getElementById('xAxisScale').value;
        const yScale = document.getElementById('yAxisScale').value;
        
        let yAxisTitle = 'Value';
        if (yAxisUnits.size === 1) {
          // All datasets have same unit
          yAxisTitle = `Value (${Array.from(yAxisUnits)[0]})`;
        } else if (yAxisUnits.size > 1) {
          // Multiple units
          yAxisTitle = `Value (${Array.from(yAxisUnits).join(', ')})`;
        }
        
        const layout = {
          title: {
            text: `Comparing ${paths.length} dataset${paths.length > 1 ? 's' : ''}`,
            font: { size: 14 },
            xanchor: 'left',
            x: 0
          },
          xaxis: { 
            title: timeUnit ? `Time (${timeUnit})` : 'Time',
            type: xScale
          },
          yaxis: { 
            title: yAxisTitle,
            type: yScale,
            showexponent: 'all',
            exponentformat: 'power'
          },
          hovermode: 'closest',
          showlegend: true,
          legend: {
            x: 1.02,
            y: 1,
            xanchor: 'left',
            yanchor: 'top'
          },
          margin: {
            r: 200
          }
        };
        
        const config = {
            displayLogo:false,
            scrollZoom: true,
            showLink:   false,
            plotlyServerURL:"https://chart-studio.plotly.com",
            modeBarButtonsToAdd: ['v1hovermode'],
            responsive: true,
            toImageButtonOptions: {
              format: 'svg',
              filename: 'multi_dataset_chart',
              height: 600,
              width: 800,
              scale: 1
            }
        };

        currentChartData = { traces, layout, paths };
        chartContainer.classList.add('visible');
        Plotly.newPlot('plotlyChart', traces, layout, config).then(() => {
          setupDynamicLegend(document.getElementById('plotlyChart'));
        });
      } else {
        chartContainer.classList.remove('visible');
        currentChartData = null;
      }
    }

    function createRadionuclidesChart(path) {
      const plotDiv = document.getElementById('plotlyChart');
      const chartContainer = document.getElementById('plotlyChartContainer');
      plotDiv.innerHTML = '';
      
      const traces = [];
      const enabledFiles = getEnabledFiles();
      
      let timeUnit = '';
      let yAxisUnit = '';
      let yAxisName = path.split('/').pop();
      
      if (enabledFiles.length > 0) {
        const firstFile = loadedFiles[enabledFiles[0]];
        timeUnit = getTimeUnit(firstFile);
      }
      
      for (const fileKey of enabledFiles) {
        const file = loadedFiles[fileKey];
        
        if (!checkDatasetExistsInFile(file, path)) {
          continue;
        }
        
        try {
          const group = file.get(path);
          if (!group || group.type.toLowerCase() !== 'group') {
            continue;
          }
          
          const timeData = getTimeData(file);
          if (!timeData) {
            console.warn(`No /time dataset found in ${fileKey}`);
            continue;
          }
          
          let datasetKeys = [];
          try {
            if (typeof group.keys === 'function') {
              datasetKeys = Array.from(group.keys());
            }
          } catch (e) {
            console.error('Error getting dataset keys:', e);
            continue;
          }
          
          for (const datasetKey of datasetKeys) {
            try {
              const dataset = group.get(datasetKey);
              if (!dataset || dataset.type.toLowerCase() !== 'dataset') {
                continue;
              }
              
              let yData;
              if (typeof dataset.value !== 'undefined') {
                yData = dataset.value;
              } else if (typeof dataset.toArray === 'function') {
                yData = dataset.toArray();
              }
              
              if (yData) {
                let yArray;
                if (Array.isArray(yData)) {
                  yArray = yData;
                } else if (yData && typeof yData === 'object' && yData.length !== undefined) {
                  yArray = Array.from(yData);
                } else {
                  yArray = [yData];
                }
                
                let isProbabilistic = false;
                if (dataset.attrs && typeof dataset.attrs === 'object') {
                  for (const attrName in dataset.attrs) {
                    if (attrName === 'probabilistic') {
                      const attrObj = dataset.attrs[attrName];
                      if (attrObj && typeof attrObj.value !== 'undefined') {
                        const value = attrObj.value;
                        isProbabilistic = value === true || value === 1 || value === 'TRUE' || value === 'True';
                      }
                    }
                  }
                }
                
                if (isProbabilistic) {
                  
                  if (Array.isArray(yArray[0])) {
                    yArray = yArray.map(timeSlice => {
                      if (Array.isArray(timeSlice)) {
                        const sum = timeSlice.reduce((a, b) => a + b, 0);
                        return sum / timeSlice.length;
                      }
                      return timeSlice;
                    });
                  } else if (yArray.length > timeData.length && yArray.length % timeData.length === 0) {
                    const numRealizations = Math.floor(yArray.length / timeData.length);
                    
                    const means = [];
                    
                    for (let t = 0; t < timeData.length; t++) {
                      let sum = 0;
                      for (let r = 0; r < numRealizations; r++) {
                        sum += yArray[t * numRealizations + r];
                      }
                      means.push(sum / numRealizations);
                    }
                    
                    yArray = means;
                  }
                }

                const minLength = Math.min(timeData.length, yArray.length);
                const trimmedTimeData = timeData.slice(0, minLength);
                const trimmedYData = yArray.slice(0, minLength);
                
                const lineStyle = getLineStyle(datasetKey);
                let traceName = datasetKey;
                let lineWidth = lineStyle.width;
                
                if (enabledFiles.length > 1 && enabledFiles.indexOf(fileKey) > 0) {
                  traceName = `${datasetKey} (${fileKey})`;
                  lineWidth = lineWidth / 2;
                }
                
                traces.push({
                  x: trimmedTimeData,
                  y: trimmedYData,
                  mode: 'lines',
                  name: traceName,
                  line: {
                    color: lineStyle.color,
                    dash: lineStyle.dash,
                    width: lineWidth
                  },
                  type: 'scatter'
                });
              }
            } catch (e) {
              console.error(`Error creating trace for ${datasetKey} in ${fileKey}:`, e);
            }
          }
        } catch (e) {
          console.error(`Error processing group for ${fileKey}:`, e);
        }
      }
      
      if (traces.length > 0) {
        const firstFile = loadedFiles[enabledFiles[0]];
        try {
          const group = firstFile.get(path);
          if (group && group.attrs && typeof group.attrs === 'object') {
            for (const attrName in group.attrs) {
              if (attrName === 'unit') {
                const attrObj = group.attrs[attrName];
                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                  yAxisUnit = attrObj.value;
                }
              }
            }
          }
        } catch (e) {
          console.warn('Could not read unit from group:', e);
        }
        
        const xScale = document.getElementById('xAxisScale').value;
        const yScale = document.getElementById('yAxisScale').value;
        
        const yAxisTitle = yAxisUnit ? `${yAxisName} (${yAxisUnit})` : yAxisName;
        
        const layout = {
          title: {
            text: path,
            font: { size: 14 },
            xanchor: 'left',
            x: 0
          },
          xaxis: { 
            title: timeUnit ? `Time (${timeUnit})` : 'Time',
            type: xScale
          },
          yaxis: { 
            title: yAxisTitle,
            type: yScale,
            showexponent: 'all',
            exponentformat: 'power'
          },
          hovermode: 'closest',
          showlegend: true,
          legend: {
            x: 1.02,
            y: 1,
            xanchor: 'left',
            yanchor: 'top'
          },
          margin: {
            r: 150
          }
        };
        
        const config = {
            displayLogo:false,
            scrollZoom: true,
            showLink:   false,
            plotlyServerURL:"https://chart-studio.plotly.com",
            modeBarButtonsToAdd: ['v1hovermode'],
            responsive: true,
            toImageButtonOptions: {
              format: 'svg',
              filename: 'chart',
              height: 600,
              width: 800,
              scale: 1
            }
        };
        
        currentChartData = { traces, layout, path };
        chartContainer.classList.add('visible');
        Plotly.newPlot('plotlyChart', traces, layout, config).then(() => {
          setupDynamicLegend(document.getElementById('plotlyChart'));
        });
      } else {
        chartContainer.classList.remove('visible');
        currentChartData = null;
      }
    }
    let dynamicLegendEnabled = true;

    function toggleDynamicLegend() {
      dynamicLegendEnabled = document.getElementById('dynamicLegend').checked;
      
      const plotDiv = document.getElementById('plotlyChart');
      if (!plotDiv || !plotDiv.data || !plotDiv.layout) {
        return;
      }
      
      if (!dynamicLegendEnabled) {
        // Show all legend items using Plotly.react
        const newData = plotDiv.data.map(trace => ({
          ...trace,
          showlegend: true
        }));
        
        Plotly.react(plotDiv, newData, plotDiv.layout).then(() => {
          const statusEl = document.getElementById('legendStatus');
          if (statusEl) {
            statusEl.style.display = 'none';
          }
        });
      } else {
        // Re-apply dynamic filtering based on current view
        const layout = plotDiv.layout;
        
        // Get current ranges
        let xRange = layout.xaxis?.range;
        let yRange = layout.yaxis?.range;
        
        if (!xRange || !yRange) {
          // If no zoom applied yet, show all
          return;
        }
        
        // Convert log scale ranges if needed
        const xIsLog = layout.xaxis?.type === 'log';
        const yIsLog = layout.yaxis?.type === 'log';
        
        const xMin = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
        const xMax = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
        const yMin = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
        const yMax = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
        
        // Check each trace for visibility
        let visibleCount = 0;
        const newData = plotDiv.data.map((trace) => {
          let isVisible = false;
          
          // Check if any point is within the visible range
          for (let j = 0; j < trace.x.length; j++) {
            const x = trace.x[j];
            const y = trace.y[j];
            
            if (x === null || x === undefined || y === null || y === undefined) {
              continue;
            }
            
            if (x >= xMin && x <= xMax && y >= yMin && y <= yMax) {
              isVisible = true;
              break;
            }
          }
          
          if (isVisible) visibleCount++;
          
          return {
            ...trace,
            showlegend: isVisible
          };
        });
        
        // Use Plotly.react to force redraw
        Plotly.react(plotDiv, newData, plotDiv.layout).then(() => {
          const totalCount = plotDiv.data.length;
          const statusEl = document.getElementById('legendStatus');
          
          if (statusEl) {
            if (visibleCount < totalCount) {
              statusEl.textContent = `Showing ${visibleCount}/${totalCount} traces`;
              statusEl.style.display = 'block';
            } else {
              statusEl.style.display = 'none';
            }
          }
        });
      }
    }
    function setupDynamicLegend(plotDiv) {
      plotDiv.on('plotly_relayout', function(eventData) {
        if (!dynamicLegendEnabled) return;
        
        // Check if this is a zoom/pan event
        if (!eventData || (!eventData['xaxis.range[0]'] && !eventData['xaxis.range'] && !eventData['xaxis.autorange'])) {
          return;
        }
        
        const fullData = plotDiv.data;
        const layout = plotDiv.layout;
        
        // Get current axis ranges
        let xRange, yRange;
        
        if (eventData['xaxis.autorange'] || eventData['yaxis.autorange']) {
          // Autorange - show all traces
          const visibility = fullData.map(() => true);
          Plotly.restyle(plotDiv, { showlegend: visibility });
          
          // Update status
          const statusEl = document.getElementById('legendStatus');
          if (statusEl) {
            statusEl.style.display = 'none';
          }
          return;
        }
        
        if (eventData['xaxis.range[0]'] !== undefined) {
          xRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
        } else if (eventData['xaxis.range']) {
          xRange = eventData['xaxis.range'];
        } else if (layout.xaxis && layout.xaxis.range) {
          xRange = layout.xaxis.range;
        }
        
        if (eventData['yaxis.range[0]'] !== undefined) {
          yRange = [eventData['yaxis.range[0]'], eventData['yaxis.range[1]']];
        } else if (eventData['yaxis.range']) {
          yRange = eventData['yaxis.range'];
        } else if (layout.yaxis && layout.yaxis.range) {
          yRange = layout.yaxis.range;
        }
        
        if (!xRange || !yRange) return;
        
        // Convert log scale ranges if needed
        const xIsLog = layout.xaxis && layout.xaxis.type === 'log';
        const yIsLog = layout.yaxis && layout.yaxis.type === 'log';
        
        const xMin = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
        const xMax = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
        const yMin = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
        const yMax = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
        
        // Check each trace for visibility
        const visibility = fullData.map((trace, i) => {
          // Check if any point is within the visible range
          for (let j = 0; j < trace.x.length; j++) {
            const x = trace.x[j];
            const y = trace.y[j];
            
            // Skip invalid values
            if (x === null || x === undefined || y === null || y === undefined) {
              continue;
            }
            
            // Check if point is in visible range
            if (x >= xMin && x <= xMax && y >= yMin && y <= yMax) {
              return true;
            }
          }
          return false;
        });
        
        // Use Plotly.restyle with array of booleans
        Plotly.restyle(plotDiv, { showlegend: visibility }).then(() => {
          // Update status counter
          const visibleCount = visibility.filter(v => v).length;
          const totalCount = fullData.length;
          const statusEl = document.getElementById('legendStatus');
          
          if (statusEl) {
            if (visibleCount < totalCount) {
              statusEl.textContent = `Showing ${visibleCount}/${totalCount} traces`;
              statusEl.style.display = 'block';
            } else {
              statusEl.style.display = 'none';
            }
          }
        });
      });
    }


    function showNodeAttributes(path, isGroup = false) {
      const infoDiv = document.getElementById('info');
      infoDiv.innerHTML = '<div class="loading">Loading...</div>';
      
      const jsonReplacer = (key, value) => {
        if (typeof value === 'bigint') {
          return value.toString() + 'n';
        }
        if (value && typeof value === 'object' && value.length !== undefined) {
          return Array.from(value);
        }
        return value;
      };
      
      try {
        const enabledFiles = getEnabledFiles();
        let html = '';
        let hasTimeDependentData = false;
        let isRadionuclidesGroup = false;
        
        if (isGroup && enabledFiles.length > 0) {
          const firstFile = loadedFiles[enabledFiles[0]];
          isRadionuclidesGroup = checkGroupForRadionuclides(firstFile, path);
          selectedIsRadionuclidesGroup = isRadionuclidesGroup;
        } else {
          selectedIsRadionuclidesGroup = false;
        }
        
        for (const fileKey of enabledFiles) {
          const file = loadedFiles[fileKey];
          
          if (!checkDatasetExistsInFile(file, path)) {
            continue;
          }
          
          const node = file.get(path);
          if (!node) continue;
          
          const isFirstFile = fileKey === enabledFiles[0];
          const fileColor = isFirstFile ? '#0066cc' : '#10b981';
          
          html += `<div class="file-data-section" style="border-left-color: ${fileColor};">`;
          html += `<h4>${escapeHtml(fileKey)}</h4>`;
          
          if (isFirstFile) {
            html += `<div class="info-section">
              <div class="info-label">Path</div>
              <div class="info-content">${escapeHtml(path)}</div>
            </div>`;
            
            html += `<div class="info-section">
              <div class="info-label">Type</div>
              <div class="info-content">${escapeHtml(String(node.type))}</div>
            </div>`;
            
            if (!isGroup && node.dtype) {
              const readableDtype = formatDataType(node.dtype);
              html += `<div class="info-section">
                <div class="info-label">Data Type</div>
                <div class="info-content">${escapeHtml(readableDtype)}</div>
              </div>`;
            }
            
            if (node.shape && Array.isArray(node.shape)) {
              html += `<div class="info-section">
                <div class="info-label">Shape</div>
                <div class="info-content">${node.shape.join(', ')}</div>
              </div>`;
            }
          }
          
          if (!isGroup) {
            if (isTimeDependent(node)) {
              hasTimeDependentData = true;
            }
            
            try {
              let data;
              if (typeof node.value !== 'undefined') {
                data = node.value;
              } else if (typeof node.toArray === 'function') {
                data = node.toArray();
              }
              
              if (data !== undefined) {
                let preview;
                let itemCount;
                let fullData;
                
                if (Array.isArray(data)) {
                  preview = data.slice(0, 100);
                  itemCount = data.length;
                  fullData = data;
                } else if (data && typeof data === 'object' && data.length !== undefined) {
                  preview = Array.from(data).slice(0, 100);
                  itemCount = data.length;
                  fullData = Array.from(data);
                } else {
                  preview = [data];
                  itemCount = 1;
                  fullData = [data];
                }
                
                const isScalar = itemCount === 1;
                const downloadBtnId = `downloadData_${fileKey.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`;
                
                html += `<div class="info-section">
                  <div class="info-label" style="display: flex; align-items: center; justify-content: space-between;">
                    <span>Data Preview (first ${preview.length}/${itemCount} items)</span>
                    ${!isScalar ? `<button 
                      id="${downloadBtnId}" 
                      class="download-data-btn" 
                      style="padding: 4px 8px; background: var(--color-kvot-background); color: var(--color-kvot-bright); border: none; border-radius: 3px; cursor: pointer; font-size: 11px; font-weight: 500; transition: all 0.2s;"
                      onmouseover="this.style.background='var(--color-kvot-primary)'" 
                      onmouseout="this.style.background='var(--color-kvot-background)'"
                      title="Download full dataset as CSV">
                      ‚¨á Download CSV
                    </button>` : ''}
                  </div>
                  <div class="info-content">${escapeHtml(JSON.stringify(preview, jsonReplacer, 2))}</div>
                </div>`;
                
                // Store the full data for download
                if (!isScalar) {
                  setTimeout(() => {
                    const downloadBtn = document.getElementById(downloadBtnId);
                    if (downloadBtn) {
                      downloadBtn.addEventListener('click', () => {
                        // Get index attribute if it exists
                        let headerRow = null;
                        try {
                          if (node.attrs && typeof node.attrs === 'object') {
                            for (const attrName in node.attrs) {
                              if (attrName === 'index') {
                                const attrObj = node.attrs[attrName];
                                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                                  const indexValue = attrObj.value;
                                  if (Array.isArray(indexValue)) {
                                    headerRow = indexValue;
                                  } else if (indexValue && typeof indexValue === 'object' && indexValue.length !== undefined) {
                                    headerRow = Array.from(indexValue);
                                  }
                                }
                              }
                            }
                          }
                        } catch (e) {
                          console.warn('Could not read index attribute:', e);
                        }
                        
                        // Determine data shape
                        let csvContent = '';
                        const shape = node.shape || [];
                        
                        if (shape.length === 1) {
                          // 1D array - single column
                          if (headerRow && headerRow.length === 1) {
                            csvContent += escapeCSV(headerRow[0]) + '\n';
                          }
                          fullData.forEach(value => {
                            csvContent += escapeCSV(value) + '\n';
                          });
                        } else if (shape.length === 2) {
                          // 2D array - rows and columns
                          const numRows = shape[0];
                          const numCols = shape[1];
                          
                          // Add header if available
                          if (headerRow && headerRow.length === numCols) {
                            csvContent += headerRow.map(h => escapeCSV(h)).join(',') + '\n';
                          }
                          
                          // Add data rows
                          for (let i = 0; i < numRows; i++) {
                            const row = [];
                            for (let j = 0; j < numCols; j++) {
                              row.push(escapeCSV(fullData[i * numCols + j]));
                            }
                            csvContent += row.join(',') + '\n';
                          }
                        } else if (shape.length === 0) {
                          // Scalar or flat array
                          if (headerRow && headerRow.length > 0) {
                            csvContent += headerRow.map(h => escapeCSV(h)).join(',') + '\n';
                          }
                          
                          // Try to determine if it's a multi-column array by checking header length
                          if (headerRow && headerRow.length > 1) {
                            const numCols = headerRow.length;
                            const numRows = Math.floor(fullData.length / numCols);
                            for (let i = 0; i < numRows; i++) {
                              const row = [];
                              for (let j = 0; j < numCols; j++) {
                                row.push(escapeCSV(fullData[i * numCols + j]));
                              }
                              csvContent += row.join(',') + '\n';
                            }
                          } else {
                            // Single column
                            fullData.forEach(value => {
                              csvContent += escapeCSV(value) + '\n';
                            });
                          }
                        } else {
                          // Higher dimensional - flatten to 2D
                          console.warn('Multi-dimensional array, flattening to 2D');
                          if (headerRow) {
                            csvContent += headerRow.map(h => escapeCSV(h)).join(',') + '\n';
                          }
                          
                          const lastDim = shape[shape.length - 1];
                          const numRows = Math.floor(fullData.length / lastDim);
                          
                          for (let i = 0; i < numRows; i++) {
                            const row = [];
                            for (let j = 0; j < lastDim; j++) {
                              row.push(escapeCSV(fullData[i * lastDim + j]));
                            }
                            csvContent += row.join(',') + '\n';
                          }
                        }
                        
                        // Create and download CSV
                        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const safePath = path.replace(/[^a-zA-Z0-9]/g, '_');
                        const safeFileName = fileKey.replace(/\.[^/.]+$/, '');
                        a.download = `${safeFileName}${safePath}_data.csv`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                      });
                    }
                  }, 0);
                }
              }
            } catch (e) {
              console.warn('Could not read data:', e.message);
            }
          }
          
          const attrs = {};
          let hasAttributes = false;
          
          try {
            if (node.attrs && typeof node.attrs === 'object') {
              for (const attrName in node.attrs) {
                if (!attrName.startsWith('_') && typeof node.attrs[attrName] === 'object') {
                  try {
                    const attrObj = node.attrs[attrName];
                    let attrValue;
                    
                    if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                      attrValue = attrObj.value;
                    } else {
                      attrValue = attrObj;
                    }
                    
                    attrs[attrName] = attrValue;
                    hasAttributes = true;
                  } catch (e) {
                    attrs[attrName] = `(unreadable: ${e.message})`;
                  }
                }
              }
            }
          } catch (e) {
            console.warn('Error reading attributes:', e.message);
          }
          
          if (hasAttributes && Object.keys(attrs).length > 0) {
            let attrsHtml = '<table style="width:100%; border-collapse: collapse; font-family: monospace; font-size: 11px;">';
            attrsHtml += '<tr style="border-bottom: 1px solid #e5e7eb; background: #f3f4f6;"><th style="text-align: left; padding: 6px; font-weight: 600;">Name</th><th style="text-align: left; padding: 6px; font-weight: 600;">Value</th></tr>';
            
            for (const [key, value] of Object.entries(attrs)) {
              let displayValue;
              if (typeof value === 'string') {
                displayValue = value;
              } else if (Array.isArray(value)) {
                displayValue = `[${value.join(', ')}]`;
              } else if (value === null) {
                displayValue = 'null';
              } else if (value === undefined) {
                displayValue = 'undefined';
              } else if (typeof value === 'object') {
                if (value.length !== undefined) {
                  displayValue = `[${Array.from(value).slice(0, 10).join(', ')}${value.length > 10 ? '...' : ''}]`;
                } else {
                  displayValue = JSON.stringify(value, jsonReplacer, 0);
                }
              } else if (typeof value === 'bigint') {
                displayValue = value.toString() + 'n';
              } else {
                displayValue = String(value);
              }
              
              attrsHtml += `<tr style="border-bottom: 1px solid #f0f0f0;">
                <td style="padding: 6px; word-break: break-word; max-width: 150px;"><strong>${escapeHtml(key)}</strong></td>
                <td style="padding: 6px; word-break: break-word; color: #555;">${escapeHtml(displayValue)}</td>
              </tr>`;
            }
            
            attrsHtml += '</table>';
            html += `<div class="info-section">
              <div class="info-label">Attributes (${Object.keys(attrs).length})</div>
              <div class="info-content" style="padding: 0; overflow-x: auto;">${attrsHtml}</div>
            </div>`;
          }
          
          html += '</div>';
        }
        
        infoDiv.innerHTML = html || '<div style="color:#999;">No data available for this path</div>';
        
        if (isRadionuclidesGroup) {
          createRadionuclidesChart(path);
        } else if (hasTimeDependentData && !isGroup) {
          createPlotlyChart(path);
        } else {
          document.getElementById('plotlyChartContainer').classList.remove('visible');
          currentChartData = null;
        }
      } catch (e) {
        infoDiv.innerHTML = `<div class="error">Error: ${escapeHtml(e.message)}</div>`;
        console.error(e);
      }
    }

    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const files = Array.from(e.target.files || []);
      if (files.length === 0) return;
      
      try {
        await waitForH5Wasm();
        
        for (const file of files) {
          try {
            const buffer = await file.arrayBuffer();
            
            const { FS, File } = window.h5wasm;
            if (!FS || !File) throw new Error('h5wasm not ready');
            
            const filename = `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.h5`;
            const data = new Uint8Array(buffer);
            
            FS.writeFile('/' + filename, data);
            const hf = new File('/' + filename, 'r');
            
            loadedFiles[file.name] = hf;
            fileStates[file.name] = true;
            if (!fileOrder.includes(file.name)) {
              fileOrder.push(file.name);
            }
          } catch (err) {
            console.error(`Error loading ${file.name}:`, err);
            alert(`Failed to load ${file.name}`);
          }
        }
        
        updateTabs();
        await refreshTreeStructure();
      } catch (err) {
        alert(`Error: ${err.message}`);
        console.error(err);
      }
      
      e.target.value = '';
    });

    let dragCounter = 0;

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    document.body.addEventListener('dragenter', (e) => {
      dragCounter++;
      document.getElementById('dropOverlay').classList.add('active');
    });

    document.body.addEventListener('dragleave', (e) => {
      dragCounter--;
      if (dragCounter === 0) {
        document.getElementById('dropOverlay').classList.remove('active');
      }
    });

    document.body.addEventListener('drop', (e) => {
      dragCounter = 0;
      document.getElementById('dropOverlay').classList.remove('active');
      
      const dt = e.dataTransfer;
      const files = dt.files;
      if (files.length > 0) {
        document.getElementById('fileInput').files = files;
        const event = new Event('change', { bubbles: true });
        document.getElementById('fileInput').dispatchEvent(event);
      }
    });

    function showMultipleDatasetAttributes(paths) {
      const infoDiv = document.getElementById('info');
      infoDiv.innerHTML = `<div class="loading">Loading ${paths.length} datasets...</div>`;
      
      const enabledFiles = getEnabledFiles();
      if (enabledFiles.length === 0) return;
      
      let html = `<div style="background: var(--color-kvot-bright); padding: 12px; border-radius: 6px; margin-bottom: 16px; font-weight: 600; color: var(--color-kvot-background);">
        üìä ${paths.length} datasets selected
      </div>`;
      
      let allTimeDependent = true;
      
      for (const path of paths) {
        html += `<div class="file-data-section" style="border-left-color: var(--color-kvot-accent);">`;
        html += `<h4>${escapeHtml(path)}</h4>`;
        
        const file = loadedFiles[enabledFiles[0]];
        try {
          const dataset = file.get(path);
          if (!dataset) continue;
          
          const isTimeDep = isTimeDependent(dataset);
          if (!isTimeDep) allTimeDependent = false;
          
          html += `<div class="info-section">
            <div class="info-label">Type</div>
            <div class="info-content">${escapeHtml(String(dataset.type))} ${isTimeDep ? '‚è±Ô∏è (time-dependent)' : ''}</div>
          </div>`;
          
          if (dataset.dtype) {
            const readableDtype = formatDataType(dataset.dtype);
            html += `<div class="info-section">
              <div class="info-label">Data Type</div>
              <div class="info-content">${escapeHtml(readableDtype)}</div>
            </div>`;
          }
          
          if (dataset.shape && Array.isArray(dataset.shape)) {
            html += `<div class="info-section">
              <div class="info-label">Shape</div>
              <div class="info-content">${dataset.shape.join(', ')}</div>
            </div>`;
          }
          
          // Show attributes
          const attrs = {};
          if (dataset.attrs && typeof dataset.attrs === 'object') {
            for (const attrName in dataset.attrs) {
              if (!attrName.startsWith('_') && typeof dataset.attrs[attrName] === 'object') {
                const attrObj = dataset.attrs[attrName];
                attrs[attrName] = attrObj?.value ?? attrObj;
              }
            }
          }
          
          if (Object.keys(attrs).length > 0) {
            html += `<div class="info-section">
              <div class="info-label">Key Attributes</div>
              <div class="info-content" style="font-size: 11px;">`;
            
            for (const [key, value] of Object.entries(attrs).slice(0, 5)) {
              let displayValue = String(value);
              if (displayValue.length > 50) {
                displayValue = displayValue.substring(0, 50) + '...';
              }
              html += `<strong>${escapeHtml(key)}:</strong> ${escapeHtml(displayValue)}<br>`;
            }
            
            html += `</div></div>`;
          }
          
        } catch (e) {
          html += `<div class="error">Error loading dataset: ${escapeHtml(e.message)}</div>`;
        }
        
        html += `</div>`;
      }
      
      infoDiv.innerHTML = html;
      
      // Create combined chart if all are time-dependent
      if (allTimeDependent && paths.length > 0) {
        createMultiDatasetChart(paths);
      } else {
        document.getElementById('plotlyChartContainer').classList.remove('visible');
        currentChartData = null;
      }
    }

    // Search functionality
    let searchTimeout = null;
    let currentSearchTerm = '';
    function wildcardToRegex(pattern) {
      // Escape special regex characters except *
      const escaped = pattern.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
      // Replace * with .*
      const regexPattern = escaped.replace(/\*/g, '.*');
      return new RegExp(regexPattern, 'i');
    }

    function highlightText(text, searchTerm) {
      if (!searchTerm) return escapeHtml(text);
      
      const regex = wildcardToRegex(searchTerm);
      const match = text.match(regex);
      
      if (!match) return escapeHtml(text);
      
      const matchStart = match.index;
      const matchEnd = matchStart + match[0].length;
      
      const before = escapeHtml(text.substring(0, matchStart));
      const matched = escapeHtml(text.substring(matchStart, matchEnd));
      const after = escapeHtml(text.substring(matchEnd));
      
      return `${before}<span class="search-highlight">${matched}</span>${after}`;
    }

    function filterTree(searchTerm) {
      currentSearchTerm = searchTerm;
      const tree = document.getElementById('tree');
      const allItems = tree.querySelectorAll('.tree-item');
      const allChildren = tree.querySelectorAll('.tree-group-children');
      
      if (!searchTerm.trim()) {
        // Clear search - show everything, remove highlights
        allItems.forEach(item => {
          item.classList.remove('search-hidden', 'search-match');
          const label = item.querySelector('.tree-label');
          if (label) {
            const originalText = label.textContent;
            label.innerHTML = escapeHtml(originalText);
          }
        });
        
        allChildren.forEach(child => {
          child.classList.remove('search-expanded');
          // Restore original expanded state based on parent
          const parentGroup = child.previousElementSibling;
          if (parentGroup && parentGroup.classList.contains('expanded')) {
            child.classList.add('expanded');
          } else {
            child.classList.remove('expanded');
          }
        });
        
        return;
      }
      
      const regex = wildcardToRegex(searchTerm);
      const matchingItems = new Set();
      const itemsToShow = new Set();
      
      // First pass: find all matching items
      allItems.forEach(item => {
        const label = item.querySelector('.tree-label');
        if (!label) return;
        
        const text = label.textContent;
        const matches = regex.test(text);
        
        if (matches) {
          matchingItems.add(item);
          item.classList.add('search-match');
          // Highlight the matching text
          label.innerHTML = highlightText(text, searchTerm);
        } else {
          item.classList.remove('search-match');
          label.innerHTML = escapeHtml(text);
        }
      });
      
      // Second pass: build set of items to show (matches + their parents)
      matchingItems.forEach(item => {
        itemsToShow.add(item);
        
        // Add all parent groups
        let current = item;
        while (current) {
          const parentChildren = current.closest('.tree-group-children');
          if (parentChildren) {
            const parentGroup = parentChildren.previousElementSibling;
            if (parentGroup && parentGroup.classList.contains('tree-item')) {
              itemsToShow.add(parentGroup);
              current = parentGroup;
            } else {
              break;
            }
          } else {
            break;
          }
        }
      });
      
      // Third pass: hide non-matching items, show matching items and parents
      allItems.forEach(item => {
        if (itemsToShow.has(item)) {
          item.classList.remove('search-hidden');
        } else {
          item.classList.add('search-hidden');
        }
      });
      
      // Fourth pass: expand parent groups of matches
      allChildren.forEach(child => {
        const parentGroup = child.previousElementSibling;
        if (parentGroup && itemsToShow.has(parentGroup)) {
          child.classList.add('search-expanded');
          if (parentGroup) {
            const toggle = parentGroup.querySelector('.tree-toggle');
            if (toggle) {
              toggle.classList.remove('collapsed');
            }
            parentGroup.classList.add('expanded');
          }
        } else if (!child.classList.contains('expanded')) {
          child.classList.remove('search-expanded');
        }
      });
    }

    // Setup search event listeners
    document.getElementById('treeSearch').addEventListener('input', (e) => {
      const searchTerm = e.target.value;
      const clearBtn = document.getElementById('clearSearch');
      
      if (searchTerm) {
        clearBtn.classList.add('visible');
      } else {
        clearBtn.classList.remove('visible');
      }
      
      // Debounce the search
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }
      
      searchTimeout = setTimeout(() => {
        filterTree(searchTerm);
      }, 200);
    });

    document.getElementById('clearSearch').addEventListener('click', () => {
      const searchInput = document.getElementById('treeSearch');
      searchInput.value = '';
      document.getElementById('clearSearch').classList.remove('visible');
      filterTree('');
      searchInput.focus();
    });

    // Handle Escape key to clear search
    document.getElementById('treeSearch').addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.getElementById('clearSearch').click();
      }
    });

    // Re-apply search filter after tree refresh
    const originalRefreshTreeStructure = refreshTreeStructure;
    refreshTreeStructure = async function() {
      await originalRefreshTreeStructure();
      const searchTerm = document.getElementById('treeSearch').value;
      if (searchTerm) {
        // Small delay to ensure DOM is updated
        setTimeout(() => filterTree(searchTerm), 50);
      }
    };
  </script>
</body>
</html>