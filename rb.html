<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="icon" type="image/png" sizes="16x16" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB8lBMVEUARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARHUARHUARHUARHUCRncUVIETU4AIS3oTU4ABRXYARHYANGlBdJkhXYi/0NypwNE8cZbC095OfqAAM2kAK2Ohus1Ug6Pf6O6OrcI2bJPr8fSzx9YAOGyguswpY4zf5+5XhKQyaZHs8fWctsoANWoAMmg/c5gsZY62ythKe57p7/NMfZ8AMGcAPG86b5VZhqbj6/Bah6br8PStw9MAN2sAKmKatslVg6Pg6O7k6/CpwNEANGo0a5IeW4aqwdGswtJEd5uwxtUvaJAAN2wDRncBRXYJS3sJS3sESHgJTHsARXYARXYARHUARHUARXYARXYARHUARHUARXYARHUARHUARXYARXYARHYARHUNTn0VVIEGSHgRUX8LTHsWVYIQUX+8ztvW4emBo7ulvc6MqsHX4enF1eDw9Pe9ztvf6O7g6O7k6/DI1+Hi6u/y9vh8oLlGeJz////6+/y+z9zX4urJ1+Katsn6/Pz4+vve5+1tlbGmvs/r8fTP3OW0yNbz9vjN2+Tn7fLI1uHX4unp7/Otw9PE1N96nreXs8eOrcLG1eCov9AHSnkKTHsISnoHSnoLTXwHSXlgx+EhAAAAanRSTlMLYnd2Um5xUXUZ0/6w7vOv/NSx/e7z/dSx7vOw/dQZGdSx7vOw/dQZGdSx7vOw/dQZ1LHu87D91BkZ1LHzsP3UGRnUsfOw/dQZGdSx7vPUGdSx7vOw/dQZ/rDu87D8DGR6eXpUcHRTd3tlDK+lHQAAAAFiS0dEhRXXaucAAAAHdElNRQfmCB4IBCY0DSgTAAAA8klEQVQY02NgYGRiZmZhZWZmY+dgZmJkYODkyuLm5uHNyuLjF+DO4uJk4BTMysoSAgnwCGdlCRInkJ2TJSSSky3KI5aTAxIQz83Ll5AsKJSSlikqlpVjkFcoKS1TVCqvUFZRraxSU2fQ0KyuqdXSrqvX0dVraNQ3YNAwbGpuMTJubTMxNWvvMLdgsLTqrO6yNu7usbG1a+q1d2BwdOrrn+CsPbHKxdVtUqm7B4On1+QpU719ptX4utpNn+FnweAfMHPW7MCgOXODQ0LnzQ8LB7pjwcKIyKhFi6NjYpcsFedkiItPSExKTklMSE1LT8zIjAMAkOZIz65wIlsAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjItMDgtMzBUMDg6MDQ6MzgrMDA6MDCWf9PgAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIyLTA4LTMwVDA4OjA0OjM4KzAwOjAw5yJrXAAAAFd6VFh0UmF3IHByb2ZpbGUgdHlwZSBpcHRjAAB4nOPyDAhxVigoyk/LzEnlUgADIwsuYwsTIxNLkxQDEyBEgDTDZAMjs1Qgy9jUyMTMxBzEB8uASKBKLgDqFxF08kI1lQAAAABJRU5ErkJggg=="/>
  <link rel="mask-icon" type="image/svg" href="data:image/svg;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iNzg0LjAwMDAwMHB0IiBoZWlnaHQ9Ijc4NC4wMDAwMDBwdCIgdmlld0JveD0iMCAwIDc4NC4wMDAwMDAgNzg0LjAwMDAwMCIKIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiPgo8bWV0YWRhdGE+CkNyZWF0ZWQgYnkgcG90cmFjZSAxLjE0LCB3cml0dGVuIGJ5IFBldGVyIFNlbGluZ2VyIDIwMDEtMjAxNwo8L21ldGFkYXRhPgo8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCw3ODQuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApIgpmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiPgo8cGF0aCBkPSJNNTMwIDM5MTUgbDAgLTM2MjUgMTA3NSAwIDEwNzUgMCAwIDM2MjUgMCAzNjI1IC0xMDc1IDAgLTEwNzUgMCAwCi0zNjI1eiBtMTczNCAyMDkgbDIzNiAtMjQ3IDAgLTI2OCAwIC0yNjkgLTM4MCAwIC0zODAgMCAtMiAyMTggLTMgMjE3IC0xMDcgMwotMTA4IDMgMCAtMzQ1IDAgLTM0NiAyMyAtNSBjMTIgLTMgMTIzIC0yNiAyNDcgLTUwIGwyMjUgLTQ1IDIzOCAtMjM4IDIzNwotMjM3IDAgLTUxMCAwIC01MTEgLTIwOCAtMjA3IC0yMDkgLTIwNyAtNDgwIDAgLTQ3OSAwIC0xOTcgMjI0IC0xOTcgMjI0IDAKMzAxIDAgMzAxIDM5OCAtMiAzOTcgLTMgMyAtMjI3IDIgLTIyOCAxMDUgMCAxMDUgMCAwIDMzNCBjMCAzMTAgLTEgMzM1IC0xNwozNDAgLTEwIDMgLTEyOCAyNiAtMjYzIDUxIC0xMzUgMjUgLTI1MiA0OSAtMjYxIDUzIC04IDQgLTExOCAxMTEgLTI0MiAyMzkKbC0yMjcgMjMyIDAgNTI0IDAgNTIzIDIzOCAyMDEgMjM3IDIwMiA0MTcgMCA0MTcgMSAyMzUgLTI0NnoiLz4KPHBhdGggZD0iTTI4NjAgMzkxNSBsMCAtMzYyNSAxMDc1IDAgMTA3NSAwIDAgMzYyNSAwIDM2MjUgLTEwNzUgMCAtMTA3NSAwIDAKLTM2MjV6IG05NzAgLTI4IGw1IC00ODggMTg1IDQ4NSAxODUgNDg2IDMzOSAwIDMzOCAwIC02IC0yMiBjLTMgLTEzIC05MyAtMzEzCi0yMDEgLTY2NyBsLTE5NiAtNjQ1IDI4IC0yNiBjMTUgLTE1IDEwMyAtOTYgMTk2IC0xODAgbDE2NyAtMTUyIDAgLTc5OSAwCi03OTkgLTQwNSAwIC00MDUgMCAtMiA2ODIgLTMgNjgzIC0xMTIgMyAtMTEzIDMgMCAtNjg2IDAgLTY4NSAtNDIwIDAgLTQyMCAwCjAgMTY1MCAwIDE2NTAgNDE4IC0yIDQxNyAtMyA1IC00ODh6Ii8+CjxwYXRoIGQ9Ik01MTkwIDM5MTUgbDAgLTM2MjUgMTA2MCAwIDEwNjAgMCAwIDM2MjUgMCAzNjI1IC0xMDYwIDAgLTEwNjAgMCAwCi0zNjI1eiBtMTc0NyAyNDMgbDIxMyAtMjEzIDAgLTQzNSAwIC00MzYgLTIwMiAtMTYwIGMtMTEyIC04OCAtMjAzIC0xNjUgLTIwMwotMTcxIDAgLTYgOTAgLTgwIDIwMCAtMTY1IGwyMDAgLTE1NCAzIC00MzkgMiAtNDQwIC0yNDcgLTIzNyAtMjQ4IC0yMzcgLTY0NwotMSAtNjQ4IDAgMCAxNjUwIDAgMTY1MCA2ODIgMCA2ODMgMCAyMTIgLTIxMnoiLz4KPHBhdGggZD0iTTYxODAgMzM5NSBsMCAtMzc1IDEyMCAwIDEyMCAwIC0yIDM3MyAtMyAzNzIgLTExNyAzIC0xMTggMyAwIC0zNzZ6Ii8+CjxwYXRoIGQ9Ik02MTgwIDIwODUgbDAgLTM3NiAxMTggMyAxMTcgMyAzIDM3MyAyIDM3MiAtMTIwIDAgLTEyMCAwIDAgLTM3NXoiLz4KPC9nPgo8L3N2Zz4K" color="#5bbad5">
  <title>HDF5 File Viewer</title>
  <link href="https://unpkg.com/leaflet@1.9.2/dist/leaflet.css" rel="stylesheet">
  <script src="https://unpkg.com/leaflet@1.9.2/dist/leaflet.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="resources/js/xlsxwrite.js"></script>
  <script>
    // xlsxwrite.js is ready immediately after loading (no WASM initialization needed)
    window.xlsxReady = true;
    console.log('xlsxwrite.js loaded');
  </script>
  <link rel="stylesheet" href="./resources/css/kvot.css">
  <link rel="stylesheet" href="./resources/css/rb.css">
</head>
<body>
  <div id="dropOverlay">
    <div class="message">üìÅ Drop HDF5 files here</div>
  </div>
  
  <header></header>

  <input id="fileInput" type="file" accept=".h5,.hdf5,.he5" multiple />

  <div class="container">
    <div class="panel" id="leftPanel">
      <h3>File Structure</h3>
      <div class="search-container">
        <input 
          type="text" 
          id="treeSearch" 
          placeholder="Search tree (use * for wildcard)..." 
          autocomplete="off"
        />
        <button id="clearSearch" class="clear-search-btn" title="Clear search">√ó</button>
      </div>
      <div id="tree" class="loading">Drop HDF5 files or click "+ Add Files" to start...</div>
    </div>

    <div class="resize-handle" id="resizeHandle"></div>

    <div class="panel">
      <div class="right-panel-content">
        <div id="plotlyChartContainer">
          <h3>Chart</h3>
          <div class="chart-controls">
            <label>
              X-axis:
              <select id="xAxisScale" onchange="updateChartScales()">
                <option value="linear">Linear</option>
                <option value="log">Log</option>
              </select>
            </label>
            <label>
              Y-axis:
              <select id="yAxisScale" onchange="updateChartScales()">
                <option value="linear">Linear</option>
                <option value="log">Log</option>
              </select>
            </label>
            <label >
              <input type="checkbox" id="dynamicLegend" checked onchange="toggleDynamicLegend()">
              Dynamic Legend
            </label>
            <label id="showTotalLabel" style="display: none;">
              <input type="checkbox" id="showTotal" checked onchange="toggleShowTotal()">
              Show Total
            </label>
            <label id="showRatioLabel" style="display: none;">
              <input type="checkbox" id="showRatio" onchange="toggleShowRatio()">
              Show Ratio
            </label>
            <span id="legendStatus" style=" font-size: 12px; color: var(--color-text-muted);"></span>
            <button onclick="applyReleasePresetView()" style="margin-left: auto;">Apply Release View</button>
            <button onclick="applyDosePresetView()">Apply Dose View</button>
          </div>
          <div id="plotlyChart"></div>
        </div>
        
        <div>
          <h3>Dataset Information</h3>
            <div class="multi-select-hint" style="display: none;" id="multiSelectHint">
              üí° <strong>Tip:</strong> Hold Ctrl (‚åò on Mac) and click datasets to compare multiple
            </div>
            <div id="info">Select a dataset to view its details</div>
        </div>
      </div>
    </div>
  </div>

  <div id="map"></div>
  <footer></footer>

  <script src="./resources/js/site.js"></script>
  <script>
    KVOT.renderHeader('hdf result browser', '<div class="tabs-container"><div id="fileTabs"></div><button class="add-file-btn" onclick="document.getElementById(\'fileInput\').click()">+ Add Files</button></div>');
    KVOT.renderNav('rb.html');
    KVOT.renderFooter();
    KVOT.initMap('map');
  </script>

  <script src="https://cdn.jsdelivr.net/npm/h5wasm@latest/dist/iife/h5wasm.min.js"></script>
  <script>
    /* ==========================================================================
       HDF5 FILE VIEWER - JAVASCRIPT APPLICATION
       ==========================================================================
       
       Module Organization:
       1. GLOBAL STATE & CONFIGURATION
       2. UTILITY FUNCTIONS
       3. HDF5 DATA ACCESS
       4. FILE MANAGEMENT
       5. TAB MANAGEMENT
       6. TREE VIEW
       7. RADIONUCLIDE LINE STYLES
       8. CHART CONTROLS
       9. CHART CREATION
       10. DYNAMIC LEGEND
       11. DATASET INFORMATION DISPLAY
       12. SEARCH FUNCTIONALITY
       13. DRAG & DROP
       14. CLIPBOARD & EXPORT
       15. EVENT LISTENERS & INITIALIZATION
       
       ========================================================================== */


    /**
     * ==========================================================================
     * HDF5 FILE VIEWER APPLICATION
     * ==========================================================================
     * 
     * A browser-based viewer for HDF5 files with interactive tree navigation,
     * Plotly.js charting, and multi-file comparison capabilities.
     * 
     * @overview
     * - Section 1: Global State & Configuration
     * - Section 2: Utility Functions  
     * - Section 3: HDF5 Data Access
     * - Section 4: File Management
     * - Section 5: Tab Management
     * - Section 6: Tree View
     * - Section 7: Radionuclide Line Styles
     * - Section 8: Chart Controls
     * - Section 9: Chart Creation
     * - Section 10: Dynamic Legend
     * - Section 11: Dataset Information Display
     * - Section 12: Search Functionality
     * - Section 13: Drag & Drop
     * - Section 14: Clipboard & Export
     * - Section 15: Event Listeners & Initialization
     * 
     * @requires h5wasm - WebAssembly-based HDF5 library
     * @requires Plotly.js - Interactive charting library
     * @requires SortableJS - Drag-and-drop sorting library
     * 
     * @author KVOT Development Team
     * @version 2.0.0
     */

    /* ==========================================================================
       1. GLOBAL STATE & CONFIGURATION
       ========================================================================== */
    
    /**
     * @typedef {Object} FileState
     * @property {boolean} enabled - Whether the file is currently enabled for display
     */

    /**
     * @typedef {Object} ChartData
     * @property {Array} traces - Plotly trace data
     * @property {Object} layout - Plotly layout configuration
     * @property {string} path - Dataset path being charted
     */

    /** @type {Object.<string, Object>} Map of filename to HDF5 file objects */
    let loadedFiles = {};
    /** @type {Object.<string, boolean>} Map of filename to enabled/disabled state */
    let fileStates = {};
    /** @type {string[]} Ordered list of filenames (determines tab order) */
    let fileOrder = [];
    
    // Selection state
    /** @type {string|null} Currently selected HDF5 path in the tree view */
    let selectedDatasetPath = null;
    /** @type {boolean} True if the selected path is a radionuclides group (for special charting) */
    let selectedIsRadionuclidesGroup = false;
    /** @type {string[]} Array of selected paths when in multi-select mode (Ctrl+click) */
    let selectedDatasets = [];
    /** @type {boolean} True when user is selecting multiple datasets with Ctrl/Cmd key */
    let multiSelectMode = false;
    
    // Chart state
    /** @type {ChartData|null} Current chart data (traces, layout, path) for export/clipboard */
    let currentChartData = null;
    /** @type {string|null} Filename of the first enabled file (determines tree structure source) */
    let currentTreeFile = null;
    
    // Dynamic legend state
    /** @type {boolean} When true, legend updates to show only traces visible in current viewport */
    let dynamicLegendEnabled = true;
    
    // Search state
    /** @type {number|null} Timeout ID for debounced search input */
    let searchTimeout = null;
    /** @type {string} Current search/filter term applied to tree view */
    let currentSearchTerm = '';
    
    // Drag & drop state
    /** @type {number} Counter for drag enter/leave events to handle nested elements */
    let dragCounter = 0;


    /* ==========================================================================
       1.1 CONSTANTS
       ========================================================================== */
    
    /**
     * Default placeholder message shown in the info panel when no dataset is selected.
     * @constant {string}
     */
    const INFO_PANEL_DEFAULT_MESSAGE = 'Select a dataset to view its details';
    
    /**
     * Standard legend positioning for Plotly charts.
     * Places legend to the right of the chart area.
     * @constant {Object}
     */
    const CHART_LEGEND_CONFIG = {
      x: 1.02,      // Slightly right of chart area
      y: 1,         // Top aligned
      xanchor: 'left',
      yanchor: 'top'
    };
    
    /**
     * Y-axis exponent display settings for scientific notation.
     * Shows all exponents in power format (e.g., 10^6 instead of 1e6).
     * @constant {Object}
     */
    const CHART_YAXIS_EXPONENT = {
      showexponent: 'all',
      exponentformat: 'power'
    };
    
    /**
     * Chart margins with extra right padding for legend.
     * @constant {Object}
     */
    const CHART_MARGIN_WITH_LEGEND = { t: 10, r: 150,  b: 60 };


    /* ==========================================================================
       1.2 DOM ELEMENT HELPERS
       ========================================================================== */
    
    /**
     * Cached DOM element references (initialized on DOMContentLoaded)
     * @type {Object.<string, HTMLElement>}
     */
    const DOM = {};
    
    /**
     * Initialize cached DOM element references
     * Call once after DOM is ready
     */
    function initDOMReferences() {
      DOM.plotlyChart = document.getElementById('plotlyChart');
      DOM.plotlyChartContainer = document.getElementById('plotlyChartContainer');
      DOM.info = document.getElementById('info');
      DOM.tree = document.getElementById('tree');
      DOM.xAxisScale = document.getElementById('xAxisScale');
      DOM.yAxisScale = document.getElementById('yAxisScale');
      DOM.searchInput = document.getElementById('searchInput');
      DOM.searchResults = document.getElementById('searchResults');
      DOM.tabs = document.getElementById('tabs');
      DOM.showTotal = document.getElementById('showTotal');
      DOM.showTotalContainer = document.getElementById('showTotalContainer');
      DOM.showTotalLabel = document.getElementById('showTotalLabel');
      DOM.showRatio = document.getElementById('showRatio');
      DOM.showRatioLabel = document.getElementById('showRatioLabel');
      DOM.dynamicLegendToggle = document.getElementById('dynamicLegendToggle');
      DOM.dropZone = document.getElementById('dropZone');
      DOM.fileTabs = document.getElementById('fileTabs');
    }
    
    /**
     * Get element by ID (with fallback if DOM cache not initialized)
     * @param {string} id - Element ID
     * @returns {HTMLElement|null}
     */
    function getElement(id) {
      return DOM[id] || document.getElementById(id);
    }
    
    /**
     * Show or hide the "Show Total" checkbox based on context
     * @param {boolean} show - Whether to show the checkbox
     */
    function setShowTotalVisible(show) {
      const label = getElement('showTotalLabel');
      if (label) {
        label.style.display = show ? '' : 'none';
      }
    }

    /**
     * Show or hide the "Show Ratio" checkbox based on context.
     * Only shown when there are exactly two enabled files (thick + thin lines).
     * @param {boolean} show - Whether to show the checkbox
     */
    function setShowRatioVisible(show) {
      const label = getElement('showRatioLabel');
      if (label) {
        label.style.display = show ? '' : 'none';
      }
    }


    /* ==========================================================================
       2. UTILITY FUNCTIONS
       ========================================================================== */
    
    /**
     * Wait for h5wasm library to be loaded and ready
     */
    async function waitForH5Wasm() {
      let attempts = 0;
      while (!window.h5wasm && attempts < 50) {
        await new Promise(r => setTimeout(r, 100));
        attempts++;
      }
      if (!window.h5wasm) throw new Error('h5wasm failed to load');
      if (window.h5wasm.ready instanceof Promise) await window.h5wasm.ready;
      return window.h5wasm;
    }

    /**
     * Escape HTML special characters for safe rendering
     */
    function escapeHtml(text) {
      const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
      return String(text).replace(/[&<>"']/g, m => map[m]);
    }
    
    /**
     * Escape value for CSV export (handle commas, quotes, newlines)
     */
    function escapeCSV(value) {
      if (value === null || value === undefined) {
        return '';
      }
      
      const str = String(value);
      
      if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
        return '"' + str.replace(/"/g, '""') + '"';
      }
      
      return str;
    }
    
    /**
     * Format HDF5 data type into human-readable string
     */
    function formatDataType(dtype) {
      if (!dtype) return 'unknown';
      
      let name = '';
      
      if (typeof dtype === 'object' && dtype.name) {
        name = dtype.name;
      } else if (typeof dtype === 'string') {
        name = dtype;
      } else {
        return String(dtype);
      }
      
      const typeMap = {
        'i': 'Integer', 'u': 'Unsigned Integer', 'f': 'Float', 'c': 'Complex',
        'S': 'String (fixed)', 'U': 'Unicode String', 'V': 'Void/Compound',
        'O': 'Object Reference', 'b': 'Boolean', 't': 'Time', 'm': 'Timedelta',
        'M': 'Datetime', 'a': 'Bytes', 'A': 'Any', 'd': 'Float'
      };
      
      name = name.replace(/^[<>|=]/, '');
      
      const match = name.match(/^([a-zA-Z])(\d+)$/);
      if (match) {
        const [, type, bytes] = match;
        const baseType = typeMap[type] || type;
        const bitSize = parseInt(bytes) * 8;
        return `${baseType} (${bitSize}-bit)`;
      }
      
      const singleTypeMatch = name.match(/^([a-zA-Z])$/);
      if (singleTypeMatch) {
        const type = singleTypeMatch[1];
        return typeMap[type] || name;
      }
      
      return name;
    }
    
    /**
     * Check if a value represents a truthy attribute (handles various formats)
     * @param {*} value - The value to check
     * @returns {boolean} True if the value is truthy
     */
    function isTruthyAttribute(value) {
      return value === true || value === 1 || value === 'TRUE' || value === 'True' || value === 'true';
    }
    
    /**
     * Convert data to a proper array
     * @param {*} data - The data to convert (array, array-like, or scalar)
     * @returns {Array} The data as an array
     */
    function normalizeDataArray(data) {
      if (Array.isArray(data)) {
        return data;
      } else if (data && typeof data === 'object' && data.length !== undefined) {
        return Array.from(data);
      } else {
        return [data];
      }
    }
    
    /**
     * Check if a dataset has the 'probabilistic' attribute set to true
     * @param {Object} dataset - HDF5 dataset with attrs
     * @returns {boolean} True if probabilistic
     */
    function checkIsProbabilistic(dataset) {
      if (dataset && dataset.attrs && typeof dataset.attrs === 'object') {
        for (const attrName in dataset.attrs) {
          if (attrName === 'probabilistic') {
            const attrObj = dataset.attrs[attrName];
            if (attrObj && typeof attrObj.value !== 'undefined') {
              return isTruthyAttribute(attrObj.value);
            }
          }
        }
      }
      return false;
    }
    
    /**
     * Compute mean values from probabilistic data array
     * @param {Array} yArray - Raw data array (may contain realizations)
     * @param {Array} timeData - Time data for reference length
     * @returns {Array} Array of mean values per timestep
     */
    function computeProbabilisticMean(yArray, timeData) {
      if (Array.isArray(yArray[0])) {
        // Array of arrays: each timeSlice has multiple realizations
        return yArray.map(timeSlice => {
          if (Array.isArray(timeSlice)) {
            const sum = timeSlice.reduce((a, b) => a + b, 0);
            return sum / timeSlice.length;
          }
          return timeSlice;
        });
      } else if (yArray.length > timeData.length && yArray.length % timeData.length === 0) {
        // Flat array: realizations interleaved or sequential
        const numRealizations = Math.floor(yArray.length / timeData.length);
        const means = [];
        for (let t = 0; t < timeData.length; t++) {
          let sum = 0;
          for (let r = 0; r < numRealizations; r++) {
            sum += yArray[t * numRealizations + r];
          }
          means.push(sum / numRealizations);
        }
        return means;
      }
      return yArray;
    }
    
    /**
     * Get current axis scale values from UI
     * @returns {{xScale: string, yScale: string}}
     */
    function getChartScales() {
      return {
        xScale: getElement('xAxisScale')?.value || 'linear',
        yScale: getElement('yAxisScale')?.value || 'linear'
      };
    }
    
    /**
     * Create base layout configuration for Plotly charts
     * @param {Object} options - Layout options
     * @param {string} options.title - Chart title
     * @param {string} options.xAxisTitle - X axis title
     * @param {string} options.yAxisTitle - Y axis title
     * @param {string} [options.xScale='linear'] - X axis scale type
     * @param {string} [options.yScale='linear'] - Y axis scale type
     * @returns {Object} Plotly layout configuration
     */
    function createBaseLayout({ title, xAxisTitle, yAxisTitle, xScale = 'linear', yScale = 'linear' }) {
      return {
        title: {
          text: '',
          font: { size: 14 },
          xanchor: 'left',
          x: 0
        },
        xaxis: { 
          title: xAxisTitle,
          type: xScale
        },
        yaxis: { 
          title: yAxisTitle,
          type: yScale,
          ...CHART_YAXIS_EXPONENT
        },
        hovermode: 'closest',
        showlegend: true,
        legend: CHART_LEGEND_CONFIG,
        margin: CHART_MARGIN_WITH_LEGEND
      };
    }
    
    /**
     * Hide the chart container and clear chart data
     */
    function hideChart() {
      const container = getElement('plotlyChartContainer');
      if (container) {
        container.classList.remove('visible');
      }
      currentChartData = null;
    }
    
    /**
     * Reset info panel to default message
     */
    function resetInfoPanel() {
      const info = getElement('info');
      if (info) {
        info.innerHTML = INFO_PANEL_DEFAULT_MESSAGE;
      }
    }
    
    /**
     * Render a Plotly chart with standard configuration
     * @param {Array} traces - Plotly trace data
     * @param {Object} layout - Plotly layout configuration
     * @param {string} path - Dataset path (for storing in currentChartData)
     */
    function renderChart(traces, layout, path) {
      const container = getElement('plotlyChartContainer');
      const config = getPlotlyConfig('chart');
      
      currentChartData = { traces, layout, path };
      if (container) {
        container.classList.add('visible');
      }
      
      Plotly.newPlot('plotlyChart', traces, layout, config).then(() => {
        setupDynamicLegend(getElement('plotlyChart'));
      });
    }


    /* ==========================================================================
       3. HDF5 DATA ACCESS
       ========================================================================== */
    
    /**
     * Check if a dataset or group exists at the given path in an HDF5 file.
     * Safely handles exceptions from invalid paths.
     * 
     * @param {Object} file - h5wasm File object
     * @param {string} path - HDF5 path to check (e.g., '/group/dataset')
     * @returns {boolean} True if the path exists and is accessible
     */
    function checkDatasetExistsInFile(file, path) {
      try {
        const dataset = file.get(path);
        return dataset !== null && dataset !== undefined;
      } catch (e) {
        return false;
      }
    }
    
    /**
     * Check if a path exists in a file referenced by filename.
     * Looks up the file in loadedFiles by name before checking.
     * 
     * @param {string} fileName - Key in loadedFiles object
     * @param {string} path - HDF5 path to check
     * @returns {boolean} True if file exists in loadedFiles and path is valid
     */
    function checkIfPathExistsInFile(fileName, path) {
      try {
        const file = loadedFiles[fileName];
        if (!file) return false;
        const node = file.get(path);
        return node !== null && node !== undefined;
      } catch (e) {
        return false;
      }
    }

    /**
     * Retrieve time axis data from the standard '/time' dataset.
     * This is the x-axis data for time-dependent plots.
     * 
     * @param {Object} file - h5wasm File object
     * @returns {number[]|null} Array of time values, or null if not found
     */
    function getTimeData(file) {
      try {
        const timeDataset = file.get('/time');
        if (timeDataset && typeof timeDataset.value !== 'undefined') {
          let timeData = timeDataset.value;
          if (timeData && typeof timeData === 'object' && timeData.length !== undefined) {
            return Array.from(timeData);
          }
          return [timeData];
        }
      } catch (e) {
        console.warn('Could not read /time dataset:', e.message);
      }
      return null;
    }

    /**
     * Get the unit string from the '/time' dataset's 'unit' attribute.
     * Used for labeling the x-axis on time-dependent charts.
     * 
     * @param {Object} file - h5wasm File object
     * @returns {string} Time unit string (e.g., 'years', 's'), or empty string if not found
     */
    function getTimeUnit(file) {
      try {
        const timeDataset = file.get('/time');
        if (timeDataset && timeDataset.attrs && typeof timeDataset.attrs === 'object') {
          for (const attrName in timeDataset.attrs) {
            if (attrName === 'unit') {
              const attrObj = timeDataset.attrs[attrName];
              if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                return attrObj.value;
              }
            }
          }
        }
      } catch (e) {
        console.warn('Could not read time unit:', e);
      }
      return '';
    }

    /**
     * Check if a dataset has the 'time_dependent' attribute set to a truthy value.
     * Datasets marked as time-dependent are eligible for time-series plotting.
     * 
     * @param {Object} dataset - h5wasm Dataset object with attrs property
     * @returns {boolean} True if the dataset has time_dependent=true/1/'TRUE'/'True'
     */
    function isTimeDependent(dataset) {
      try {
        if (dataset.attrs && typeof dataset.attrs === 'object') {
          for (const attrName in dataset.attrs) {
            if (attrName === 'time_dependent') {
              const attrObj = dataset.attrs[attrName];
              if (attrObj && typeof attrObj.value !== 'undefined') {
                const value = attrObj.value;
                return value === true || value === 1 || value === 'TRUE' || value === 'True';
              }
            }
          }
        }
      } catch (e) {
        console.warn('Error checking time_dependent attribute:', e);
      }
      return false;
    }
    
    /**
     * Check if a group contains radionuclide data suitable for special charting.
     * A radionuclides group must have:
     * - IndexLists attribute containing 'Radionuclides'
     * - time_dependent attribute set to true
     * 
     * These groups get special treatment: all child datasets are plotted together
     * with isotope-specific line styles and colors.
     * 
     * @param {Object} file - h5wasm File object
     * @param {string} path - HDF5 path to the group
     * @returns {boolean} True if the group is a radionuclides data container
     */
    function checkGroupForRadionuclides(file, path) {
      try {
        const group = file.get(path);
        if (!group || group.type.toLowerCase() !== 'group') {
          return false;
        }
        
        let hasRadionuclidesIndex = false;
        let isTimeDependentGroup = false;
        
        if (group.attrs && typeof group.attrs === 'object') {
          for (const attrName in group.attrs) {
            if (attrName === 'IndexLists') {
              const attrObj = group.attrs[attrName];
              if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                const value = attrObj.value;
                if (Array.isArray(value) && value.includes('Radionuclides')) {
                  hasRadionuclidesIndex = true;
                } else if (typeof value === 'string' && value === 'Radionuclides') {
                  hasRadionuclidesIndex = true;
                }
              }
            }
            
            if (attrName === 'time_dependent') {
              const attrObj = group.attrs[attrName];
              if (attrObj && typeof attrObj.value !== 'undefined') {
                const value = attrObj.value;
                isTimeDependentGroup = value === true || value === 1 || value === 'TRUE' || value === 'True';
              }
            }
          }
        }
        
        return hasRadionuclidesIndex && isTimeDependentGroup;
      } catch (e) {
        console.warn('Error checking group for radionuclides:', e);
        return false;
      }
    }


    /* ==========================================================================
       4. FILE MANAGEMENT
       ========================================================================== */
    
    /**
     * Get list of filenames for currently enabled (visible) files.
     * Maintains the order from fileOrder array.
     * 
     * @returns {string[]} Array of enabled filenames in display order
     */
    function getEnabledFiles() {
      return fileOrder.filter(key => fileStates[key]);
    }
    
    /**
     * Get the filename of the first enabled file.
     * This file's structure is used to render the tree view.
     * 
     * @returns {string|null} Filename of first enabled file, or null if none enabled
     */
    function getTreeFile() {
      const enabledFiles = getEnabledFiles();
      return enabledFiles.length > 0 ? enabledFiles[0] : null;
    }

    /**
     * Toggle a file's enabled/disabled state and update the UI.
     * Enabled files contribute data to charts; disabled files are hidden.
     * 
     * @param {string} fileName - The filename to toggle
     */
    function toggleFileState(fileName) {
      fileStates[fileName] = !fileStates[fileName];
      updateTabs();
    }

    /**
     * Remove a file completely from the viewer.
     * Cleans up all references and updates the UI. If this was the last
     * file, resets the viewer to its initial empty state.
     * 
     * @param {string} fileName - The filename to remove
     * @returns {Promise<void>}
     */
    async function removeFile(fileName) {
      delete loadedFiles[fileName];
      delete fileStates[fileName];
      fileOrder = fileOrder.filter(k => k !== fileName);
      
      const enabledFiles = getEnabledFiles();
      
      updateTabs();
      
      if (enabledFiles.length === 0) {
        // No enabled files - clear UI
        currentTreeFile = null;
        const tree = document.getElementById('tree');
        tree.innerHTML = '<div class="loading">Drop HDF5 files or click "+ Add Files" to start...</div>';
        tree.classList.add('loading');
        resetInfoPanel();
        hideChart();
        selectedDatasetPath = null;
        selectedIsRadionuclidesGroup = false;
        
        document.querySelector('.search-container').classList.remove('visible');
        
        const hint = document.getElementById('multiSelectHint');
        if (hint) {
          hint.style.display = 'none';
        }
      }
    }
    
    /**
     * Refresh the info panel and chart display after file selection changes.
     * Verifies the selected path still exists in the current tree file.
     * If the path no longer exists, clears the selection.
     * 
     * @returns {void}
     */
    function refreshInfoAndChart() {
      if (!selectedDatasetPath) {
        return;
      }

      const treeFile = getTreeFile();
      
      if (!treeFile || !checkIfPathExistsInFile(treeFile, selectedDatasetPath)) {
        // Clear selection if path doesn't exist
        resetInfoPanel();
        hideChart();
        selectedDatasetPath = null;
        selectedIsRadionuclidesGroup = false;
        
        document.querySelectorAll('.tree-item.dataset').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.tree-item.group').forEach(el => el.classList.remove('expanded'));
        return;
      }

      // Path exists, refresh display
      if (selectedIsRadionuclidesGroup) {
        showNodeAttributes(selectedDatasetPath, true);
        createRadionuclidesChart(selectedDatasetPath);
      } else {
        showNodeAttributes(selectedDatasetPath, false);
        
        try {
          const file = loadedFiles[treeFile];
          const dataset = file.get(selectedDatasetPath);
          if (dataset && dataset.type.toLowerCase() === 'dataset' && isTimeDependent(dataset)) {
            createPlotlyChart(selectedDatasetPath);
          }
        } catch (e) {
          console.warn('Error checking if dataset is time-dependent:', e);
        }
      }
    }


    /* ==========================================================================
       5. TAB MANAGEMENT
       ========================================================================== */
    
    /**
     * Update the file tabs display and reinitialize drag-drop sorting.
     * Renders a tab for each loaded file, handles click-to-toggle and
     * drag-to-reorder functionality via SortableJS.
     * 
     * Tab states:
     * - enabled: File data included in charts (blue indicator)
     * - disabled: File loaded but hidden from charts (gray)
     * 
     * @returns {void}
     */
    function updateTabs() {
      const tabsContainer = document.getElementById('fileTabs');
      const previousTreeFile = currentTreeFile;
      
      // Render tabs
      tabsContainer.innerHTML = fileOrder.map(key => {
        const isEnabled = fileStates[key];
        return `
          <div class="file-tab ${isEnabled ? 'enabled' : 'disabled'}" data-file="${escapeHtml(key)}">
            <div class="file-tab-name" title="${escapeHtml(key)}">${escapeHtml(key)}</div>
            <div class="file-tab-close" onclick="event.stopPropagation(); removeFile('${key.replace(/'/g, "\\'")}')">√ó</div>
          </div>
        `;
      }).join('');
      
      // Add click handlers for toggle
      document.querySelectorAll('.file-tab').forEach(tab => {
        const fileName = tab.getAttribute('data-file');
        tab.addEventListener('click', (e) => {
          if (!e.target.classList.contains('file-tab-close')) {
            toggleFileState(fileName);
          }
        });
      });
      
      // Initialize SortableJS for drag reordering
      if (window.Sortable && tabsContainer.children.length > 0) {
        Sortable.create(tabsContainer, {
          animation: 150,
          ghostClass: 'sortable-ghost',
          dragClass: 'sortable-drag',
          onEnd: function(evt) {
            const previousFirst = currentTreeFile;
            
            const newOrder = Array.from(tabsContainer.children).map(
              tab => tab.getAttribute('data-file')
            );
            fileOrder = newOrder;
            
            const newTreeFile = getTreeFile();
            currentTreeFile = newTreeFile;
            
            const treeFileChanged = previousFirst !== newTreeFile;
            
            console.log('Drag ended - Previous:', previousFirst, 'New:', newTreeFile, 'Changed:', treeFileChanged);
            
            if (treeFileChanged) {
              refreshTreeStructure();
            }
            
            refreshInfoAndChart();
          }
        });
      }
      
      // Check if tree file changed
      const newTreeFile = getTreeFile();
      const treeFileChanged = previousTreeFile !== newTreeFile;
      currentTreeFile = newTreeFile;
      
      console.log('updateTabs - Previous:', previousTreeFile, 'New:', newTreeFile, 'Changed:', treeFileChanged);
      
      if (treeFileChanged) {
        refreshTreeStructure();
      }
      
      refreshInfoAndChart();
    }


    /* ==========================================================================
       6. TREE VIEW
       ========================================================================== */
    
    /**
     * Toggle the expand/collapse state of a group node in the tree.
     * Called when clicking the triangle toggle icon.
     * Does NOT select the group or trigger chart updates.
     * 
     * @param {Event} event - Click event on the toggle icon
     * @param {string} path - HDF5 path of the group
     * @returns {void}
     */
    function toggleGroupExpansion(event, path) {
      event.stopPropagation();
      
      const toggle = event.currentTarget;
      const groupItem = toggle.closest('.tree-item.group');
      const childrenDiv = groupItem.nextElementSibling;
      
      if (childrenDiv && childrenDiv.classList.contains('tree-group-children')) {
        const isExpanded = childrenDiv.classList.contains('expanded');
        
        if (isExpanded) {
          childrenDiv.classList.remove('expanded');
          toggle.classList.add('collapsed');
          groupItem.classList.remove('expanded');
        } else {
          childrenDiv.classList.add('expanded');
          toggle.classList.remove('collapsed');
        }
      }
    }
    
    /**
     * Handle dataset selection in single or multi-select mode.
     * 
     * Single-click: Selects one dataset, shows its info and chart.
     * Ctrl/Cmd+click: Adds/removes dataset from multi-selection,
     *                 shows combined info and comparison chart.
     * 
     * @param {string} path - HDF5 path to the dataset
     * @param {Event} [evt] - Click event (used to detect Ctrl/Cmd key)
     * @returns {void}
     */
    function selectDataset(path, evt) {
      evt?.stopPropagation();
      
      const isCtrlKey = evt?.ctrlKey || evt?.metaKey;
      const datasetElement = evt?.target?.closest('.tree-item.dataset');
      
      if (isCtrlKey) {
        // Multi-select mode
        multiSelectMode = true;
        
        const index = selectedDatasets.indexOf(path);
        if (index > -1) {
          selectedDatasets.splice(index, 1);
          datasetElement?.classList.remove('selected');
        } else {
          selectedDatasets.push(path);
          datasetElement?.classList.add('selected');
        }
        
        selectedIsRadionuclidesGroup = false;
        document.querySelectorAll('.tree-item.group').forEach(el => {
          el.classList.remove('expanded');
        });
        
        if (selectedDatasets.length > 0) {
          showMultipleDatasetAttributes(selectedDatasets);
        } else {
          resetInfoPanel();
          document.getElementById('plotlyChartContainer').classList.remove('visible');
          currentChartData = null;
        }
      } else {
        // Single select mode
        multiSelectMode = false;
        selectedDatasets = [path];
        selectedDatasetPath = path;
        selectedIsRadionuclidesGroup = false;
        
        document.querySelectorAll('.tree-item.dataset').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.tree-item.group').forEach(el => el.classList.remove('expanded'));
        
        datasetElement?.classList.add('selected');
        
        showNodeAttributes(path, false);
      }
    }
    
    /**
     * Handle group selection to show group info and radionuclides chart.
     * Clicking on a group (not its toggle icon) selects it for display.
     * If the group contains radionuclides data, triggers special charting.
     * 
     * @param {Event} event - Click event on the group element
     * @returns {void}
     */
    function toggleGroup(event) {
      event.stopPropagation();
      const groupItem = event.currentTarget;
      
      if (event.target.classList.contains('tree-toggle')) {
        return;
      }
      
      const path = groupItem.getAttribute('data-path');
      if (path) {
        multiSelectMode = false;
        selectedDatasets = [];
        
        selectedDatasetPath = path;
        selectedIsRadionuclidesGroup = true;
        
        document.querySelectorAll('.tree-item.dataset.selected').forEach(el => {
          el.classList.remove('selected');
        });
        
        document.querySelectorAll('.tree-item.group').forEach(el => {
          el.classList.remove('expanded');
        });
        
        groupItem.classList.add('expanded');
        
        showNodeAttributes(path, true);
      }
    }

    /**
     * Refresh the tree view from the first enabled file's structure.
     * Rebuilds the entire tree HTML and applies any active search filter.
     * Shows loading state during refresh and handles errors gracefully.
     * 
     * @returns {Promise<void>}
     */
    async function refreshTreeStructure() {
      const tree = document.getElementById('tree');
      const searchContainer = document.querySelector('.search-container');
      const treeFile = getTreeFile();
      
      if (!treeFile) {
        tree.innerHTML = '<div class="loading">Drop HDF5 files or click "+ Add Files" to start...</div>';
        tree.classList.add('loading');
        resetInfoPanel();
        hideChart();
        searchContainer.classList.remove('visible');
        return;
      }
      
      console.log('Refreshing tree structure for:', treeFile);
      
      try {
        const file = loadedFiles[treeFile];
        const treeHtml = await buildTree(file, '', false, treeFile);
        tree.innerHTML = treeHtml || '<div style="color:#999;">No items found</div>';
        tree.classList.remove('loading');
        searchContainer.classList.add('visible');
      } catch (err) {
        tree.innerHTML = `<div class="error">Error loading tree: ${escapeHtml(err.message)}</div>`;
        console.error(err);
        searchContainer.classList.remove('visible');
      }
    }
    
    // Decorator: Show multi-select hint after tree refresh
    const originalRefreshTreeStructure2 = refreshTreeStructure;
    refreshTreeStructure = async function() {
      await originalRefreshTreeStructure2();
      const hint = document.getElementById('multiSelectHint');
      const tree = document.getElementById('tree');
      
      if (hint) {
        const hasEnabledFiles = getEnabledFiles().length > 0;
        const isNotLoading = !tree.classList.contains('loading');
        const hasTreeContent = tree.querySelector('.tree-item') !== null;
        
        if (hasEnabledFiles && isNotLoading && hasTreeContent) {
          hint.style.display = 'flex';
        } else {
          hint.style.display = 'none';
        }
      }
    };
    
    /**
     * Recursively build HTML tree structure from an HDF5 group.
     * Creates collapsible group nodes and selectable dataset nodes.
     * Preserves selection state when rebuilding.
     * 
     * @param {Object} group - h5wasm Group object to traverse
     * @param {string} [prefix=''] - Path prefix for nested items
     * @param {boolean} [isNested=false] - Whether this is a nested call (not root)
     * @returns {Promise<string>} HTML string for the tree structure
     */
    async function buildTree(group, prefix = '', isNested = false, fileName = '') {
      const childrenHtml = [];
      
      // Add root group item only at top level
      if (prefix === '') {
        const isRootSelected = selectedDatasetPath === '/' && selectedIsRadionuclidesGroup;
        const rootLabel = fileName ? fileName : 'root';
        const rootHtml = `<div class="tree-item group ${isRootSelected ? 'expanded' : ''}" onclick="toggleGroup(event)" data-path="/" style="font-weight: 600; color: var(--color-kvot-primary); margin-bottom: 8px;">
          <div class="tree-toggle ${isRootSelected ? '' : 'collapsed'}" onclick="event.stopPropagation(); toggleGroupExpansion(event, '/')">‚ñ∂</div>
          <div class="tree-icon folder"></div>
          <div class="tree-label">/ (${rootLabel})</div>
        </div>`;
        childrenHtml.push(rootHtml);
        
        const rootChildrenStart = `<div class="tree-group-children ${isRootSelected ? 'expanded' : ''}" style="margin-left: 20px;">`;
        childrenHtml.push(rootChildrenStart);
      }
      
      try {
        let keys = [];
        try {
          if (typeof group.keys === 'function') {
            keys = Array.from(group.keys());
          }
          keys.sort();
        } catch (e) {
          console.error('Error getting keys:', e.message);
          if (prefix === '') {
            childrenHtml.push('</div>');
          }
          return childrenHtml.join('');
        }
        
        if (keys.length === 0) {
          if (prefix === '') {
            childrenHtml.push('<div style="color:#999;padding:8px;font-size:12px;">(empty)</div>');
            childrenHtml.push('</div>');
          }
          return childrenHtml.join('');
        }
        
        for (const key of keys) {
          try {
            const obj = group.get(key);
            if (!obj) continue;
            
            const path = prefix ? `${prefix}/${key}` : `/${key}`;
            const objType = String(obj.type).toLowerCase();
            
            if (objType === 'group') {
              const isSelected = selectedDatasetPath === path && selectedIsRadionuclidesGroup;
              const groupHtml = `<div class="tree-item group ${isSelected ? 'expanded' : ''}" onclick="toggleGroup(event)" data-path="${escapeHtml(path)}">
                  <div class="tree-toggle ${isSelected ? '' : 'collapsed'}" onclick="event.stopPropagation(); toggleGroupExpansion(event, '${path.replace(/'/g, "\\'")}')">‚ñ∂</div>
                  <div class="tree-icon folder"></div>
                  <div class="tree-label">${escapeHtml(key)}</div>
                </div>`;
              childrenHtml.push(groupHtml);
              
              try {
                const subItems = await buildTree(obj, path, true);
                const childrenWrapper = `<div class="tree-group-children ${isSelected ? 'expanded' : ''}">${subItems || '<div style="color:#999;padding:8px;font-size:12px;">(empty)</div>'}</div>`;
                childrenHtml.push(childrenWrapper);
              } catch (subErr) {
                console.error('Error getting sub-items for', key, subErr);
                const errorWrapper = `<div class="tree-group-children"><div style="color:red;padding:8px;font-size:12px;">(error: ${escapeHtml(subErr.message)})</div></div>`;
                childrenHtml.push(errorWrapper);
              }
            } else if (objType === 'dataset') {
              const shape = obj.shape?.length ? `${obj.shape.join('√ó')}` : 'scalar';
              const formattedDtype = formatDataType(obj.dtype);
              const isSelected = selectedDatasetPath === path && !selectedIsRadionuclidesGroup;
              const datasetHtml = `<div class="tree-item dataset ${isSelected ? 'selected' : ''}" onclick="selectDataset('${path.replace(/'/g, "\\'")}', event)" data-path="${escapeHtml(path)}">
                <div class="tree-icon dataset"></div>
                <div class="tree-label">${escapeHtml(key)}</div>
                <div class="tree-meta">${escapeHtml(formattedDtype)} [${escapeHtml(shape)}]</div>
              </div>`;
              childrenHtml.push(datasetHtml);
            }
          } catch (e) {
            console.error('Error with key', key, ':', e.message);
            childrenHtml.push(`<div class="tree-item" style="color:red;font-size:12px;">‚ö†Ô∏è ${escapeHtml(key)}</div>`);
          }
        }
      } catch (e) {
        console.error('buildTree error:', e);
      }
      
      if (prefix === '') {
        childrenHtml.push('</div>');
      }
      
      return childrenHtml.join('');
    }


    /* ==========================================================================
       7. RADIONUCLIDE LINE STYLES
       ========================================================================== */
    
    /**
     * Get the line style (color, dash pattern) for a radionuclide isotope.
     * 
     * Predefined styles are provided for common isotopes in categories:
     * - Actinides (Ac, Am, Cm, Np, Pa, Pu, Th, U)
     * - Fission products (Ag, Cs, I, Pd, Se, Sm, Sn, Sr, Tc, Zr)
     * - Activation products (Be, C, Cl, Co, H, Ni, Nb, Mo)
     * - Other radionuclides (various)
     * 
     * Colors are chosen for visual distinction on both light backgrounds
     * and when multiple isotopes are plotted together.
     * 
     * @param {string} name - Isotope name (e.g., 'U-238', 'Cs-137', 'C-14-org')
     * @returns {{color: string|null, dash: string, width: number}} Line style object
     * 
     * @example
     * getLineStyle('U-238')  // { color: 'rgb(255,0,0)', dash: 'solid', width: 2 }
     * getLineStyle('unknown') // { color: null, dash: 'solid', width: 2 }
     */
    function getLineStyle(name) {
      const lineStyles = {
        // Actinides
        'Ac-227': { color: 'rgb(128,0,0)', dash: 'solid' },
        'Am-241': { color: 'rgb(72,209,204)', dash: 'dashdot' },
        'Am-242m': { color: 'rgb(72,209,204)', dash: 'dash' },
        'Am-243': { color: 'rgb(72,209,204)', dash: 'solid' },
        'Cm-242': { color: 'rgb(175,238,238)', dash: 'dash' },
        'Cm-243': { color: 'rgb(175,238,238)', dash: 'solid' },
        'Cm-244': { color: 'rgb(175,238,238)', dash: 'dot' },
        'Cm-245': { color: 'rgb(175,238,238)', dash: 'dash' },
        'Cm-246': { color: 'rgb(175,238,238)', dash: 'dashdot' },
        'Np-237': { color: 'rgb(218,165,32)', dash: 'solid' },
        'Pa-231': { color: 'rgb(85,107,47)', dash: 'solid' },
        'Pu-238': { color: 'rgb(0,255,255)', dash: 'dot' },
        'Pu-239': { color: 'rgb(0,255,255)', dash: 'solid' },
        'Pu-240': { color: 'rgb(0,255,255)', dash: 'dash' },
        'Pu-241': { color: 'rgb(0,255,255)', dash: 'dashdot' },
        'Pu-242': { color: 'rgb(0,255,255)', dash: 'dash' },
        'Th-228': { color: 'rgb(75,0,130)', dash: 'dash' },
        'Th-229': { color: 'rgb(75,0,130)', dash: 'dot' },
        'Th-230': { color: 'rgb(75,0,130)', dash: 'solid' },
        'Th-232': { color: 'rgb(75,0,130)', dash: 'dash' },
        'U-232': { color: 'rgb(255,0,0)', dash: 'longdash' },
        'U-233': { color: 'rgb(255,0,0)', dash: 'dash' },
        'U-234': { color: 'rgb(255,0,0)', dash: 'dot' },
        'U-235': { color: 'rgb(255,0,0)', dash: 'dash' },
        'U-236': { color: 'rgb(255,0,0)', dash: 'dashdot' },
        'U-238': { color: 'rgb(255,0,0)', dash: 'solid' },
        
        // Fission products
        'Ag-108m': { color: 'rgb(128,128,0)', dash: 'solid' },
        'Cs-135': { color: 'rgb(0,128,0)', dash: 'solid' },
        'Cs-137': { color: 'rgb(0,128,0)', dash: 'dash' },
        'I-129': { color: 'rgb(30,144,255)', dash: 'solid' },
        'Pd-107': { color: 'rgb(216,191,216)', dash: 'solid' },
        'Se-79': { color: 'rgb(112,128,144)', dash: 'solid' },
        'Sm-151': { color: 'rgb(138,43,226)', dash: 'solid' },
        'Sn-126': { color: 'rgb(0,0,0)', dash: 'solid' },
        'Sr-90': { color: 'rgb(255,215,0)', dash: 'solid' },
        'Tc-99': { color: 'rgb(0,0,128)', dash: 'solid' },
        'Zr-93': { color: 'rgb(144,238,144)', dash: 'solid' },
        
        // Activation products
        'Be-10': { color: 'rgb(65,105,225)', dash: 'solid' },
        'C-14': { color: 'rgb(0,0,255)', dash: 'solid' },
        'C-14-org': { color: 'rgb(0,0,255)', dash: 'solid' },
        'C-14-ind': { color: 'rgb(0,0,255)', dash: 'dash' },
        'C-14-inorg': { color: 'rgb(0,0,255)', dash: 'dot' },
        'Cl-36': { color: 'rgb(210,105,30)', dash: 'solid' },
        'Co-60': { color: 'rgb(0,255,127)', dash: 'solid' },
        'H-3': { color: 'rgb(0,0,205)', dash: 'solid' },
        'Ni-59': { color: 'rgb(255,0,255)', dash: 'solid' },
        'Ni-63': { color: 'rgb(255,0,255)', dash: 'dash' },
        'Nb-93m': { color: 'rgb(210,180,140)', dash: 'solid' },
        'Nb-94': { color: 'rgb(210,180,140)', dash: 'dash' },
        'Mo-93': { color: 'rgb(0,255,0)', dash: 'solid' },
        
        // Other radionuclides
        'Ar-39': { color: 'rgb(152,251,152)', dash: 'solid' },
        'Ba-133': { color: 'rgb(70,130,180)', dash: 'solid' },
        'Ca-41': { color: 'rgb(128,0,128)', dash: 'solid' },
        'Cd-113m': { color: 'rgb(124,252,0)', dash: 'solid' },
        'Eu-150': { color: 'rgb(205,133,63)', dash: 'dash' },
        'Eu-152': { color: 'rgb(205,133,63)', dash: 'solid' },
        'Gd-148': { color: 'rgb(255,255,0)', dash: 'solid' },
        'Ho-166m': { color: 'rgb(100,149,237)', dash: 'solid' },
        'K-40': { color: 'rgb(139,69,19)', dash: 'solid' },
        'La-137': { color: 'rgb(255,248,220)', dash: 'solid' },
        'Pb-210': { color: 'rgb(148,0,211)', dash: 'dash' },
        'Po-210': { color: 'rgb(148,0,211)', dash: 'dot' },
        'Ra-226': { color: 'rgb(148,0,211)', dash: 'solid' },
        'Ra-228': { color: 'rgb(148,0,211)', dash: 'dash' },
        'Re-186m': { color: 'rgb(255,160,122)', dash: 'solid' },
        'Si-32': { color: 'rgb(255,228,181)', dash: 'solid' },
        'Tb-157': { color: 'rgb(221,160,221)', dash: 'solid' },
        'Tb-158': { color: 'rgb(221,160,221)', dash: 'dash' },
        'Ti-44': { color: 'rgb(218,112,214)', dash: 'solid' }
      };
      
      const defaultStyle = { color: null, dash: 'solid', width: 2 };
      
      if (name in lineStyles) {
        return { ...defaultStyle, ...lineStyles[name] };
      }
      
      return defaultStyle;
    }


    /* ==========================================================================
       8. CHART CONTROLS
       ========================================================================== */
    
    /**
     * Update the chart axis scales based on dropdown selections.
     * Applies new scale types (linear/log) without rebuilding the entire chart.
     * 
     * @returns {void}
     */
    function updateChartScales() {
      if (!currentChartData) return;
      
      const xScale = document.getElementById('xAxisScale').value;
      const yScale = document.getElementById('yAxisScale').value;
      
      const update = {
        'xaxis.type': xScale,
        'yaxis.type': yScale
      };
      
      Plotly.relayout('plotlyChart', update);
    }

    /**
     * Apply preset axis ranges optimized for viewing release data.
     * Sets both axes to log scale with ranges suitable for radionuclide releases.
     * X-axis: 100 - 100,000 (years)
     * Y-axis: 10,000 - 1e9 (activity units)
     * 
     * @returns {void}
     */
    function applyReleasePresetView() {
      if (!currentChartData) return;
      
      document.getElementById('xAxisScale').value = 'log';
      document.getElementById('yAxisScale').value = 'log';
      
      const update = {
        'xaxis.type': 'log',
        'xaxis.range': [Math.log10(100), Math.log10(100000)],
        'yaxis.type': 'log',
        'yaxis.range': [Math.log10(10000), Math.log10(1e9)]
      };
      
      Plotly.relayout('plotlyChart', update);
    }

    /**
     * Apply preset axis ranges optimized for viewing dose data.
     * Sets both axes to log scale with ranges suitable for dose rates.
     * X-axis: 1,000 - 100,000 (years)
     * Y-axis: 1e-10 - 1e-5 (Sv/year or similar units)
     * 
     * @returns {void}
     */
    function applyDosePresetView() {
      if (!currentChartData) return;
      
      document.getElementById('xAxisScale').value = 'log';
      document.getElementById('yAxisScale').value = 'log';
      
      const update = {
        'xaxis.type': 'log',
        'xaxis.range': [Math.log10(1000), Math.log10(1e5)],
        'yaxis.type': 'log',
        'yaxis.range': [Math.log10(1e-10), Math.log10(1e-5)]
      };
      
      Plotly.relayout('plotlyChart', update);
    }

    /**
     * Export current chart data to a CSV file.
     * Creates a downloadable file with columns: Series, X, Y.
     * Each trace in the chart becomes a series in the CSV.
     * 
     * @returns {void}
     */
    function downloadChartData() {
      if (!currentChartData) {
        alert('No chart data available');
        return;
      }
      
      let csv = 'Series,X,Y\n';
      
      for (const trace of currentChartData.traces) {
        const name = trace.name;
        for (let i = 0; i < trace.x.length; i++) {
          csv += `"${name}",${trace.x[i]},${trace.y[i]}\n`;
        }
      }
      
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `chart_data_${Date.now()}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    /**
     * Export current chart data to an Excel file (.xlsx).
     * Creates a workbook with two sheets:
     * - "Chart": Contains a native Excel scatter chart with the same look as Plotly
     * - "Data": Contains the chart data with time column and one column per trace
     * 
     * Uses xlsxwrite.js for native Excel chart creation with full feature support.
     * Creates a chart that matches the Plotly chart styling:
     * - Same axis type (log/linear) with proper logarithmic scale support
     * - Same line colors from traces
     * - Same dash patterns (solid, dash, dot, dashdot, longdash)
     * - Gridlines matching the Plotly style
     * - Lines without markers
     * 
     * @returns {Promise<void>}
     */
    async function downloadChartDataAsExcel() {
      if (!currentChartData) {
        alert('No chart data available');
        return;
      }
      
      // Check if xlsxwrite.js is ready
      if (!window.xlsxReady || !window.XlsxWriter) {
        alert('Excel export library is not loaded. Please refresh the page.');
        return;
      }
      
      try {
        const allTraces = currentChartData.traces;
        const layout = currentChartData.layout;
        
        // Get current state from the actual Plotly chart element
        const chartDiv = document.getElementById('plotlyChart');
        const plotlyTraces = chartDiv && chartDiv.data ? chartDiv.data : allTraces;
        const plotlyLayout = chartDiv && chartDiv.layout ? chartDiv.layout : layout;
        
        // Check if Dynamic Legend is enabled and we should filter by viewport
        const dynamicLegendCheckbox = document.getElementById('dynamicLegend');
        const isDynamicLegendEnabled = dynamicLegendCheckbox && dynamicLegendCheckbox.checked;
        
        let traces;
        
        if (isDynamicLegendEnabled && plotlyLayout.xaxis && plotlyLayout.yaxis) {
          // Filter traces based on whether they have data points in the current viewport
          const xRange = plotlyLayout.xaxis.range;
          const yRange = plotlyLayout.yaxis.range;
          
          if (xRange && yRange) {
            const xIsLog = plotlyLayout.xaxis.type === 'log';
            const yIsLog = plotlyLayout.yaxis.type === 'log';
            
            const xMin = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
            const xMax = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
            const yMin = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
            const yMax = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
            
            traces = plotlyTraces.filter(trace => {
              // Check if trace has any data points in the current viewport
              for (let j = 0; j < trace.x.length; j++) {
                const x = trace.x[j];
                const y = trace.y[j];
                if (x !== null && x !== undefined && y !== null && y !== undefined) {
                  if (x >= xMin && x <= xMax && y >= yMin && y <= yMax) {
                    return true;
                  }
                }
              }
              return false;
            });
          } else {
            traces = plotlyTraces;
          }
        } else {
          // Dynamic Legend off - export all traces (or filter by visible property)
          traces = plotlyTraces.filter(trace => {
            const visible = trace.visible;
            return visible === undefined || visible === true;
          });
        }
        
        if (traces.length === 0) {
          alert('No visible traces to export. Please show at least one trace in the chart.');
          return;
        }
        
        // Find the longest x array to determine row count
        const maxLength = Math.max(...traces.map(t => t.x ? t.x.length : 0));
        
        // Extract chart metadata
        const chartTitle = layout && layout.title && layout.title.text 
          ? layout.title.text 
          : 'Chart Data';
        const xAxisTitle = layout && layout.xaxis && layout.xaxis.title && layout.xaxis.title.text
          ? layout.xaxis.title.text
          : 'Time';
        const yAxisTitle = layout && layout.yaxis && layout.yaxis.title && layout.yaxis.title.text
          ? layout.yaxis.title.text
          : 'Value';
        
        // Detect axis types from Plotly layout
        const xAxisType = plotlyLayout && plotlyLayout.xaxis && plotlyLayout.xaxis.type ? plotlyLayout.xaxis.type : 'linear';
        const yAxisType = plotlyLayout && plotlyLayout.yaxis && plotlyLayout.yaxis.type ? plotlyLayout.yaxis.type : 'linear';
        
        // Helper function to parse rgb color string to [R, G, B] array
        const parseRgbColor = (colorStr) => {
          if (!colorStr) return null;
          // Handle rgb(r,g,b) format
          const rgbMatch = colorStr.match(/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i);
          if (rgbMatch) {
            return [parseInt(rgbMatch[1]), parseInt(rgbMatch[2]), parseInt(rgbMatch[3])];
          }
          // Handle hex format #RRGGBB or RRGGBB
          const hexMatch = colorStr.match(/#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
          if (hexMatch) {
            return [parseInt(hexMatch[1], 16), parseInt(hexMatch[2], 16), parseInt(hexMatch[3], 16)];
          }
          // Handle short hex format #RGB
          const shortHexMatch = colorStr.match(/^#?([a-f\d])([a-f\d])([a-f\d])$/i);
          if (shortHexMatch) {
            return [
              parseInt(shortHexMatch[1] + shortHexMatch[1], 16),
              parseInt(shortHexMatch[2] + shortHexMatch[2], 16),
              parseInt(shortHexMatch[3] + shortHexMatch[3], 16)
            ];
          }
          return null;
        };
        
        // Map Plotly dash type to Excel dash type (using sys variants for standard Excel look)
        const mapDashType = (plotlyDash) => {
          if (!plotlyDash || plotlyDash === 'solid') return 'solid';
          switch (plotlyDash) {
            case 'dash': return 'sysDash';
            case 'dot': return 'sysDot';
            case 'dashdot': return 'sysDashDot';
            case 'longdash': return 'lgDash';
            case 'longdashdot': return 'lgDashDot';
            default: return 'solid';
          }
        };
        
        // Fallback Plotly-like color palette (brighter colors)
        const plotlyColors = [
          [0x1F, 0x77, 0xB4], // blue
          [0xFF, 0x7F, 0x0E], // orange
          [0x2C, 0xA0, 0x2C], // green
          [0xD6, 0x27, 0x28], // red
          [0x94, 0x67, 0xBD], // purple
          [0x8C, 0x56, 0x4B], // brown
          [0xE3, 0x77, 0xC2], // pink
          [0x7F, 0x7F, 0x7F], // gray
          [0xBC, 0xBD, 0x22], // olive
          [0x17, 0xBE, 0xCF]  // cyan
        ];
        
        // Create workbook using xlsxwrite.js
        const xlsx = new XlsxWriter();
        
        // Plotly-like gridline color (light gray)
        const gridColor = 'E5ECF6';
        const minorGridColor = 'EEF2F8';
        
        // ============ CREATE CHART ============
        // Configure chart with axis settings
        const chartConfig = {
          width: 800,
          height: 500,
          scatterStyle: 'line',  // Line without markers
          showBorder: false,     // Remove chart border
          xAxis: {
            title: { text: xAxisTitle },
            numberFormat: '[>1000]### ### ### ##0;General',
            fontSize: 9,
            majorGridlines: { color: gridColor, width: 0.75 }
          },
          yAxis: {
            title: { text: yAxisTitle, customAngle: -90 },
            numberFormat: '0E+0',
            fontSize: 9,
            majorGridlines: { color: gridColor, width: 0.75 }
          },
          legend: { position: 'r', fontSize: 8 }
        };
        
        // Set logarithmic scale if Plotly uses it, and add minor gridlines/ticks
        if (xAxisType === 'log') {
          chartConfig.xAxis.logBase = 10;
          chartConfig.xAxis.minorGridlines = { color: minorGridColor, width: 0.5 };
          chartConfig.xAxis.minorTickMark = 'out';
        }
        if (yAxisType === 'log') {
          chartConfig.yAxis.logBase = 10;
          chartConfig.yAxis.minorGridlines = { color: minorGridColor, width: 0.5 };
          chartConfig.yAxis.minorTickMark = 'out';
        }
        
        // Set axis min/max to match current Plotly view
        // For log scale: always set limits (needed for proper scaling)
        // For linear scale: only set limits if user has zoomed (autorange is false)
        if (plotlyLayout.xaxis && plotlyLayout.xaxis.range) {
          const xRange = plotlyLayout.xaxis.range;
          const xIsLog = xAxisType === 'log';
          const xIsZoomed = plotlyLayout.xaxis.autorange === false;
          if (xIsLog || xIsZoomed) {
            chartConfig.xAxis.minimum = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
            chartConfig.xAxis.maximum = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
          }
        }
        if (plotlyLayout.yaxis && plotlyLayout.yaxis.range) {
          const yRange = plotlyLayout.yaxis.range;
          const yIsLog = yAxisType === 'log';
          const yIsZoomed = plotlyLayout.yaxis.autorange === false;
          if (yIsLog || yIsZoomed) {
            chartConfig.yAxis.minimum = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
            chartConfig.yAxis.maximum = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
          }
        }
        
        const chart = xlsx.newChart(chartConfig);
        
        // Get x values from the first trace
        const xValues = traces.length > 0 && traces[0].x ? traces[0].x : [];
        
        // Add series to chart
        traces.forEach((trace, idx) => {
          // Get color from trace or use fallback
          let color = plotlyColors[idx % plotlyColors.length];
          const traceColor = trace.line?.color || trace.marker?.color || null;
          if (traceColor) {
            const parsedColor = parseRgbColor(traceColor);
            if (parsedColor) {
              color = parsedColor;
            }
          }
          
          // Get dash type from trace
          const dashType = mapDashType(trace.line?.dash);
          
          // Get line width from trace (default to 2 if not specified)
          const lineWidth = trace.line?.width || 2;
          
          // Filter out null/undefined values
          const yVals = trace.y || [];
          const xVals = trace.x || xValues;
          
          // Create series with xlsxwrite.js
          const series = xlsx.newSeries({
            name: { text: trace.name || `Series ${idx + 1}` },
            x: { values: xVals.map(v => v === null || v === undefined ? NaN : v) },
            y: { values: yVals.map(v => v === null || v === undefined ? NaN : v) },
            length: Math.max(xVals.length, yVals.length),
            line: {
              color: { option: 'Solid', value: color },
              width: lineWidth,
              dashType: dashType,
              capType: 'rnd',
              compoundType: 'sng',
              joinType: 'round',
              beginType: 'none',
              endType: 'none'
            },
            marker: { option: 'NoMarker' }
          });
          
          chart.series.push(series);
        });
        
        // ============ PREPARE DATA ============
        // Build data array with headers
        const headers = ['Time', ...traces.map((t, i) => t.name || `Series ${i + 1}`)];
        const dataRows = [];
        
        for (let i = 0; i < maxLength; i++) {
          const row = [xValues[i] !== undefined ? xValues[i] : null];
          traces.forEach(trace => {
            row.push(trace.y && trace.y[i] !== undefined ? trace.y[i] : null);
          });
          dataRows.push(row);
        }
        
        // Position chart to the right of the data (after all data columns)
        chart.x = (traces.length + 2) * 64;  // Offset by number of columns + margin
        chart.y = 0;
        
        // Write Data sheet with both data AND chart
        xlsx.writeData([headers, ...dataRows], 'Data', { chart: chart });
        
        // Generate filename
        const safeTitle = chartTitle.replace(/[^a-z0-9]/gi, '_').substring(0, 50);
        const filename = `${safeTitle}_${Date.now()}.xlsx`;
        
        // Save and download the file
        await xlsx.saveAs(filename);
        
      } catch (err) {
        console.error('Excel export failed:', err);
        alert('Failed to export to Excel: ' + err.message);
      }
    }
    
    /**
     * Handle "Show Total" checkbox toggle for radionuclides charts.
     * When checked, adds a trace showing the sum of all radionuclide activities.
     * Only applicable when viewing a radionuclides group.
     * 
     * @returns {void}
     */
    function toggleShowTotal() {
      if (selectedIsRadionuclidesGroup && selectedDatasetPath) {
        createRadionuclidesChart(selectedDatasetPath);
      }
    }

    /**
     * Handle "Show Ratio" checkbox toggle for radionuclides charts.
     * When checked, appends the ratio of max values (thick/thin) to the legend
     * name of thick-line traces.
     * 
     * @returns {void}
     */
    function toggleShowRatio() {
      if (selectedIsRadionuclidesGroup && selectedDatasetPath) {
        createRadionuclidesChart(selectedDatasetPath);
      }
    }


    /* ==========================================================================
       9. CHART CREATION
       ========================================================================== */
    
    /**
     * Create a Plotly chart for a single time-dependent dataset.
     * Plots the dataset from all enabled files as separate traces,
     * allowing comparison across files.
     * 
     * @param {string} path - HDF5 path to the dataset
     * @returns {void}
     */
    function createPlotlyChart(path) {
      const plotDiv = getElement('plotlyChart');
      const chartContainer = getElement('plotlyChartContainer');
      plotDiv.innerHTML = '';
      
      // Hide "Show Total" and "Show Ratio" checkboxes (only for radionuclides groups)
      setShowTotalVisible(false);
      setShowRatioVisible(false);
      
      const traces = [];
      const enabledFiles = getEnabledFiles();
      
      let timeUnit = '';
      let yAxisUnit = '';
      let yAxisName = path.split('/').pop();
      
      if (enabledFiles.length > 0) {
        const firstFile = loadedFiles[enabledFiles[0]];
        timeUnit = getTimeUnit(firstFile);
        
        // Get y-axis unit from dataset
        try {
          const dataset = firstFile.get(path);
          if (dataset && dataset.attrs && typeof dataset.attrs === 'object') {
            for (const attrName in dataset.attrs) {
              if (attrName === 'unit') {
                const attrObj = dataset.attrs[attrName];
                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                  yAxisUnit = attrObj.value;
                }
              }
            }
          }
        } catch (e) {
          console.warn('Could not read unit from dataset:', e);
        }
      }
      
      // Build traces for each enabled file
      for (const fileKey of enabledFiles) {
        const file = loadedFiles[fileKey];
        
        if (!checkDatasetExistsInFile(file, path)) {
          continue;
        }
        
        try {
          const dataset = file.get(path);
          
          if (!isTimeDependent(dataset)) {
            continue;
          }
          
          const timeData = getTimeData(file);
          if (!timeData) {
            console.warn(`No /time dataset found in ${fileKey}`);
            continue;
          }
          
          let yData;
          if (typeof dataset.value !== 'undefined') {
            yData = dataset.value;
          } else if (typeof dataset.toArray === 'function') {
            yData = dataset.toArray();
          }
          
          if (yData) {
            let yArray = normalizeDataArray(yData);
            
            // Handle probabilistic data (take mean)
            if (checkIsProbabilistic(dataset)) {
              yArray = computeProbabilisticMean(yArray, timeData);
            }

            // Handle length mismatch
            const minLength = Math.min(timeData.length, yArray.length);
            if (timeData.length !== yArray.length) {
              console.warn(`Time data length (${timeData.length}) doesn't match data length (${yArray.length}) for ${fileKey}`);
            }
            
            traces.push({
              x: timeData.slice(0, minLength),
              y: yArray.slice(0, minLength),
              mode: 'lines+markers',
              name: fileKey,
              type: 'scatter'
            });
          }
        } catch (e) {
          console.error(`Error creating trace for ${fileKey}:`, e);
        }
      }
      
      // Render chart if we have data
      if (traces.length > 0) {
        const { xScale, yScale } = getChartScales();
        const yAxisTitle = yAxisUnit ? `${yAxisName} (${yAxisUnit})` : yAxisName;
        
        const layout = createBaseLayout({
          title: path,
          xAxisTitle: timeUnit ? `Time (${timeUnit})` : 'Time',
          yAxisTitle,
          xScale,
          yScale
        });

        renderChart(traces, layout, path);
      } else {
        hideChart();
      }
    }

    /**
     * Create a Plotly chart comparing multiple selected datasets.
     * Each dataset gets a unique color; if multiple files are enabled,
     * different line dash styles distinguish files for the same dataset.
     * 
     * Used in multi-select mode (Ctrl+click on multiple datasets).
     * 
     * @param {string[]} paths - Array of HDF5 dataset paths to compare
     * @returns {void}
     */
    function createMultiDatasetChart(paths) {
      const plotDiv = getElement('plotlyChart');
      const chartContainer = getElement('plotlyChartContainer');
      plotDiv.innerHTML = '';
      
      // Hide "Show Total" and "Show Ratio" checkboxes (only for radionuclides groups)
      setShowTotalVisible(false);
      setShowRatioVisible(false);
      
      const traces = [];
      const enabledFiles = getEnabledFiles();
      
      let timeUnit = '';
      const yAxisUnits = new Set();
      
      if (enabledFiles.length > 0) {
        const firstFile = loadedFiles[enabledFiles[0]];
        timeUnit = getTimeUnit(firstFile);
      }
      
      // Color palette for different datasets
      const colors = [
        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
        '#1abc9c', '#e67e22', '#34495e', '#c0392b', '#2980b9',
        '#27ae60', '#f1c40f', '#8e44ad', '#16a085', '#d35400'
      ];
      
      for (const [pathIndex, path] of paths.entries()) {
        const datasetName = path.split('/').pop();
        const baseColor = colors[pathIndex % colors.length];
        
        for (const [fileIndex, fileKey] of enabledFiles.entries()) {
          const file = loadedFiles[fileKey];
          
          if (!checkDatasetExistsInFile(file, path)) {
            continue;
          }
          
          try {
            const dataset = file.get(path);
            
            if (!isTimeDependent(dataset)) {
              continue;
            }
            
            // Get unit
            let yAxisUnit = '';
            if (dataset.attrs && typeof dataset.attrs === 'object') {
              for (const attrName in dataset.attrs) {
                if (attrName === 'unit') {
                  const attrObj = dataset.attrs[attrName];
                  if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                    yAxisUnit = attrObj.value;
                    yAxisUnits.add(yAxisUnit);
                  }
                }
              }
            }
            
            const timeData = getTimeData(file);
            if (!timeData) {
              console.warn(`No /time dataset found in ${fileKey}`);
              continue;
            }
            
            let yData;
            if (typeof dataset.value !== 'undefined') {
              yData = dataset.value;
            } else if (typeof dataset.toArray === 'function') {
              yData = dataset.toArray();
            }
            
            if (yData) {
              let yArray = normalizeDataArray(yData);
              
              // Handle probabilistic data (take mean)
              if (checkIsProbabilistic(dataset)) {
                yArray = computeProbabilisticMean(yArray, timeData);
              }

              const minLength = Math.min(timeData.length, yArray.length);
              const trimmedTimeData = timeData.slice(0, minLength);
              const trimmedYData = yArray.slice(0, minLength);
              
              // Adjust style for multiple files
              let traceName = datasetName;
              let lineColor = baseColor;
              let lineWidth = 2;
              let lineDash = 'solid';
              
              if (enabledFiles.length > 1) {
                traceName = `${datasetName} (${fileKey})`;
                lineWidth = 1.5;
                const dashStyles = ['solid', 'dash', 'dot', 'dashdot'];
                lineDash = dashStyles[fileIndex % dashStyles.length];
              }
              
              traces.push({
                x: trimmedTimeData,
                y: trimmedYData,
                mode: 'lines+markers',
                name: traceName,
                line: {
                  color: lineColor,
                  dash: lineDash,
                  width: lineWidth
                },
                type: 'scatter',
                hovertemplate: `<b>${traceName}</b><br>Time: %{x}<br>Value: %{y}<extra></extra>`
              });
            }
          } catch (e) {
            console.error(`Error creating trace for ${path} in ${fileKey}:`, e);
          }
        }
      }
      
      if (traces.length > 0) {
        const { xScale, yScale } = getChartScales();
        
        let yAxisTitle = 'Value';
        if (yAxisUnits.size === 1) {
          yAxisTitle = `Value (${Array.from(yAxisUnits)[0]})`;
        } else if (yAxisUnits.size > 1) {
          yAxisTitle = `Value (${Array.from(yAxisUnits).join(', ')})`;
        }
        
        const layout = createBaseLayout({
          title: `Comparing ${paths.length} dataset${paths.length > 1 ? 's' : ''}`,
          xAxisTitle: timeUnit ? `Time (${timeUnit})` : 'Time',
          yAxisTitle,
          xScale,
          yScale
        });
        layout.margin.r = 200; // Extra room for longer legend names
        
        const config = getPlotlyConfig('multi_dataset_chart');

        currentChartData = { traces, layout, paths };
        const container = getElement('plotlyChartContainer');
        if (container) container.classList.add('visible');
        Plotly.newPlot('plotlyChart', traces, layout, config).then(() => {
          setupDynamicLegend(getElement('plotlyChart'));
        });
      } else {
        hideChart();
      }
    }

    /**
     * Create a Plotly chart for a radionuclides data group.
     * Plots all child datasets (isotopes) with predefined line styles.
     * 
     * Features:
     * - Each isotope uses its characteristic color and dash pattern
     * - "Show Total" checkbox adds a summed trace
     * - Supports multi-file comparison with thinner lines for secondary files
     * 
     * @param {string} path - HDF5 path to the radionuclides group
     * @returns {void}
     */
    function createRadionuclidesChart(path) {
      const plotDiv = getElement('plotlyChart');
      const chartContainer = getElement('plotlyChartContainer');
      plotDiv.innerHTML = '';
      
      // Show "Show Total" checkbox for radionuclides groups
      setShowTotalVisible(true);
      
      const traces = [];
      const enabledFiles = getEnabledFiles();
      
      // Show "Show Ratio" checkbox only when exactly 2 files are enabled (thick + thin lines)
      const hasTwoFiles = enabledFiles.length === 2;
      setShowRatioVisible(hasTwoFiles);
      
      // Store data for computing total
      const totalDataByFile = {};
      
      // Track the starting index of each file's traces in the traces array
      const fileTraceStartIndex = {};

      let timeUnit = '';
      let yAxisUnit = '';
      let yAxisName = path.split('/').pop();
      
      if (enabledFiles.length > 0) {
        const firstFile = loadedFiles[enabledFiles[0]];
        timeUnit = getTimeUnit(firstFile);
      }
      
      // Build traces for each file and each radionuclide
      for (const fileKey of enabledFiles) {
        const file = loadedFiles[fileKey];
        
        // Record where this file's traces begin
        fileTraceStartIndex[fileKey] = traces.length;
        
        if (!checkDatasetExistsInFile(file, path)) {
          continue;
        }
        
        try {
          const group = file.get(path);
          if (!group || group.type.toLowerCase() !== 'group') {
            continue;
          }
          
          const timeData = getTimeData(file);
          if (!timeData) {
            console.warn(`No /time dataset found in ${fileKey}`);
            continue;
          }
          
          let datasetKeys = [];
          try {
            if (typeof group.keys === 'function') {
              datasetKeys = Array.from(group.keys());
            }
          } catch (e) {
            console.error('Error getting dataset keys:', e);
            continue;
          }
          
          for (const datasetKey of datasetKeys) {
            try {
              const dataset = group.get(datasetKey);
              if (!dataset || dataset.type.toLowerCase() !== 'dataset') {
                continue;
              }
              
              let yData;
              if (typeof dataset.value !== 'undefined') {
                yData = dataset.value;
              } else if (typeof dataset.toArray === 'function') {
                yData = dataset.toArray();
              }
              
              if (yData) {
                let yArray = normalizeDataArray(yData);
                
                // Handle probabilistic data
                if (checkIsProbabilistic(dataset)) {
                  yArray = computeProbabilisticMean(yArray, timeData);
                }

                const minLength = Math.min(timeData.length, yArray.length);
                const trimmedTimeData = timeData.slice(0, minLength);
                const trimmedYData = yArray.slice(0, minLength);
                
                // Store data for computing total
                if (!totalDataByFile[fileKey]) {
                  totalDataByFile[fileKey] = { timeData: trimmedTimeData, dataArrays: [] };
                }
                totalDataByFile[fileKey].dataArrays.push(trimmedYData);
                
                // Get line style for this radionuclide
                const lineStyle = getLineStyle(datasetKey);
                let traceName = datasetKey;
                let lineWidth = lineStyle.width;
                
                if (enabledFiles.length > 1 && enabledFiles.indexOf(fileKey) > 0) {
                  traceName = `${datasetKey} (${fileKey})`;
                  lineWidth = lineWidth / 2;
                }
                
                traces.push({
                  x: trimmedTimeData,
                  y: trimmedYData,
                  mode: 'lines',
                  name: traceName,
                  line: {
                    color: lineStyle.color,
                    dash: lineStyle.dash,
                    width: lineWidth
                  },
                  type: 'scatter'
                });
              }
            } catch (e) {
              console.error(`Error creating trace for ${datasetKey} in ${fileKey}:`, e);
            }
          }
        } catch (e) {
          console.error(`Error processing group for ${fileKey}:`, e);
        }
      }
      
      // Collect max values per radionuclide per file (needed for ratio display)
      const showRatioCheckbox = getElement('showRatio');
      const showRatioChecked = hasTwoFiles && showRatioCheckbox && showRatioCheckbox.checked;
      const maxByFileAndName = {}; // { datasetKey: { fileKey: maxVal } }
      if (showRatioChecked) {
        for (const fileKey of enabledFiles) {
          const fileData = totalDataByFile[fileKey];
          if (!fileData) continue;
          const file = loadedFiles[fileKey];
          const group = file.get(path);
          let datasetKeys = [];
          try {
            if (typeof group.keys === 'function') {
              datasetKeys = Array.from(group.keys());
            }
          } catch (e) { /* ignore */ }
          // Match datasetKeys to dataArrays by index
          for (let i = 0; i < datasetKeys.length && i < fileData.dataArrays.length; i++) {
            const key = datasetKeys[i];
            const arr = fileData.dataArrays[i];
            const maxVal = Math.max(...arr);
            if (!maxByFileAndName[key]) maxByFileAndName[key] = {};
            maxByFileAndName[key][fileKey] = maxVal;
          }
        }
      }

      const primaryFile = enabledFiles[0];
      const secondaryFile = hasTwoFiles ? enabledFiles[1] : null;

      /**
       * Format a ratio value to a display string (3 significant digits).
       * @param {number} ratio
       * @returns {string}
       */
      function formatRatio(ratio) {
        if (ratio === 0 || !isFinite(ratio)) return ratio.toString();
        return ratio.toPrecision(3);
      }

      // Add total traces, each at the top of its corresponding file's group in the legend
      const showTotalCheckbox = getElement('showTotal');
      if (showTotalCheckbox && showTotalCheckbox.checked) {
        // Compute total per file and collect total max values for ratio
        const totalMaxByFile = {}; // { fileKey: maxTotalValue }
        const totalTracesByFile = {}; // { fileKey: traceObject }
        for (const fileKey of Object.keys(totalDataByFile)) {
          const fileData = totalDataByFile[fileKey];
          if (fileData.dataArrays.length > 0) {
            const timeData = fileData.timeData;
            const totalY = new Array(timeData.length).fill(0);
            
            // Sum all data arrays
            for (const dataArray of fileData.dataArrays) {
              for (let i = 0; i < Math.min(dataArray.length, totalY.length); i++) {
                totalY[i] += dataArray[i];
              }
            }
            
            totalMaxByFile[fileKey] = Math.max(...totalY);

            let traceName = 'Total';
            let lineWidth = 2;
            
            if (enabledFiles.length > 1 && enabledFiles.indexOf(fileKey) > 0) {
              traceName = `Total (${fileKey})`;
              lineWidth = 1;
            }
            
            totalTracesByFile[fileKey] = {
              x: timeData,
              y: totalY,
              mode: 'lines',
              name: traceName,
              line: {
                color: '#000000',
                dash: 'solid',
                width: lineWidth
              },
              type: 'scatter'
            };
          }
        }

        // If Show Ratio is checked, append ratio to the primary Total trace name
        if (showRatioChecked && secondaryFile) {
          const t = totalTracesByFile[primaryFile];
          if (t && t.name === 'Total') {
            const maxPrimary = totalMaxByFile[primaryFile];
            const maxSecondary = totalMaxByFile[secondaryFile];
            if (maxSecondary != null && maxSecondary !== 0) {
              t.name = `Total (${formatRatio(maxPrimary / maxSecondary)})`;
            } else if (maxSecondary === 0 && maxPrimary > 0) {
              t.name = `Total (‚àû)`;
            }
          }
        }

        // Insert each total trace at the beginning of its file's group.
        // Process files in reverse order so earlier splice positions stay valid.
        const filesWithTotals = enabledFiles.filter(fk => totalTracesByFile[fk]);
        for (let i = filesWithTotals.length - 1; i >= 0; i--) {
          const fk = filesWithTotals[i];
          const insertIdx = fileTraceStartIndex[fk] != null ? fileTraceStartIndex[fk] : traces.length;
          traces.splice(insertIdx, 0, totalTracesByFile[fk]);
        }
      }

      // Update thick-line trace names with ratio of max values if "Show Ratio" is checked
      if (showRatioChecked) {
        for (const trace of traces) {
          // Thick-line traces are those from the primary file (no fileKey suffix, not Total)
          for (const datasetKey of Object.keys(maxByFileAndName)) {
            if (trace.name === datasetKey) {
              const maxPrimary = maxByFileAndName[datasetKey][primaryFile];
              const maxSecondary = maxByFileAndName[datasetKey][secondaryFile];
              if (maxSecondary != null && maxSecondary !== 0) {
                trace.name = `${datasetKey} (${formatRatio(maxPrimary / maxSecondary)})`;
              } else if (maxSecondary === 0 && maxPrimary > 0) {
                trace.name = `${datasetKey} (‚àû)`;
              }
              break;
            }
          }
        }
      }
      
      // Render chart if we have traces
      if (traces.length > 0) {
        // Get unit from group
        const firstFile = loadedFiles[enabledFiles[0]];
        try {
          const group = firstFile.get(path);
          if (group && group.attrs && typeof group.attrs === 'object') {
            for (const attrName in group.attrs) {
              if (attrName === 'unit') {
                const attrObj = group.attrs[attrName];
                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                  yAxisUnit = attrObj.value;
                }
              }
            }
          }
        } catch (e) {
          console.warn('Could not read unit from group:', e);
        }
        
        const { xScale, yScale } = getChartScales();
        const yAxisTitle = yAxisUnit ? `${yAxisName} (${yAxisUnit})` : yAxisName;
        
        const layout = createBaseLayout({
          title: path,
          xAxisTitle: timeUnit ? `Time (${timeUnit})` : 'Time',
          yAxisTitle,
          xScale,
          yScale
        });
        
        renderChart(traces, layout, path);
      } else {
        hideChart();
      }
    }
    
    /**
     * Get standard Plotly configuration with custom toolbar buttons.
     * Configures the mode bar with:
     * - Copy to clipboard button (PNG export)
     * - Download CSV button (data export)
     * - Download Excel button (xlsx export)
     * - Standard Plotly zoom/pan/reset tools
     * - SVG export configuration
     * 
     * @param {string} filename - Base filename for exported images/data
     * @returns {Object} Plotly config object
     */
    function getPlotlyConfig(filename) {
      return {
        displayLogo: false,
        scrollZoom: true,
        showLink: false,
        plotlyServerURL: "https://chart-studio.plotly.com",
        modeBarButtonsToAdd: [
          'v1hovermode',
          {
            name: 'Copy chart to clipboard',
            icon: {
              width: 500,
              height: 600,
              path: 'M224 0c-35.3 0-64 28.7-64 64V288v64 64c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V288 160 64c0-35.3-28.7-64-64-64H224zm0 64H448V160H224V64zM160 448c0 17.7-14.3 32-32 32H64c-17.7 0-32-14.3-32-32V384H160v64zm0-96H32V288H160v64zM32 240V176H160v64H32zM160 128V64h32v64H160z'
            },
            click: function(gd) {
              copyChartToClipboard();
            }
          },
          {
            name: 'Download data as CSV',
            icon: {
              width: 512,
              height: 512,
              path: 'M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zm368 56a24 24 0 1 1 0 48 24 24 0 1 1 0-48z'
            },
            click: function(gd) {
              downloadChartData();
            }
          },
          {
            name: 'Download data as Excel',
            icon: {
              width: 384,
              height: 512,
              path: 'M64 0C28.7 0 0 28.7 0 64V448c0 35.3 28.7 64 64 64H320c35.3 0 64-28.7 64-64V160H256c-17.7 0-32-14.3-32-32V0H64zM256 0V128H384L256 0zM155.7 250.2L192 302.1l36.3-51.9c7.6-10.9 22.6-13.5 33.4-5.9s13.5 22.6 5.9 33.4L221.3 344l46.4 66.2c7.6 10.9 5 25.8-5.9 33.4s-25.8 5-33.4-5.9L192 385.8l-36.3 51.9c-7.6 10.9-22.6 13.5-33.4 5.9s-13.5-22.6-5.9-33.4L162.7 344l-46.4-66.2c-7.6-10.9-5-25.8 5.9-33.4s25.8-5 33.4 5.9z'
            },
            click: function(gd) {
              downloadChartDataAsExcel();
            }
          }
        ],
        responsive: true,
        toImageButtonOptions: {
          format: 'svg',
          filename: filename,
          height: 600,
          width: 800,
          scale: 1
        }
      };
    }


    /* ==========================================================================
       10. DYNAMIC LEGEND
       ========================================================================== */
    
    /**
     * Toggle dynamic legend filtering on/off.
     * When enabled, only traces with data points visible in the current
     * viewport are shown in the legend. When disabled, all traces are shown.
     * 
     * @returns {void}
     */
    function toggleDynamicLegend() {
      dynamicLegendEnabled = document.getElementById('dynamicLegend').checked;
      
      const plotDiv = document.getElementById('plotlyChart');
      if (!plotDiv || !plotDiv.data || !plotDiv.layout) {
        return;
      }
      
      if (!dynamicLegendEnabled) {
        // Show all legend items
        const newData = plotDiv.data.map(trace => ({
          ...trace,
          showlegend: true
        }));
        
        Plotly.react(plotDiv, newData, plotDiv.layout).then(() => {
          const statusEl = document.getElementById('legendStatus');
          if (statusEl) {
            statusEl.style.display = 'none';
          }
        });
      } else {
        // Re-apply dynamic filtering based on current view
        const layout = plotDiv.layout;
        
        let xRange = layout.xaxis?.range;
        let yRange = layout.yaxis?.range;
        
        if (!xRange || !yRange) {
          return;
        }
        
        const xIsLog = layout.xaxis?.type === 'log';
        const yIsLog = layout.yaxis?.type === 'log';
        
        const xMin = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
        const xMax = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
        const yMin = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
        const yMax = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
        
        let visibleCount = 0;
        const newData = plotDiv.data.map((trace) => {
          let isVisible = false;
          
          for (let j = 0; j < trace.x.length; j++) {
            const x = trace.x[j];
            const y = trace.y[j];
            
            if (x === null || x === undefined || y === null || y === undefined) {
              continue;
            }
            
            if (x >= xMin && x <= xMax && y >= yMin && y <= yMax) {
              isVisible = true;
              break;
            }
          }
          
          if (isVisible) visibleCount++;
          
          return {
            ...trace,
            showlegend: isVisible
          };
        });
        
        Plotly.react(plotDiv, newData, plotDiv.layout).then(() => {
          const totalCount = plotDiv.data.length;
          const statusEl = document.getElementById('legendStatus');
          
          if (statusEl) {
            if (visibleCount < totalCount) {
              statusEl.textContent = `Showing ${visibleCount}/${totalCount} traces`;
              statusEl.style.display = 'block';
            } else {
              statusEl.style.display = 'none';
            }
          }
        });
      }
    }
    
    /**
     * Set up dynamic legend filtering on zoom/pan events.
     * Attaches a plotly_relayout listener that updates legend visibility
     * based on which traces have data points in the current viewport.
     * 
     * This helps reduce legend clutter when zoomed in on charts with many traces.
     * A status indicator shows "Showing X/Y traces" when filtering is active.
     * 
     * @param {HTMLElement} plotDiv - The Plotly chart DOM element
     * @returns {void}
     */
    function setupDynamicLegend(plotDiv) {
      plotDiv.on('plotly_relayout', function(eventData) {
        if (!dynamicLegendEnabled) return;
        
        if (!eventData || (!eventData['xaxis.range[0]'] && !eventData['xaxis.range'] && !eventData['xaxis.autorange'])) {
          return;
        }
        
        const fullData = plotDiv.data;
        const layout = plotDiv.layout;
        
        let xRange, yRange;
        
        if (eventData['xaxis.autorange'] || eventData['yaxis.autorange']) {
          // Autorange - show all traces
          const visibility = fullData.map(() => true);
          Plotly.restyle(plotDiv, { showlegend: visibility });
          
          const statusEl = document.getElementById('legendStatus');
          if (statusEl) {
            statusEl.style.display = 'none';
          }
          return;
        }
        
        // Get axis ranges
        if (eventData['xaxis.range[0]'] !== undefined) {
          xRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
        } else if (eventData['xaxis.range']) {
          xRange = eventData['xaxis.range'];
        } else if (layout.xaxis && layout.xaxis.range) {
          xRange = layout.xaxis.range;
        }
        
        if (eventData['yaxis.range[0]'] !== undefined) {
          yRange = [eventData['yaxis.range[0]'], eventData['yaxis.range[1]']];
        } else if (eventData['yaxis.range']) {
          yRange = eventData['yaxis.range'];
        } else if (layout.yaxis && layout.yaxis.range) {
          yRange = layout.yaxis.range;
        }
        
        if (!xRange || !yRange) return;
        
        // Convert log scale ranges
        const xIsLog = layout.xaxis && layout.xaxis.type === 'log';
        const yIsLog = layout.yaxis && layout.yaxis.type === 'log';
        
        const xMin = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
        const xMax = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
        const yMin = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
        const yMax = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
        
        // Check each trace for visibility
        const visibility = fullData.map((trace, i) => {
          for (let j = 0; j < trace.x.length; j++) {
            const x = trace.x[j];
            const y = trace.y[j];
            
            if (x === null || x === undefined || y === null || y === undefined) {
              continue;
            }
            
            if (x >= xMin && x <= xMax && y >= yMin && y <= yMax) {
              return true;
            }
          }
          return false;
        });
        
        Plotly.restyle(plotDiv, { showlegend: visibility }).then(() => {
          const visibleCount = visibility.filter(v => v).length;
          const totalCount = fullData.length;
          const statusEl = document.getElementById('legendStatus');
          
          if (statusEl) {
            if (visibleCount < totalCount) {
              statusEl.textContent = `Showing ${visibleCount}/${totalCount} traces`;
              statusEl.style.display = 'block';
            } else {
              statusEl.style.display = 'none';
            }
          }
        });
      });
    }


    /* ==========================================================================
       11. DATASET INFORMATION DISPLAY
       ========================================================================== */
    
    /**
     * Display node attributes and information for a selected path
     * Shows data preview, attributes table, and triggers chart if time-dependent
     * @param {string} path - HDF5 path to the node
     * @param {boolean} isGroup - Whether the node is a group (vs dataset)
     */
    function showNodeAttributes(path, isGroup = false) {
      const infoDiv = document.getElementById('info');
      infoDiv.innerHTML = '<div class="loading">Loading...</div>';
      
      const jsonReplacer = (key, value) => {
        if (typeof value === 'bigint') {
          return value.toString() + 'n';
        }
        if (value && typeof value === 'object' && value.length !== undefined) {
          return Array.from(value);
        }
        return value;
      };
      
      try {
        const enabledFiles = getEnabledFiles();
        let html = '';
        let hasTimeDependentData = false;
        let isRadionuclidesGroup = false;
        
        // Check if this is a radionuclides group
        if (isGroup && enabledFiles.length > 0) {
          const firstFile = loadedFiles[enabledFiles[0]];
          isRadionuclidesGroup = checkGroupForRadionuclides(firstFile, path);
          selectedIsRadionuclidesGroup = isRadionuclidesGroup;
        } else {
          selectedIsRadionuclidesGroup = false;
        }
        
        // Build HTML for each enabled file
        for (const fileKey of enabledFiles) {
          const file = loadedFiles[fileKey];
          
          if (!checkDatasetExistsInFile(file, path)) {
            continue;
          }
          
          const node = file.get(path);
          if (!node) continue;
          
          const isFirstFile = fileKey === enabledFiles[0];
          const fileColor = isFirstFile ? '#0066cc' : '#10b981';
          
          html += `<div class="file-data-section" style="border-left-color: ${fileColor};">`;
          html += `<h4>${escapeHtml(fileKey)}</h4>`;
          
          // Show path, type, dtype, shape only for first file
          if (isFirstFile) {
            html += `<div class="info-section">
              <div class="info-label">Path</div>
              <div class="info-content">${escapeHtml(path)}</div>
            </div>`;
            
            html += `<div class="info-section">
              <div class="info-label">Type</div>
              <div class="info-content">${escapeHtml(String(node.type))}</div>
            </div>`;
            
            if (!isGroup && node.dtype) {
              const readableDtype = formatDataType(node.dtype);
              html += `<div class="info-section">
                <div class="info-label">Data Type</div>
                <div class="info-content">${escapeHtml(readableDtype)}</div>
              </div>`;
            }
            
            if (node.shape && Array.isArray(node.shape)) {
              html += `<div class="info-section">
                <div class="info-label">Shape</div>
                <div class="info-content">${node.shape.join(', ')}</div>
              </div>`;
            }
          }
          
          // Show data preview for datasets (not groups)
          if (!isGroup) {
            if (isTimeDependent(node)) {
              hasTimeDependentData = true;
            }
            
            try {
              let data;
              if (typeof node.value !== 'undefined') {
                data = node.value;
              } else if (typeof node.toArray === 'function') {
                data = node.toArray();
              }
              
              if (data !== undefined) {
                let preview;
                let itemCount;
                let fullData;
                
                if (Array.isArray(data)) {
                  preview = data.slice(0, 100);
                  itemCount = data.length;
                  fullData = data;
                } else if (data && typeof data === 'object' && data.length !== undefined) {
                  preview = Array.from(data).slice(0, 100);
                  itemCount = data.length;
                  fullData = Array.from(data);
                } else {
                  preview = [data];
                  itemCount = 1;
                  fullData = [data];
                }
                
                const isScalar = itemCount === 1;
                const downloadBtnId = `downloadData_${fileKey.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`;
                
                html += `<div class="info-section">
                  <div class="info-label" style="display: flex; align-items: center; justify-content: space-between;">
                    <span>Data Preview (first ${preview.length}/${itemCount} items)</span>
                    ${!isScalar ? `<button 
                      id="${downloadBtnId}" 
                      class="download-data-btn" 
                      style="padding: 4px 8px; background: var(--color-kvot-background); color: var(--color-kvot-bright); border: none; border-radius: 3px; cursor: pointer; font-size: 11px; font-weight: 500; transition: all 0.2s;"
                      onmouseover="this.style.background='var(--color-kvot-primary)'" 
                      onmouseout="this.style.background='var(--color-kvot-background)'"
                      title="Download full dataset as CSV">
                      ‚¨á Download CSV
                    </button>` : ''}
                  </div>
                  <div class="info-content">${escapeHtml(JSON.stringify(preview, jsonReplacer, 2))}</div>
                </div>`;
                
                // Setup download button handler
                if (!isScalar) {
                  setTimeout(() => {
                    const downloadBtn = document.getElementById(downloadBtnId);
                    if (downloadBtn) {
                      downloadBtn.addEventListener('click', () => {
                        downloadDatasetAsCSV(node, fullData, path, fileKey);
                      });
                    }
                  }, 0);
                }
              }
            } catch (e) {
              console.warn('Could not read data:', e.message);
            }
          }
          
          // Show attributes table
          const attrs = {};
          let hasAttributes = false;
          
          try {
            if (node.attrs && typeof node.attrs === 'object') {
              for (const attrName in node.attrs) {
                if (!attrName.startsWith('_') && typeof node.attrs[attrName] === 'object') {
                  try {
                    const attrObj = node.attrs[attrName];
                    let attrValue;
                    
                    if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                      attrValue = attrObj.value;
                    } else {
                      attrValue = attrObj;
                    }
                    
                    attrs[attrName] = attrValue;
                    hasAttributes = true;
                  } catch (e) {
                    attrs[attrName] = `(unreadable: ${e.message})`;
                  }
                }
              }
            }
          } catch (e) {
            console.warn('Error reading attributes:', e.message);
          }
          
          if (hasAttributes && Object.keys(attrs).length > 0) {
            html += buildAttributesTable(attrs, jsonReplacer);
          }
          
          // Add Excel download button for datasets (not groups)
          if (!isGroup) {
            const escapedPath = path.replace(/'/g, "\\'");
            const escapedFileKey = fileKey.replace(/'/g, "\\'");
            html += `<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--color-border);">
              <button onclick="downloadDatasetAsExcel('${escapedPath}', '${escapedFileKey}')" 
                style="padding: 6px 12px; background: #217346; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500; transition: all 0.2s;"
                onmouseover="this.style.background='#1e6b3f'" 
                onmouseout="this.style.background='#217346'"
                title="Download this dataset to Excel">
                üìä Download Excel
              </button>
            </div>`;
          }
          
          html += '</div>';
        }
        
        infoDiv.innerHTML = html || '<div style="color:#999;">No data available for this path</div>';
        
        // Create chart if appropriate
        if (isRadionuclidesGroup) {
          createRadionuclidesChart(path);
        } else if (hasTimeDependentData && !isGroup) {
          createPlotlyChart(path);
        } else {
          document.getElementById('plotlyChartContainer').classList.remove('visible');
          currentChartData = null;
        }
      } catch (e) {
        infoDiv.innerHTML = `<div class="error">Error: ${escapeHtml(e.message)}</div>`;
        console.error(e);
      }
    }

    /**
     * Download dataset data as CSV file
     * @param {Object} node - HDF5 dataset node
     * @param {Array} fullData - Full data array
     * @param {string} path - Dataset path
     * @param {string} fileKey - File name
     */
    function downloadDatasetAsCSV(node, fullData, path, fileKey) {
      // Get index attribute if it exists
      let headerRow = null;
      try {
        if (node.attrs && typeof node.attrs === 'object') {
          for (const attrName in node.attrs) {
            if (attrName === 'index') {
              const attrObj = node.attrs[attrName];
              if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                const indexValue = attrObj.value;
                if (Array.isArray(indexValue)) {
                  headerRow = indexValue;
                } else if (indexValue && typeof indexValue === 'object' && indexValue.length !== undefined) {
                  headerRow = Array.from(indexValue);
                }
              }
            }
          }
        }
      } catch (e) {
        console.warn('Could not read index attribute:', e);
      }
      
      // Determine data shape and build CSV
      let csvContent = '';
      const shape = node.shape || [];
      
      if (shape.length === 1) {
        // 1D array - single column
        if (headerRow && headerRow.length === 1) {
          csvContent += escapeCSV(headerRow[0]) + '\n';
        }
        fullData.forEach(value => {
          csvContent += escapeCSV(value) + '\n';
        });
      } else if (shape.length === 2) {
        // 2D array - rows and columns
        const numRows = shape[0];
        const numCols = shape[1];
        
        if (headerRow && headerRow.length === numCols) {
          csvContent += headerRow.map(h => escapeCSV(h)).join(',') + '\n';
        }
        
        for (let i = 0; i < numRows; i++) {
          const row = [];
          for (let j = 0; j < numCols; j++) {
            row.push(escapeCSV(fullData[i * numCols + j]));
          }
          csvContent += row.join(',') + '\n';
        }
      } else if (shape.length === 0) {
        // Scalar or flat array
        if (headerRow && headerRow.length > 0) {
          csvContent += headerRow.map(h => escapeCSV(h)).join(',') + '\n';
        }
        
        if (headerRow && headerRow.length > 1) {
          const numCols = headerRow.length;
          const numRows = Math.floor(fullData.length / numCols);
          for (let i = 0; i < numRows; i++) {
            const row = [];
            for (let j = 0; j < numCols; j++) {
              row.push(escapeCSV(fullData[i * numCols + j]));
            }
            csvContent += row.join(',') + '\n';
          }
        } else {
          fullData.forEach(value => {
            csvContent += escapeCSV(value) + '\n';
          });
        }
      } else {
        // Higher dimensional - flatten to 2D
        console.warn('Multi-dimensional array, flattening to 2D');
        if (headerRow) {
          csvContent += headerRow.map(h => escapeCSV(h)).join(',') + '\n';
        }
        
        const lastDim = shape[shape.length - 1];
        const numRows = Math.floor(fullData.length / lastDim);
        
        for (let i = 0; i < numRows; i++) {
          const row = [];
          for (let j = 0; j < lastDim; j++) {
            row.push(escapeCSV(fullData[i * lastDim + j]));
          }
          csvContent += row.join(',') + '\n';
        }
      }
      
      // Create and download CSV
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const safePath = path.replace(/[^a-zA-Z0-9]/g, '_');
      const safeFileName = fileKey.replace(/\.[^/.]+$/, '');
      a.download = `${safeFileName}${safePath}_data.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /**
     * Download selected dataset information, attributes, and data as Excel file
     * Uses xlsxwrite.js library
     */
    async function downloadDatasetAsExcel(datasetPath, datasetFileKey) {
      // Use provided parameters or fall back to selected dataset
      const path = datasetPath || selectedDatasetPath;
      if (!path) {
        alert('No dataset selected');
        return;
      }
      
      const enabledFiles = getEnabledFiles();
      if (enabledFiles.length === 0) {
        alert('No files enabled');
        return;
      }
      
      try {
        // Use specified file or first enabled file
        const fileKey = datasetFileKey || enabledFiles[0];
        const file = loadedFiles[fileKey];
        if (!file) {
          alert('File not found: ' + fileKey);
          return;
        }
        const node = file.get(path);
        
        if (!node) {
          alert('Could not access dataset');
          return;
        }
        
        const isGroup = node.type === 'Group';
        const safeFileName = fileKey.replace(/\.[^/.]+$/, '').replace(/[^a-zA-Z0-9]/g, '_');
        const safePath = path.replace(/[^a-zA-Z0-9]/g, '_');
        
        // Create workbook
        const xlsx = new XlsxWriter(`${safeFileName}${safePath}.xlsx`);
        
        // Create formats
        const headerFormat = xlsx.addFormat({
          bold: true,
          bg_color: '217346',
          font_color: 'FFFFFF',
          align: 'center',
          valign: 'vcenter',
          border: 1
        });
        
        const labelFormat = xlsx.addFormat({
          bold: true,
          bg_color: 'E2EFDA',
          border: 1
        });
        
        const valueFormat = xlsx.addFormat({
          border: 1
        });
        
        const titleFormat = xlsx.addFormat({
          bold: true,
          font_size: 14,
          font_color: '217346'
        });
        
        // ========== SHEET 1: Information ==========
        xlsx.write(0, 0, 'Dataset Information', titleFormat, 'Information');
        xlsx.write(2, 0, 'Property', headerFormat, 'Information');
        xlsx.write(2, 1, 'Value', headerFormat, 'Information');
        xlsx.setColumn(0, 0, 20, null, {}, 'Information');
        xlsx.setColumn(1, 1, 50, null, {}, 'Information');
        
        let row = 3;
        xlsx.write(row, 0, 'File', labelFormat, 'Information');
        xlsx.write(row, 1, fileKey, valueFormat, 'Information');
        row++;
        
        xlsx.write(row, 0, 'Path', labelFormat, 'Information');
        xlsx.write(row, 1, path, valueFormat, 'Information');
        row++;
        
        xlsx.write(row, 0, 'Type', labelFormat, 'Information');
        xlsx.write(row, 1, String(node.type), valueFormat, 'Information');
        row++;
        
        if (!isGroup && node.dtype) {
          xlsx.write(row, 0, 'Data Type', labelFormat, 'Information');
          xlsx.write(row, 1, formatDataType(node.dtype), valueFormat, 'Information');
          row++;
        }
        
        if (node.shape && Array.isArray(node.shape)) {
          xlsx.write(row, 0, 'Shape', labelFormat, 'Information');
          xlsx.write(row, 1, node.shape.join(' √ó '), valueFormat, 'Information');
          row++;
        }
        
        xlsx.write(row, 0, 'Export Date', labelFormat, 'Information');
        xlsx.write(row, 1, new Date().toISOString(), valueFormat, 'Information');
        
        // ========== SHEET 2: Attributes ==========
        const attrs = {};
        if (node.attrs && typeof node.attrs === 'object') {
          for (const attrName in node.attrs) {
            if (!attrName.startsWith('_') && typeof node.attrs[attrName] === 'object') {
              try {
                const attrObj = node.attrs[attrName];
                let attrValue;
                
                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                  attrValue = attrObj.value;
                } else {
                  attrValue = attrObj;
                }
                
                attrs[attrName] = attrValue;
              } catch (e) {
                attrs[attrName] = `(unreadable: ${e.message})`;
              }
            }
          }
        }
        
        xlsx.write(0, 0, 'Attributes', titleFormat, 'Attributes');
        xlsx.write(2, 0, 'Name', headerFormat, 'Attributes');
        xlsx.write(2, 1, 'Value', headerFormat, 'Attributes');
        xlsx.setColumn(0, 0, 25, null, {}, 'Attributes');
        xlsx.setColumn(1, 1, 60, null, {}, 'Attributes');
        
        row = 3;
        for (const [key, value] of Object.entries(attrs)) {
          let displayValue;
          if (typeof value === 'string') {
            displayValue = value;
          } else if (Array.isArray(value)) {
            displayValue = `[${value.join(', ')}]`;
          } else if (value === null || value === undefined) {
            displayValue = String(value);
          } else if (typeof value === 'object') {
            if (value.length !== undefined) {
              displayValue = `[${Array.from(value).join(', ')}]`;
            } else {
              displayValue = JSON.stringify(value);
            }
          } else if (typeof value === 'bigint') {
            displayValue = value.toString();
          } else {
            displayValue = String(value);
          }
          
          xlsx.write(row, 0, key, labelFormat, 'Attributes');
          xlsx.write(row, 1, displayValue, valueFormat, 'Attributes');
          row++;
        }
        
        if (Object.keys(attrs).length === 0) {
          xlsx.write(3, 0, '(No attributes)', valueFormat, 'Attributes');
        }
        
        // ========== SHEET 3: Data ==========
        if (!isGroup) {
          let data;
          try {
            if (typeof node.value !== 'undefined') {
              data = node.value;
            } else if (typeof node.toArray === 'function') {
              data = node.toArray();
            }
          } catch (e) {
            console.warn('Could not read data:', e);
          }
          
          if (data !== undefined) {
            let fullData;
            if (Array.isArray(data)) {
              fullData = data;
            } else if (data && typeof data === 'object' && data.length !== undefined) {
              fullData = Array.from(data);
            } else {
              fullData = [data];
            }
            
            xlsx.write(0, 0, 'Data', titleFormat, 'Data');
            
            // Check for index attribute (column headers)
            let headerRow = null;
            try {
              if (node.attrs && node.attrs['index']) {
                const indexAttr = node.attrs['index'];
                const indexValue = indexAttr.value !== undefined ? indexAttr.value : indexAttr;
                if (Array.isArray(indexValue)) {
                  headerRow = indexValue;
                } else if (indexValue && indexValue.length !== undefined) {
                  headerRow = Array.from(indexValue);
                }
              }
            } catch (e) {
              console.warn('Could not read index attribute:', e);
            }
            
            // Try to get time data for time-series datasets
            let timeData = null;
            let timeUnit = '';
            try {
              timeData = getTimeData(file);
              timeUnit = getTimeUnit(file);
            } catch (e) {
              console.warn('Could not read time data:', e);
            }
            
            const shape = node.shape || [];
            
            if (shape.length <= 1) {
              // 1D array - single column (possibly with time column)
              const hasTimeColumn = timeData && timeData.length === fullData.length;
              const colOffset = hasTimeColumn ? 1 : 0;
              
              // Write time header if available
              if (hasTimeColumn) {
                const timeHeader = timeUnit ? `Time (${timeUnit})` : 'Time';
                xlsx.write(2, 0, timeHeader, headerFormat, 'Data');
                xlsx.setColumn(0, 0, 15, null, {}, 'Data');
              }
              
              // Write data header
              if (headerRow && headerRow.length === 1) {
                xlsx.write(2, colOffset, headerRow[0], headerFormat, 'Data');
              } else {
                xlsx.write(2, colOffset, 'Value', headerFormat, 'Data');
              }
              
              // Write data (with time if available)
              for (let i = 0; i < fullData.length; i++) {
                if (hasTimeColumn) {
                  xlsx.write(3 + i, 0, timeData[i], null, 'Data');
                }
                const val = fullData[i];
                xlsx.write(3 + i, colOffset, typeof val === 'number' ? val : String(val), null, 'Data');
              }
              
              xlsx.setColumn(colOffset, colOffset, 15, null, {}, 'Data');
              
            } else if (shape.length === 2) {
              // 2D array (possibly with time column)
              const numRows = shape[0];
              const numCols = shape[1];
              const hasTimeColumn = timeData && timeData.length === numRows;
              const colOffset = hasTimeColumn ? 1 : 0;
              
              // Write time header if available
              if (hasTimeColumn) {
                const timeHeader = timeUnit ? `Time (${timeUnit})` : 'Time';
                xlsx.write(2, 0, timeHeader, headerFormat, 'Data');
              }
              
              // Write headers
              if (headerRow && headerRow.length === numCols) {
                for (let j = 0; j < numCols; j++) {
                  xlsx.write(2, j + colOffset, String(headerRow[j]), headerFormat, 'Data');
                }
              } else {
                for (let j = 0; j < numCols; j++) {
                  xlsx.write(2, j + colOffset, `Col ${j + 1}`, headerFormat, 'Data');
                }
              }
              
              // Write data (with time if available)
              for (let i = 0; i < numRows; i++) {
                if (hasTimeColumn) {
                  xlsx.write(3 + i, 0, timeData[i], null, 'Data');
                }
                for (let j = 0; j < numCols; j++) {
                  const val = fullData[i * numCols + j];
                  xlsx.write(3 + i, j + colOffset, typeof val === 'number' ? val : String(val), null, 'Data');
                }
              }
              
              // Set column widths
              if (hasTimeColumn) {
                xlsx.setColumn(0, 0, 15, null, {}, 'Data');
              }
              for (let j = 0; j < numCols; j++) {
                xlsx.setColumn(j + colOffset, j + colOffset, 12, null, {}, 'Data');
              }
              
            } else {
              // Higher dimensional - flatten with index attribute hints (possibly with time column)
              const numCols = headerRow ? headerRow.length : (shape[shape.length - 1] || 1);
              const numRows = Math.floor(fullData.length / numCols);
              const hasTimeColumn = timeData && timeData.length === numRows;
              const colOffset = hasTimeColumn ? 1 : 0;
              
              // Write time header if available
              if (hasTimeColumn) {
                const timeHeader = timeUnit ? `Time (${timeUnit})` : 'Time';
                xlsx.write(2, 0, timeHeader, headerFormat, 'Data');
              }
              
              // Write headers
              if (headerRow) {
                for (let j = 0; j < headerRow.length; j++) {
                  xlsx.write(2, j + colOffset, String(headerRow[j]), headerFormat, 'Data');
                }
              } else {
                for (let j = 0; j < numCols; j++) {
                  xlsx.write(2, j + colOffset, `Col ${j + 1}`, headerFormat, 'Data');
                }
              }
              
              // Write data (with time if available)
              for (let i = 0; i < numRows; i++) {
                if (hasTimeColumn) {
                  xlsx.write(3 + i, 0, timeData[i], null, 'Data');
                }
                for (let j = 0; j < numCols; j++) {
                  const idx = i * numCols + j;
                  if (idx < fullData.length) {
                    const val = fullData[idx];
                    xlsx.write(3 + i, j + colOffset, typeof val === 'number' ? val : String(val), null, 'Data');
                  }
                }
              }
              
              // Set column widths
              if (hasTimeColumn) {
                xlsx.setColumn(0, 0, 15, null, {}, 'Data');
              }
              for (let j = 0; j < numCols; j++) {
                xlsx.setColumn(j + colOffset, j + colOffset, 12, null, {}, 'Data');
              }
            }
          }
        }
        
        // Save and download
        const content = await xlsx.save();
        
        // Browser download
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${safeFileName}${safePath}.xlsx`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
      } catch (e) {
        console.error('Error creating Excel file:', e);
        alert('Error creating Excel file: ' + e.message);
      }
    }

    /**
     * Build HTML table for node attributes
     * @param {Object} attrs - Attributes object
     * @param {Function} jsonReplacer - JSON replacer for BigInt etc.
     * @returns {string} HTML string for attributes section
     */
    function buildAttributesTable(attrs, jsonReplacer) {
      let attrsHtml = '<table style="width:100%; border-collapse: collapse; font-family: monospace; font-size: 11px;">';
      attrsHtml += '<tr style="border-bottom: 1px solid #e5e7eb; background: #f3f4f6;"><th style="text-align: left; padding: 6px; font-weight: 600;">Name</th><th style="text-align: left; padding: 6px; font-weight: 600;">Value</th></tr>';
      
      for (const [key, value] of Object.entries(attrs)) {
        let displayValue;
        if (typeof value === 'string') {
          displayValue = value;
        } else if (Array.isArray(value)) {
          displayValue = `[${value.join(', ')}]`;
        } else if (value === null) {
          displayValue = 'null';
        } else if (value === undefined) {
          displayValue = 'undefined';
        } else if (typeof value === 'object') {
          if (value.length !== undefined) {
            displayValue = `[${Array.from(value).slice(0, 10).join(', ')}${value.length > 10 ? '...' : ''}]`;
          } else {
            displayValue = JSON.stringify(value, jsonReplacer, 0);
          }
        } else if (typeof value === 'bigint') {
          displayValue = value.toString() + 'n';
        } else {
          displayValue = String(value);
        }
        
        attrsHtml += `<tr style="border-bottom: 1px solid #f0f0f0;">
          <td style="padding: 6px; word-break: break-word; max-width: 150px;"><strong>${escapeHtml(key)}</strong></td>
          <td style="padding: 6px; word-break: break-word; color: #555;">${escapeHtml(displayValue)}</td>
        </tr>`;
      }
      
      attrsHtml += '</table>';
      return `<div class="info-section">
        <div class="info-label">Attributes (${Object.keys(attrs).length})</div>
        <div class="info-content" style="padding: 0; overflow-x: auto;">${attrsHtml}</div>
      </div>`;
    }

    /**
     * Display information for multiple selected datasets
     * @param {Array<string>} paths - Array of selected dataset paths
     */
    function showMultipleDatasetAttributes(paths) {
      const infoDiv = document.getElementById('info');
      infoDiv.innerHTML = `<div class="loading">Loading ${paths.length} datasets...</div>`;
      
      const enabledFiles = getEnabledFiles();
      if (enabledFiles.length === 0) return;
      
      let html = `<div style="background: var(--color-kvot-bright); padding: 12px; border-radius: 6px; margin-bottom: 16px; font-weight: 600; color: var(--color-kvot-background);">
        üìä ${paths.length} datasets selected
      </div>`;
      
      let allTimeDependent = true;
      
      for (const path of paths) {
        html += `<div class="file-data-section" style="border-left-color: var(--color-kvot-accent);">`;
        html += `<h4>${escapeHtml(path)}</h4>`;
        
        const file = loadedFiles[enabledFiles[0]];
        try {
          const dataset = file.get(path);
          if (!dataset) continue;
          
          const isTimeDep = isTimeDependent(dataset);
          if (!isTimeDep) allTimeDependent = false;
          
          html += `<div class="info-section">
            <div class="info-label">Type</div>
            <div class="info-content">${escapeHtml(String(dataset.type))} ${isTimeDep ? '‚è±Ô∏è (time-dependent)' : ''}</div>
          </div>`;
          
          if (dataset.dtype) {
            const readableDtype = formatDataType(dataset.dtype);
            html += `<div class="info-section">
              <div class="info-label">Data Type</div>
              <div class="info-content">${escapeHtml(readableDtype)}</div>
            </div>`;
          }
          
          if (dataset.shape && Array.isArray(dataset.shape)) {
            html += `<div class="info-section">
              <div class="info-label">Shape</div>
              <div class="info-content">${dataset.shape.join(', ')}</div>
            </div>`;
          }
          
          // Show key attributes
          const attrs = {};
          if (dataset.attrs && typeof dataset.attrs === 'object') {
            for (const attrName in dataset.attrs) {
              if (!attrName.startsWith('_') && typeof dataset.attrs[attrName] === 'object') {
                const attrObj = dataset.attrs[attrName];
                attrs[attrName] = attrObj?.value ?? attrObj;
              }
            }
          }
          
          if (Object.keys(attrs).length > 0) {
            html += `<div class="info-section">
              <div class="info-label">Key Attributes</div>
              <div class="info-content" style="font-size: 11px;">`;
            
            for (const [key, value] of Object.entries(attrs).slice(0, 5)) {
              let displayValue = String(value);
              if (displayValue.length > 50) {
                displayValue = displayValue.substring(0, 50) + '...';
              }
              html += `<strong>${escapeHtml(key)}:</strong> ${escapeHtml(displayValue)}<br>`;
            }
            
            html += `</div></div>`;
          }
          
          // Add Excel download button for this dataset
          const escapedPath = path.replace(/'/g, "\\'");
          const escapedFileKey = enabledFiles[0].replace(/'/g, "\\'");
          html += `<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--color-border);">
            <button onclick="downloadDatasetAsExcel('${escapedPath}', '${escapedFileKey}')" 
              style="padding: 6px 12px; background: #217346; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500; transition: all 0.2s;"
              onmouseover="this.style.background='#1e6b3f'" 
              onmouseout="this.style.background='#217346'"
              title="Download this dataset to Excel">
              üìä Download Excel
            </button>
          </div>`;
          
        } catch (e) {
          html += `<div class="error">Error loading dataset: ${escapeHtml(e.message)}</div>`;
        }
        
        html += `</div>`;
      }
      
      infoDiv.innerHTML = html;
      
      // Create combined chart if all are time-dependent
      if (allTimeDependent && paths.length > 0) {
        createMultiDatasetChart(paths);
      } else {
        document.getElementById('plotlyChartContainer').classList.remove('visible');
        currentChartData = null;
      }
    }


    /* ==========================================================================
       12. SEARCH FUNCTIONALITY
       ========================================================================== */

    /**
     * Convert wildcard pattern to regular expression
     * @param {string} pattern - Wildcard pattern (supports *)
     * @returns {RegExp} Compiled regular expression
     */
    function wildcardToRegex(pattern) {
      const escaped = pattern.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
      const regexPattern = escaped.replace(/\*/g, '.*');
      return new RegExp(regexPattern, 'i');
    }

    /**
     * Highlight matching text in a string
     * @param {string} text - Original text
     * @param {string} searchTerm - Search term to highlight
     * @returns {string} HTML with highlighted matches
     */
    function highlightText(text, searchTerm) {
      if (!searchTerm) return escapeHtml(text);
      
      const regex = wildcardToRegex(searchTerm);
      const match = text.match(regex);
      
      if (!match) return escapeHtml(text);
      
      const matchStart = match.index;
      const matchEnd = matchStart + match[0].length;
      
      const before = escapeHtml(text.substring(0, matchStart));
      const matched = escapeHtml(text.substring(matchStart, matchEnd));
      const after = escapeHtml(text.substring(matchEnd));
      
      return `${before}<span class="search-highlight">${matched}</span>${after}`;
    }

    /**
     * Filter tree view based on search term
     * Shows matching items and their parents, hides non-matching items
     * @param {string} searchTerm - Search term (supports wildcards)
     */
    function filterTree(searchTerm) {
      currentSearchTerm = searchTerm;
      const tree = document.getElementById('tree');
      const allItems = tree.querySelectorAll('.tree-item');
      const allChildren = tree.querySelectorAll('.tree-group-children');
      
      // Clear search - show everything, remove highlights
      if (!searchTerm.trim()) {
        allItems.forEach(item => {
          item.classList.remove('search-hidden', 'search-match');
          const label = item.querySelector('.tree-label');
          if (label) {
            const originalText = label.textContent;
            label.innerHTML = escapeHtml(originalText);
          }
        });
        
        allChildren.forEach(child => {
          child.classList.remove('search-expanded');
          const parentGroup = child.previousElementSibling;
          if (parentGroup && parentGroup.classList.contains('expanded')) {
            child.classList.add('expanded');
          } else {
            child.classList.remove('expanded');
          }
        });
        
        return;
      }
      
      const regex = wildcardToRegex(searchTerm);
      const matchingItems = new Set();
      const itemsToShow = new Set();
      
      // First pass: find all matching items
      allItems.forEach(item => {
        const label = item.querySelector('.tree-label');
        if (!label) return;
        
        const text = label.textContent;
        const matches = regex.test(text);
        
        if (matches) {
          matchingItems.add(item);
          item.classList.add('search-match');
          label.innerHTML = highlightText(text, searchTerm);
        } else {
          item.classList.remove('search-match');
          label.innerHTML = escapeHtml(text);
        }
      });
      
      // Second pass: build set of items to show (matches + their parents)
      matchingItems.forEach(item => {
        itemsToShow.add(item);
        
        let current = item;
        while (current) {
          const parentChildren = current.closest('.tree-group-children');
          if (parentChildren) {
            const parentGroup = parentChildren.previousElementSibling;
            if (parentGroup && parentGroup.classList.contains('tree-item')) {
              itemsToShow.add(parentGroup);
              current = parentGroup;
            } else {
              break;
            }
          } else {
            break;
          }
        }
      });
      
      // Third pass: hide non-matching items, show matching items and parents
      allItems.forEach(item => {
        if (itemsToShow.has(item)) {
          item.classList.remove('search-hidden');
        } else {
          item.classList.add('search-hidden');
        }
      });
      
      // Fourth pass: expand parent groups of matches
      allChildren.forEach(child => {
        const parentGroup = child.previousElementSibling;
        if (parentGroup && itemsToShow.has(parentGroup)) {
          child.classList.add('search-expanded');
          if (parentGroup) {
            const toggle = parentGroup.querySelector('.tree-toggle');
            if (toggle) {
              toggle.classList.remove('collapsed');
            }
            parentGroup.classList.add('expanded');
          }
        } else if (!child.classList.contains('expanded')) {
          child.classList.remove('search-expanded');
        }
      });
    }


    /* ==========================================================================
       13. DRAG & DROP FILE LOADING
       ========================================================================== */

    /**
     * Prevent default browser behavior for drag events.
     * Required to enable custom drop handling for HDF5 files.
     * 
     * @param {Event} e - Drag event to prevent
     * @returns {void}
     */
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    /*
     * Drag & Drop Event Registration
     * 
     * Uses a dragCounter to track nested drag enter/leave events,
     * ensuring the overlay is only hidden when the drag truly leaves
     * the document (not just moving between child elements).
     */
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    document.body.addEventListener('dragenter', (e) => {
      dragCounter++;
      document.getElementById('dropOverlay').classList.add('active');
    });

    document.body.addEventListener('dragleave', (e) => {
      dragCounter--;
      if (dragCounter === 0) {
        document.getElementById('dropOverlay').classList.remove('active');
      }
    });

    document.body.addEventListener('drop', (e) => {
      dragCounter = 0;
      document.getElementById('dropOverlay').classList.remove('active');
      
      const dt = e.dataTransfer;
      const files = dt.files;
      if (files.length > 0) {
        document.getElementById('fileInput').files = files;
        const event = new Event('change', { bubbles: true });
        document.getElementById('fileInput').dispatchEvent(event);
      }
    });


    /* ==========================================================================
       14. CLIPBOARD & EXPORT
       ========================================================================== */
    
    /**
     * Copy the current chart to clipboard as a PNG image.
     * Uses the Clipboard API with ClipboardItem for image data.
     * Falls back to file download if clipboard access is denied or unavailable.
     * 
     * The exported image is rendered at 2x scale (1200x800 at scale 2)
     * for high-quality output suitable for documents and presentations.
     * 
     * @returns {Promise<void>}
     */
    async function copyChartToClipboard() {
      if (!currentChartData) {
        alert('No chart available to copy');
        return;
      }
      
      const plotDiv = document.getElementById('plotlyChart');
      const btn = event.target;
      const originalText = btn.textContent;
      
      try {
        // Check clipboard API availability
        if (!navigator.clipboard || !navigator.clipboard.write) {
          throw new Error('Clipboard API not supported');
        }
        
        // Try to request permission if needed
        try {
          const permissionStatus = await navigator.permissions.query({ name: 'clipboard-write' });
          if (permissionStatus.state === 'denied') {
            throw new Error('Clipboard permission denied');
          }
        } catch (permErr) {
          console.log('Permission query not supported, attempting clipboard write anyway');
        }
        
        // Convert chart to PNG
        const dataUrl = await Plotly.toImage(plotDiv, {
          format: 'png',
          width: 1200,
          height: 800,
          scale: 2
        });
        
        const blob = await fetch(dataUrl).then(r => r.blob());
        
        // Write to clipboard
        await navigator.clipboard.write([
          new ClipboardItem({
            'image/png': blob
          })
        ]);
        
        // Show success feedback
        btn.textContent = '‚úì Copied!';
        btn.style.background = 'var(--color-kvot-accent)';
        
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.background = '';
        }, 2000);
        
      } catch (err) {
        console.error('Clipboard copy failed:', err);
        
        // Fallback to download
        try {
          const dataUrl = await Plotly.toImage(plotDiv, {
            format: 'png',
            width: 1200,
            height: 800,
            scale: 2
          });
          
          const link = document.createElement('a');
          link.href = dataUrl;
          link.download = `chart_${Date.now()}.png`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          // Show download feedback
          btn.textContent = '‚¨á Downloaded';
          btn.style.background = 'var(--color-kvot-accent)';
          
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
          }, 2000);
          
          if (err.message.includes('denied') || err.message.includes('permission')) {
            alert('Clipboard access was denied. The chart has been downloaded instead.');
          }
        } catch (downloadErr) {
          console.error('Download also failed:', downloadErr);
          alert('Failed to copy or download chart: ' + downloadErr.message);
        }
      }
    }


    /* ==========================================================================
       15. EVENT LISTENERS & INITIALIZATION
       ========================================================================== */
    
    /*
     * Application Initialization
     * 
     * The following code runs immediately when the script loads:
     * 1. Initialize DOM element cache for performance
     * 2. Register event handlers for file input, search, resize, etc.
     * 3. Set up keyboard shortcuts and accessibility features
     */
    
    // Initialize cached DOM element references
    initDOMReferences();
    
    /**
     * File input change handler.
     * Processes selected HDF5 files, loads them via h5wasm,
     * and adds them to the file tabs for viewing.
     * 
     * @listens change
     */
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const files = Array.from(e.target.files || []);
      if (files.length === 0) return;
      
      try {
        await waitForH5Wasm();
        
        for (const file of files) {
          try {
            const buffer = await file.arrayBuffer();
            
            const { FS, File } = window.h5wasm;
            if (!FS || !File) throw new Error('h5wasm not ready');
            
            const filename = `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.h5`;
            const data = new Uint8Array(buffer);
            
            FS.writeFile('/' + filename, data);
            const hf = new File('/' + filename, 'r');
            
            loadedFiles[file.name] = hf;
            fileStates[file.name] = true;
            if (!fileOrder.includes(file.name)) {
              fileOrder.push(file.name);
            }
          } catch (err) {
            console.error(`Error loading ${file.name}:`, err);
            alert(`Failed to load ${file.name}`);
          }
        }
        
        updateTabs();
        await refreshTreeStructure();
      } catch (err) {
        alert(`Error: ${err.message}`);
        console.error(err);
      }
      
      e.target.value = '';
    });

    /**
     * Search input handler with 200ms debouncing.
     * Filters the tree view to show only matching items.
     * Shows/hides the clear button based on input state.
     * 
     * @listens input
     */
    document.getElementById('treeSearch').addEventListener('input', (e) => {
      const searchTerm = e.target.value;
      const clearBtn = document.getElementById('clearSearch');
      
      if (searchTerm) {
        clearBtn.classList.add('visible');
      } else {
        clearBtn.classList.remove('visible');
      }
      
      // Debounce the search
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }
      
      searchTimeout = setTimeout(() => {
        filterTree(searchTerm);
      }, 200);
    });

    /**
     * Clear search button handler.
     * Resets search input, removes filter, and refocuses the input.
     * 
     * @listens click
     */
    document.getElementById('clearSearch').addEventListener('click', () => {
      const searchInput = document.getElementById('treeSearch');
      searchInput.value = '';
      document.getElementById('clearSearch').classList.remove('visible');
      filterTree('');
      searchInput.focus();
    });

    /**
     * Keyboard shortcut: Escape key clears the search input.
     * Provides quick way to reset the tree filter.
     * 
     * @listens keydown
     */
    document.getElementById('treeSearch').addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.getElementById('clearSearch').click();
      }
    });

    /**
    /**
     * Decorator: Re-apply search filter after tree structure refresh.
     * Ensures that if the user has an active search term, it persists
     * when the tree is rebuilt (e.g., after file reordering).
     */
    const originalRefreshTreeStructure = refreshTreeStructure;
    refreshTreeStructure = async function() {
      await originalRefreshTreeStructure();
      const searchTerm = document.getElementById('treeSearch').value;
      if (searchTerm) {
        setTimeout(() => filterTree(searchTerm), 50);
      }
    };

    /**
     * Responsive chart resizing using ResizeObserver.
     * Automatically resizes the Plotly chart when its container changes size.
     * Debounced to 100ms to prevent excessive resize operations.
     */
    const plotlyChart = document.getElementById('plotlyChart');
    let resizeTimeout;
    const resizeObserver = new ResizeObserver(entries => {
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = setTimeout(() => {
        for (const entry of entries) {
          if (entry.target === plotlyChart && plotlyChart.data) {
            Plotly.Plots.resize(plotlyChart);
          }
        }
      }, 100);
    });
    
    if (plotlyChart) {
      resizeObserver.observe(plotlyChart);
    }
  </script>

  <script>
    // Panel resize handle
    (function() {
      const handle = document.getElementById('resizeHandle');
      const leftPanel = document.getElementById('leftPanel');
      const container = leftPanel.parentElement;
      let startX, startWidth;

      handle.addEventListener('mousedown', function(e) {
        e.preventDefault();
        e.stopPropagation();
        startX = e.clientX;
        startWidth = leftPanel.getBoundingClientRect().width;
        handle.classList.add('active');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        // Block pointer events on everything else during drag
        container.style.pointerEvents = 'none';
        handle.style.pointerEvents = 'auto';

        function onMouseMove(e) {
          e.preventDefault();
          const dx = e.clientX - startX;
          const maxW = container.getBoundingClientRect().width * 0.6;
          const newWidth = Math.max(150, Math.min(startWidth + dx, maxW));
          leftPanel.style.flex = '0 0 ' + newWidth + 'px';
        }

        function onMouseUp() {
          handle.classList.remove('active');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          container.style.pointerEvents = '';
          handle.style.pointerEvents = '';
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          window.dispatchEvent(new Event('resize'));
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
    })();
  </script>
</body>
</html>