<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="icon" type="image/png" sizes="16x16" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB8lBMVEUARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARHUARHUARHUARHUCRncUVIETU4AIS3oTU4ABRXYARHYANGlBdJkhXYi/0NypwNE8cZbC095OfqAAM2kAK2Ohus1Ug6Pf6O6OrcI2bJPr8fSzx9YAOGyguswpY4zf5+5XhKQyaZHs8fWctsoANWoAMmg/c5gsZY62ythKe57p7/NMfZ8AMGcAPG86b5VZhqbj6/Bah6br8PStw9MAN2sAKmKatslVg6Pg6O7k6/CpwNEANGo0a5IeW4aqwdGswtJEd5uwxtUvaJAAN2wDRncBRXYJS3sJS3sESHgJTHsARXYARXYARHUARHUARXYARXYARHUARHUARXYARHUARHUARXYARXYARHYARHUNTn0VVIEGSHgRUX8LTHsWVYIQUX+8ztvW4emBo7ulvc6MqsHX4enF1eDw9Pe9ztvf6O7g6O7k6/DI1+Hi6u/y9vh8oLlGeJz////6+/y+z9zX4urJ1+Katsn6/Pz4+vve5+1tlbGmvs/r8fTP3OW0yNbz9vjN2+Tn7fLI1uHX4unp7/Otw9PE1N96nreXs8eOrcLG1eCov9AHSnkKTHsISnoHSnoLTXwHSXlgx+EhAAAAanRSTlMLYnd2Um5xUXUZ0/6w7vOv/NSx/e7z/dSx7vOw/dQZGdSx7vOw/dQZGdSx7vOw/dQZ1LHu87D91BkZ1LHzsP3UGRnUsfOw/dQZGdSx7vPUGdSx7vOw/dQZ/rDu87D8DGR6eXpUcHRTd3tlDK+lHQAAAAFiS0dEhRXXaucAAAAHdElNRQfmCB4IBCY0DSgTAAAA8klEQVQY02NgYGRiZmZhZWZmY+dgZmJkYODkyuLm5uHNyuLjF+DO4uJk4BTMysoSAgnwCGdlCRInkJ2TJSSSky3KI5aTAxIQz83Ll5AsKJSSlikqlpVjkFcoKS1TVCqvUFZRraxSU2fQ0KyuqdXSrqvX0dVraNQ3YNAwbGpuMTJubTMxNWvvMLdgsLTqrO6yNu7usbG1a+q1d2BwdOrrn+CsPbHKxdVtUqm7B4On1+QpU719ptX4utpNn+FnweAfMHPW7MCgOXODQ0LnzQ8LB7pjwcKIyKhFi6NjYpcsFedkiItPSExKTklMSE1LT8zIjAMAkOZIz65wIlsAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjItMDgtMzBUMDg6MDQ6MzgrMDA6MDCWf9PgAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIyLTA4LTMwVDA4OjA0OjM4KzAwOjAw5yJrXAAAAFd6VFh0UmF3IHByb2ZpbGUgdHlwZSBpcHRjAAB4nOPyDAhxVigoyk/LzEnlUgADIwsuYwsTIxNLkxQDEyBEgDTDZAMjs1Qgy9jUyMTMxBzEB8uASKBKLgDqFxF08kI1lQAAAABJRU5ErkJggg=="/>
  <link rel="mask-icon" type="image/svg" href="data:image/svg;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iNzg0LjAwMDAwMHB0IiBoZWlnaHQ9Ijc4NC4wMDAwMDBwdCIgdmlld0JveD0iMCAwIDc4NC4wMDAwMDAgNzg0LjAwMDAwMCIKIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiPgo8bWV0YWRhdGE+CkNyZWF0ZWQgYnkgcG90cmFjZSAxLjE0LCB3cml0dGVuIGJ5IFBldGVyIFNlbGluZ2VyIDIwMDEtMjAxNwo8L21ldGFkYXRhPgo8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCw3ODQuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApIgpmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiPgo8cGF0aCBkPSJNNTMwIDM5MTUgbDAgLTM2MjUgMTA3NSAwIDEwNzUgMCAwIDM2MjUgMCAzNjI1IC0xMDc1IDAgLTEwNzUgMCAwCi0zNjI1eiBtMTczNCAyMDkgbDIzNiAtMjQ3IDAgLTI2OCAwIC0yNjkgLTM4MCAwIC0zODAgMCAtMiAyMTggLTMgMjE3IC0xMDcgMwotMTA4IDMgMCAtMzQ1IDAgLTM0NiAyMyAtNSBjMTIgLTMgMTIzIC0yNiAyNDcgLTUwIGwyMjUgLTQ1IDIzOCAtMjM4IDIzNwotMjM3IDAgLTUxMCAwIC01MTEgLTIwOCAtMjA3IC0yMDkgLTIwNyAtNDgwIDAgLTQ3OSAwIC0xOTcgMjI0IC0xOTcgMjI0IDAKMzAxIDAgMzAxIDM5OCAtMiAzOTcgLTMgMyAtMjI3IDIgLTIyOCAxMDUgMCAxMDUgMCAwIDMzNCBjMCAzMTAgLTEgMzM1IC0xNwozNDAgLTEwIDMgLTEyOCAyNiAtMjYzIDUxIC0xMzUgMjUgLTI1MiA0OSAtMjYxIDUzIC04IDQgLTExOCAxMTEgLTI0MiAyMzkKbC0yMjcgMjMyIDAgNTI0IDAgNTIzIDIzOCAyMDEgMjM3IDIwMiA0MTcgMCA0MTcgMSAyMzUgLTI0NnoiLz4KPHBhdGggZD0iTTYxODAgMzM5NSBsMCAtMzc1IDEyMCAwIDEyMCAwIC0yIDM3MyAtMyAzNzIgLTExNyAzIC0xMTggMyAwIC0zNzZ6Ii8+CjxwYXRoIGQ9Ik02MTgwIDIwODUgbDAgLTM3NiAxMTggMyAxMTcgMyAzIDM3MyAyIDM3MiAtMTIwIDAgLTEyMCAwIDAgLTM3NXoiLz4KPC9nPgo8L3N2Zz4K" color="#5bbad5">
  <title>HDF5 File Viewer</title>
  <link href="https://unpkg.com/leaflet@1.9.2/dist/leaflet.css" rel="stylesheet">
  <script src="https://unpkg.com/leaflet@1.9.2/dist/leaflet.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="resources/js/xlsxwrite.js"></script>
  <script>
    // xlsxwrite.js is ready immediately after loading (no WASM initialization needed)
    window.xlsxReady = true;
    console.log('xlsxwrite.js loaded');
  </script>
  <link rel="stylesheet" href="./resources/css/kvot.css">
  <link rel="stylesheet" href="./resources/css/rb.css">
</head>
<body>
  <div id="dropOverlay">
    <div class="message">üìÅ Drop HDF5 files here</div>
  </div>
  
  <header></header>

  <input id="fileInput" type="file" accept=".h5,.hdf5,.he5" multiple />

  <div class="container">
    <div class="panel" id="leftPanel">
      <div class="panel-heading">
        <h3>File Structure</h3>
        <label id="intersectLabel" class="intersect-checkbox" style="display: none;" title="Show only nodes whose full path exists in ALL enabled files">
          <input type="checkbox" id="intersectCheckbox" onchange="toggleIntersect()">
          Intersect Data
        </label>
      </div>
      <div class="search-container">
        <input 
          type="text" 
          id="treeSearch" 
          placeholder="Search tree (use * for wildcard)..." 
          autocomplete="off"
        />
        <button id="clearSearch" class="clear-search-btn" title="Clear search">√ó</button>
      </div>
      <div id="tree" class="loading">Drop HDF5 files or click "+ Add Files" to start...</div>
    </div>

    <div class="resize-handle" id="resizeHandle"></div>

    <div class="panel">
      <div class="right-panel-content">
        <div id="plotlyChartContainer">
          <h3>Chart</h3>
          <div class="chart-controls">
            <label>
              X-axis:
              <select id="xAxisScale" onchange="updateChartScales()">
                <option value="linear">Linear</option>
                <option value="log">Log</option>
              </select>
            </label>
            <label>
              Y-axis:
              <select id="yAxisScale" onchange="updateChartScales()">
                <option value="linear">Linear</option>
                <option value="log">Log</option>
              </select>
            </label>
            <label >
              <input type="checkbox" id="dynamicLegend" checked onchange="toggleDynamicLegend()">
              Dynamic Legend
            </label>
            <label id="showTotalLabel" style="display: none;">
              <input type="checkbox" id="showTotal" checked onchange="toggleShowTotal()">
              Show Total
            </label>
            <label id="showRatioLabel" style="display: none;">
              <input type="checkbox" id="showRatio" onchange="toggleShowRatio()">
              Show Ratio
            </label>
            <span id="legendStatus" style=" font-size: 12px; color: var(--color-text-muted);"></span>
            <button onclick="applyReleasePresetView()" style="margin-left: auto;">Apply Release View</button>
            <button onclick="applyDosePresetView()">Apply Dose View</button>
          </div>
          <div id="histControls" class="chart-controls" style="display: none;">
            <span style="font-weight: 600; font-size: 13px; display: inline-flex; align-items: center; gap: 4px;">üìä Data preview</span>
            <label id="histLogLabel" style="margin-left: auto;">
              <input type="checkbox" id="histLogScale" onchange="toggleHistLog()">
              Log‚ÇÅ‚ÇÄ scale
            </label>
          </div>
          <div id="plotlyChart"></div>
        </div>
        
        <div>
          <h3>Dataset Information</h3>
            <div class="multi-select-hint" style="display: none;" id="multiSelectHint">
              üí° <strong>Tip:</strong> Hold Ctrl (‚åò on Mac) and click datasets to compare multiple
            </div>
            <div id="info">Select a dataset to view its details</div>
        </div>
      </div>
    </div>
  </div>

  <div id="map"></div>
  <footer></footer>

  <script src="./resources/js/erf.js"></script>
  <script src="./resources/js/site.js"></script>
  <script>
    KVOT.renderHeader('hdf result browser', '<div class="tabs-container"><div id="fileTabs"></div><div id="fileLoadTicker" class="file-load-ticker" aria-live="polite" hidden><span class="spinner" aria-hidden="true"></span><span class="ticker-text">Loading files‚Ä¶</span></div><button class="add-file-btn" onclick="document.getElementById(\'fileInput\').click()">+ Add Files</button></div>');
    KVOT.renderNav('rb.html');
    KVOT.renderFooter();
    KVOT.initMap('map');
  </script>

  <script src="https://cdn.jsdelivr.net/npm/h5wasm@latest/dist/iife/h5wasm.min.js"></script>
  <script src="./resources/js/pdf-sampler.js"></script>
  <script>
    /* ==========================================================================
       HDF5 FILE VIEWER - JAVASCRIPT APPLICATION
       ==========================================================================
       
       Module Organization:
       1. GLOBAL STATE & CONFIGURATION
       2. UTILITY FUNCTIONS
       3. HDF5 DATA ACCESS
       4. FILE MANAGEMENT
       5. TAB MANAGEMENT
       6. TREE VIEW
       7. RADIONUCLIDE LINE STYLES
       8. CHART CONTROLS
       9. CHART CREATION
       10. DYNAMIC LEGEND
       11. DATASET INFORMATION DISPLAY
       12. SEARCH FUNCTIONALITY
       13. DRAG & DROP
       14. CLIPBOARD & EXPORT
       15. EVENT LISTENERS & INITIALIZATION
       
       ========================================================================== */


    /**
     * ==========================================================================
     * HDF5 FILE VIEWER APPLICATION
     * ==========================================================================
     * 
     * A browser-based viewer for HDF5 files with interactive tree navigation,
     * Plotly.js charting, and multi-file comparison capabilities.
     * 
     * @overview
     * - Section 1: Global State & Configuration
     * - Section 2: Utility Functions  
     * - Section 3: HDF5 Data Access
     * - Section 4: File Management
     * - Section 5: Tab Management
     * - Section 6: Tree View
     * - Section 7: Radionuclide Line Styles
     * - Section 8: Chart Controls
     * - Section 9: Chart Creation
     * - Section 10: Dynamic Legend
     * - Section 11: Dataset Information Display
     * - Section 12: Search Functionality
     * - Section 13: Drag & Drop
     * - Section 14: Clipboard & Export
     * - Section 15: Event Listeners & Initialization
     * 
     * @requires h5wasm - WebAssembly-based HDF5 library
     * @requires Plotly.js - Interactive charting library
     * @requires SortableJS - Drag-and-drop sorting library
     * 
     * @author KVOT Development Team
     * @version 2.0.0
     */

    /* ==========================================================================
       1. GLOBAL STATE & CONFIGURATION
       ========================================================================== */
    
    /**
     * @typedef {Object} FileState
     * @property {boolean} enabled - Whether the file is currently enabled for display
     */

    /**
     * @typedef {Object} ChartData
     * @property {Array} traces - Plotly trace data
     * @property {Object} layout - Plotly layout configuration
     * @property {string} path - Dataset path being charted
     */

    /** @type {Object.<string, Object>} Map of filename to HDF5 file objects */
    let loadedFiles = {};
    /** @type {Object.<string, boolean>} Map of filename to enabled/disabled state */
    let fileStates = {};
    /** @type {string[]} Ordered list of filenames (determines tab order) */
    let fileOrder = [];
    
    // Selection state
    /** @type {string|null} Currently selected HDF5 path in the tree view */
    let selectedDatasetPath = null;
    /** @type {boolean} True if the selected path is a radionuclides group (for special charting) */
    let selectedIsRadionuclidesGroup = false;
    /** @type {{path: string, fileKey: string|null}[]} Array of selected datasets in multi-select mode (Ctrl+click) */
    let selectedDatasets = [];
    /** @type {boolean} True when user is selecting multiple datasets with Ctrl/Cmd key */
    let multiSelectMode = false;
    /** @type {string|null} File key of the tree node that was clicked (null = use all enabled files) */
    let selectedFileKey = null;
    
    // Chart state
    /** @type {ChartData|null} Current chart data (traces, layout, path) for export/clipboard */
    let currentChartData = null;
    /** @type {boolean} True when the chart area is showing a PDF histogram (not a time-series chart) */
    let currentPdfHistogram = false;
    /** @type {Object|null} Stored PDF histogram data for re-rendering on theme/log change */
    let currentPdfHistogramData = null;
    /** @type {string|null} Filename of the first enabled file (determines tree structure source) */
    let currentTreeFile = null;
    
    // Dynamic legend state
    /** @type {boolean} When true, legend updates to show only traces visible in current viewport */
    let dynamicLegendEnabled = true;
    
    // Search state
    /** @type {number|null} Timeout ID for debounced search input */
    let searchTimeout = null;
    /** @type {string} Current search/filter term applied to tree view */
    let currentSearchTerm = '';
    
    // Drag & drop state
    /** @type {number} Counter for drag enter/leave events to handle nested elements */
    let dragCounter = 0;


    /* ==========================================================================
       1.1 CONSTANTS
       ========================================================================== */
    
    /**
     * Default placeholder message shown in the info panel when no dataset is selected.
     * @constant {string}
     */
    const INFO_PANEL_DEFAULT_MESSAGE = 'Select a dataset to view its details';
    
    /**
     * Standard legend positioning for Plotly charts.
     * Places legend to the right of the chart area.
     * @constant {Object}
     */
    const CHART_LEGEND_CONFIG = {
      x: 1.02,      // Slightly right of chart area
      y: 1,         // Top aligned
      xanchor: 'left',
      yanchor: 'top'
    };
    
    /**
     * Y-axis exponent display settings for scientific notation.
     * Shows all exponents in power format (e.g., 10^6 instead of 1e6).
     * @constant {Object}
     */
    const CHART_YAXIS_EXPONENT = {
      showexponent: 'all',
      exponentformat: 'power'
    };
    
    /**
     * Chart margins with extra right padding for legend.
     * @constant {Object}
     */
    const CHART_MARGIN_WITH_LEGEND = { t: 10, r: 150,  b: 60 };


    /* ==========================================================================
       1.2 DOM ELEMENT HELPERS
       ========================================================================== */
    
    /**
     * Cached DOM element references (initialized on DOMContentLoaded)
     * @type {Object.<string, HTMLElement>}
     */
    const DOM = {};
    
    /**
     * Initialize cached DOM element references
     * Call once after DOM is ready
     */
    function initDOMReferences() {
      DOM.plotlyChart = document.getElementById('plotlyChart');
      DOM.plotlyChartContainer = document.getElementById('plotlyChartContainer');
      DOM.info = document.getElementById('info');
      DOM.tree = document.getElementById('tree');
      DOM.xAxisScale = document.getElementById('xAxisScale');
      DOM.yAxisScale = document.getElementById('yAxisScale');
      DOM.searchInput = document.getElementById('searchInput');
      DOM.searchResults = document.getElementById('searchResults');
      DOM.tabs = document.getElementById('tabs');
      DOM.showTotal = document.getElementById('showTotal');
      DOM.showTotalContainer = document.getElementById('showTotalContainer');
      DOM.showTotalLabel = document.getElementById('showTotalLabel');
      DOM.showRatio = document.getElementById('showRatio');
      DOM.showRatioLabel = document.getElementById('showRatioLabel');
      DOM.dynamicLegendToggle = document.getElementById('dynamicLegendToggle');
      DOM.dropZone = document.getElementById('dropZone');
      DOM.fileTabs = document.getElementById('fileTabs');
    }
    
    /**
     * Get element by ID (with fallback if DOM cache not initialized)
     * @param {string} id - Element ID
     * @returns {HTMLElement|null}
     */
    function getElement(id) {
      return DOM[id] || document.getElementById(id);
    }
    
    /**
     * Show or hide the "Show Total" checkbox based on context
     * @param {boolean} show - Whether to show the checkbox
     */
    function setShowTotalVisible(show) {
      const label = getElement('showTotalLabel');
      if (label) {
        label.style.display = show ? '' : 'none';
      }
    }

    /**
     * Show or hide the "Show Ratio" checkbox based on context.
     * Only shown when there are exactly two enabled files (thick + thin lines).
     * @param {boolean} show - Whether to show the checkbox
     */
    function setShowRatioVisible(show) {
      const label = getElement('showRatioLabel');
      if (label) {
        label.style.display = show ? '' : 'none';
      }
    }


    /* ==========================================================================
       2. UTILITY FUNCTIONS
       ========================================================================== */
    
    /**
     * Wait for h5wasm library to be loaded and ready
     */
    async function waitForH5Wasm() {
      let attempts = 0;
      while (!window.h5wasm && attempts < 50) {
        await new Promise(r => setTimeout(r, 100));
        attempts++;
      }
      if (!window.h5wasm) throw new Error('h5wasm failed to load');
      if (window.h5wasm.ready instanceof Promise) await window.h5wasm.ready;
      return window.h5wasm;
    }

    // Install a lightweight console filter to reduce noisy h5wasm/HDF5 diagnostic
    // messages that are benign (e.g. "HDF5-DIAG", "Object not found").
    // Disable by setting `window.SUPPRESS_H5WASM_DIAGNOSTICS = false` in the console.
    (function installH5WasmDiagFilter(){
      if (window.SUPPRESS_H5WASM_DIAGNOSTICS === false) return;
      // default to enabled
      window.SUPPRESS_H5WASM_DIAGNOSTICS = true;
      const origError = console.error.bind(console);
      const origWarn = console.warn.bind(console);

      function looksLikeH5Diag(args) {
        try {
          const txt = args.map(a => (typeof a === 'string' ? a : (a && a.message) ? a.message : String(a))).join(' ');
          if (!txt) return false;
          // match the common HDF5 diagnostic signatures we saw in the console
          if (!/HDF5-DIAG|Object not found|minor:\s*Object not found/i.test(txt)) return false;
          // also prefer messages originating from h5wasm (best-effort check)
          return /h5wasm(\.min)?\.js|h5wasm/i.test(txt);
        } catch (e) {
          return false;
        }
      }

      console.error = function(...args) {
        if (looksLikeH5Diag(args)) return;
        origError(...args);
      };
      console.warn = function(...args) {
        if (looksLikeH5Diag(args)) return;
        origWarn(...args);
      };

      try { console.debug('H5Wasm diagnostic filter enabled ‚Äî SUPPRESS_H5WASM_DIAGNOSTICS = true'); } catch(e){}
    })();

    // Small FileService wrapper for h5wasm File objects. Use FileService.get(file, path),
    // FileService.keys(file) and FileService.attrs(node) to access HDF5 content safely.
    window.FileService = {
      get(file, path) {
        try { if (!file) return null; return file.get(path); } catch (e) { if (window.SUPPRESS_H5WASM_DIAGNOSTICS) return null; console.warn('FileService.get error:', e && e.message ? e.message : e, path); return null; }
      },
      keys(file) {
        try { if (!file || typeof file.keys !== 'function') return []; return Array.from(file.keys()).sort(); } catch (e) { return []; }
      },
      attrs(node) {
        const out = {};
        try {
          if (!node || !node.attrs) return out;
          for (const name in node.attrs) {
            try { const a = node.attrs[name]; out[name] = (a && typeof a === 'object' && 'value' in a) ? a.value : a; } catch (err) { out[name] = `(unreadable: ${err.message})`; }
          }
        } catch (e) {}
        return out;
      }
    };



    /**
     * Escape HTML special characters for safe rendering
     */
    function escapeHtml(text) {
      const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
      return String(text).replace(/[&<>"']/g, m => map[m]);
    }
    
    /**
     * Detect if an HDF5 path is a soft link, external link, or broken soft link.
     * @param {Object} group - h5wasm Group or File object
     * @param {string} path - Absolute HDF5 path
     * @param {Object} [obj] - The object returned by group.get(key), if already fetched
     * @returns {Object|null} Link info or null if not a link
     */
    function getLinkInfo(group, path, obj) {
      try {
        // don't treat the root "/" as a link
        if (!path || path === '/') return null;

        // explicit link object types first
        if (obj && String(obj.type) === 'BrokenSoftLink') {
          // normalize target to string when possible
          const t = obj.target;
          const targetStr = (typeof t === 'string') ? t
                            : (t instanceof Uint8Array ? new TextDecoder().decode(t) : (t?.toString?.() ?? '?'));
          return { type: 'broken', target: targetStr };
        }
        if (obj && String(obj.type) === 'ExternalLink') {
          return { type: 'external', filename: obj.filename || '?', obj_path: obj.obj_path || '?' };
        }

        // If the caller already provided `obj` (group.get(name)), avoid calling
        // the potentially noisy `group.get_link()` lookup ‚Äî h5wasm may log
        // "Object not found" for non-link names. Only attempt get_link when
        // `obj` is not available.
        if (!obj && typeof group.get_link === 'function') {
          const localName = String(path).split('/').pop();
          try {
            const softTarget = group.get_link(localName);
            if (softTarget) {
              if (typeof softTarget === 'string') return { type: 'soft', target: softTarget };
              if (softTarget && typeof softTarget === 'object') {
                if (typeof softTarget.target === 'string') return { type: 'soft', target: softTarget.target };
                if (softTarget instanceof Uint8Array) {
                  try { return { type: 'soft', target: new TextDecoder().decode(softTarget) }; } catch (e) {}
                }
              }
            }
          } catch (e) {
            // Swallow internal errors from get_link to avoid noisy console output
          }
        }
      } catch (e) { /* not a link / ignore noisy return values */ }
      return null;
    }
    //   try {
    //     if (obj && String(obj.type) === 'BrokenSoftLink') {
    //       return { type: 'broken', target: obj.target || '?' };
    //     }
    //     if (obj && String(obj.type) === 'ExternalLink') {
    //       return { type: 'external', filename: obj.filename || '?', obj_path: obj.obj_path || '?' };
    //     }
    //     // Check for resolved soft link
    //     const softTarget = group.get_link(path);
    //     if (softTarget) {
    //       return { type: 'soft', target: softTarget };
    //     }
    //   } catch (e) { /* not a link */ }
    //   return null;
    // }

    /**
     * Build a small link badge HTML for the tree view.
     * @param {Object} linkInfo - Link info from getLinkInfo()
     * @returns {string} HTML string for the badge
     */
    function buildLinkBadge(linkInfo) {
      if (!linkInfo) return '';
      let tooltip, cls;
      if (linkInfo.type === 'broken') {
        tooltip = 'Broken link \u2192 ' + linkInfo.target;
        cls = 'broken';
      } else if (linkInfo.type === 'external') {
        tooltip = 'External \u2192 ' + linkInfo.filename + ':' + linkInfo.obj_path;
        cls = 'external';
      } else {
        tooltip = 'Link \u2192 ' + linkInfo.target;
        cls = 'soft';
      }
      return `<span class="link-badge ${cls}" title="${escapeHtml(tooltip)}"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg></span>`;
    }

    /* ==========================================================================
       PDF SAMPLING ENGINE
       Mirrors the Python Distribution class from samp_util.py.
       Supports: uniform, triangular, dtriangular, normal, exponential,
       loguniform, logtriangular, logdtriangular, lognormal, raw/empirical.
       ========================================================================== */




    /* DIST_INV moved to resources/js/pdf-sampler.js (use PDFSampler internally) */

    /**
     * Generate n random samples from a PDF specification object.
     * Mirrors Python's Distribution(pdf).rnd() from samp_util.py.
     *
     * @param {Object} pdf - PDF spec, e.g. {type:'normal', mean:5, std:1}
     * @param {number} [n=1000] - Number of samples
     * @returns {Float64Array|null} Array of samples, or null if type unknown
     */
    /* Generate PDF samples (delegates to PDFSampler) */
    function generatePdfSamples(pdf, n = 1000) { return window.PDFSampler.generatePdfSamples(pdf, n); }

    /**
     * Build a human-readable label for a PDF spec.
     * @param {Object} pdf
     * @returns {string}
     */

    /**
     * Extract histogram entries from a dataset node that has a 'pdf' attribute.
     * Ensures all returned sample arrays and deterministic values are plain Numbers
     * (converts BigInt -> Number) so Plotly / math ops won't throw.
     *
     * @param {Object} node  - HDF5 dataset node
     * @param {Object} attrs - Already-extracted attribute dict (must contain attrs.pdf)
     * @param {string} label - Human-readable label prefix for this dataset
     * @returns {Array|null}
     */
    function collectPdfEntries(node, attrs, label) {
      if (!attrs.pdf) return null;
      try {
        let pdfRaw = attrs.pdf;
        if (typeof pdfRaw === 'string') pdfRaw = JSON.parse(pdfRaw);



        const isLookupTable = Array.isArray(pdfRaw);
        const indexAttr = attrs.index;

        if (isLookupTable && indexAttr) {
          const indexLabels = Array.isArray(indexAttr) ? indexAttr : Array.from(indexAttr);
          const entries = [];
          for (let i = 0; i < pdfRaw.length; i++) {
            const spec = pdfRaw[i];
            if (!spec) {
              try {
                let rawData = typeof node.value !== 'undefined' ? node.value : (typeof node.toArray === 'function' ? node.toArray() : undefined);
                if (rawData !== undefined) {
                  const arr = Array.isArray(rawData) ? rawData : Array.from(rawData);
                  entries.push({ label: label + ' ‚Äì ' + String(indexLabels[i] ?? i), samples: [PDFSampler.toNumber(arr[i])], spec: null, deterministicValue: null });
                }
              } catch (_) {}
              continue;
            }

            if (spec.type && spec.type.toLowerCase() === 'raw') {
              try {
                let rawData = typeof node.value !== 'undefined' ? node.value : (typeof node.toArray === 'function' ? node.toArray() : undefined);
                if (rawData !== undefined) {
                  const flat = Array.isArray(rawData) ? rawData : Array.from(rawData);
                  const nCols = pdfRaw.length, nRows = Math.floor(flat.length / nCols);
                  const shift = spec.include_deterministic ? 1 : 0;
                  const detVal = spec.include_deterministic && nRows > 0 ? PDFSampler.toNumber(flat[0 * nCols + i]) : null;
                  const col = [];
                  for (let r = shift; r < nRows; r++) col.push(PDFSampler.toNumber(flat[r * nCols + i]));
                  entries.push({ label: label + ' ‚Äì ' + String(indexLabels[i] ?? i), samples: col, spec, deterministicValue: detVal });
                }
              } catch (_) {}
            } else {
              let detVal = null;
              try {
                let rawData = typeof node.value !== 'undefined' ? node.value : (typeof node.toArray === 'function' ? node.toArray() : undefined);
                if (rawData !== undefined) {
                  const flat = Array.isArray(rawData) ? rawData : Array.from(rawData);
                  if (flat.length >= pdfRaw.length) detVal = PDFSampler.toNumber(flat[i]);
                }
              } catch (_) {}
              const samples = generatePdfSamples(spec, 1000);
              if (samples) {
                entries.push({ label: label + ' ‚Äì ' + String(indexLabels[i] ?? i), samples: PDFSampler.normalizeDataArray(samples), spec, deterministicValue: isFinite(detVal) ? detVal : null });
              }
            }
          }
          return entries.length > 0 ? entries : null;
        } else if (!isLookupTable && pdfRaw.type) {
          if (pdfRaw.type.toLowerCase() === 'raw') {
            try {
              let rawData = typeof node.value !== 'undefined' ? node.value : (typeof node.toArray === 'function' ? node.toArray() : undefined);
              if (rawData !== undefined) {
                const flat = Array.isArray(rawData) ? rawData : Array.from(rawData);
                const shift = pdfRaw.include_deterministic ? 1 : 0;
                const detVal = pdfRaw.include_deterministic && flat.length > 0 ? PDFSampler.toNumber(flat[0]) : null;
                return [{ label, samples: flat.slice(shift).map(PDFSampler.toNumber), spec: pdfRaw, deterministicValue: detVal }];
              }
            } catch (_) {}
          } else {
            let detVal = null;
            try {
              let rawData = typeof node.value !== 'undefined' ? node.value : (typeof node.toArray === 'function' ? node.toArray() : undefined);
              if (rawData !== undefined) {
                if (typeof rawData === 'number') detVal = rawData;
                else if (rawData && rawData.length !== undefined && rawData.length > 0) detVal = PDFSampler.toNumber(rawData[0]);
              }
            } catch (_) {}
            const samples = generatePdfSamples(pdfRaw, 1000);
            if (samples) {
              return [{ label, samples: Array.from(samples).map(PDFSampler.toNumber), spec: pdfRaw, deterministicValue: isFinite(detVal) ? detVal : null }];
            }
          }
        }
      } catch (e) {
        console.warn('collectPdfEntries error:', e.message);
      }
      return null;
    }

    /**
     * Compute analytical PDF curve points for a given distribution spec.
     * Accounts for truncation (trmin/trmax/pmin/pmax) and shift.
     * @param {Object} spec - PDF specification object
     * @param {number} [nPoints=200] - Number of points to evaluate
     * @returns {{x:number[], y:number[]}|null} Points for the line overlay
     */
    /* Compute PDF overlay (delegates to PDFSampler) */
    function computePdfOverlay(spec, nPoints = 200) { return window.PDFSampler.computePdfOverlay(spec, nPoints); }

    /**
     * Escape value for CSV export (handle commas, quotes, newlines)
     */
    function escapeCSV(value) {
      if (value === null || value === undefined) {
        return '';
      }
      
      const str = String(value);
      
      if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
        return '"' + str.replace(/"/g, '""') + '"';
      }
      
      return str;
    }
    
    /**
     * Format HDF5 data type into human-readable string
     */
    function formatDataType(dtype) {
      if (!dtype) return 'unknown';
      
      let name = '';
      
      if (typeof dtype === 'object' && dtype.name) {
        name = dtype.name;
      } else if (typeof dtype === 'string') {
        name = dtype;
      } else {
        return String(dtype);
      }
      
      const typeMap = {
        'i': 'Integer', 'u': 'Unsigned Integer', 'f': 'Float', 'c': 'Complex',
        'q': 'Integer', 'Q': 'Unsigned Integer',
        'S': 'String (fixed)', 'U': 'Unicode String', 'V': 'Void/Compound',
        'O': 'Object Reference', 'b': 'Boolean', 't': 'Time', 'm': 'Timedelta',
        'M': 'Datetime', 'a': 'Bytes', 'A': 'Any', 'd': 'Float'
      };
      
      name = name.replace(/^[<>|=]/, '');
      
      const match = name.match(/^([a-zA-Z])(\d+)$/);
      if (match) {
        const [, type, bytes] = match;
        const baseType = typeMap[type] || type;
        const bitSize = parseInt(bytes) * 8;
        return `${baseType} (${bitSize}-bit)`;
      }
      
      const singleTypeMatch = name.match(/^([a-zA-Z])$/);
      if (singleTypeMatch) {
        const type = singleTypeMatch[1];
        return typeMap[type] || name;
      }
      
      return name;
    }
    
    /**
     * Check if a value represents a truthy attribute (handles various formats)
     * @param {*} value - The value to check
     * @returns {boolean} True if the value is truthy
     */
    function isTruthyAttribute(value) {
      return value === true || value === 1 || value === 'TRUE' || value === 'True' || value === 'true';
    }
    
    /**
     * Check if a dataset has the 'probabilistic' attribute set to true
     * @param {Object} dataset - HDF5 dataset with attrs
     * @returns {boolean} True if probabilistic
     */
    function checkIsProbabilistic(dataset) {
      if (dataset && dataset.attrs && typeof dataset.attrs === 'object') {
        for (const attrName in dataset.attrs) {
          if (attrName === 'probabilistic') {
            const attrObj = dataset.attrs[attrName];
            if (attrObj && typeof attrObj.value !== 'undefined') {
              return isTruthyAttribute(attrObj.value);
            }
          }
        }
      }
      return false;
    }
    
    /**
     * Compute mean values from probabilistic data array
     * @param {Array} yArray - Raw data array (may contain realizations)
     * @param {Array} timeData - Time data for reference length
     * @returns {Array} Array of mean values per timestep
     */
    function computeProbabilisticMean(yArray, timeData) {
      if (Array.isArray(yArray[0])) {
        // Array of arrays: each timeSlice has multiple realizations
        return yArray.map(timeSlice => {
          if (Array.isArray(timeSlice)) {
            const sum = timeSlice.reduce((a, b) => a + PDFSampler.toNumber(b), 0);
            return sum / timeSlice.length;
          }
          return PDFSampler.toNumber(timeSlice);
        });
      } else if (yArray.length > timeData.length && yArray.length % timeData.length === 0) {
        // Flat array: realizations interleaved or sequential
        const numRealizations = Math.floor(yArray.length / timeData.length);
        const means = [];
        for (let t = 0; t < timeData.length; t++) {
          let sum = 0;
          for (let r = 0; r < numRealizations; r++) {
            sum += PDFSampler.toNumber(yArray[t * numRealizations + r]);
          }
          means.push(sum / numRealizations);
        }
        return means;
      }
      return yArray.map(PDFSampler.toNumber);
    }
    
    /**
     * Compute a compact diff label showing only the parts of secondName
     * that differ from firstName, with '...' replacing matching segments
     * longer than 3 characters. Short matching runs (1-3 chars) are kept.
     * Example: firstName='SFR_FSAR_CCP1.h5', secondName='SFR_PSAR_CCP33.h5'
     *          returns '...P...33...'
     *
     * @param {string} firstName - The primary/reference filename
     * @param {string} secondName - The secondary filename to diff
     * @returns {string} Compact diff string
     */
    function filenameDiff(firstName, secondName) {
      // Strip .h5/.hdf5/.he5 extension for comparison
      const stripExt = s => s.replace(/\.(h5|hdf5|he5)$/i, '');
      const a = stripExt(firstName);
      const b = stripExt(secondName);
      
      // Build runs of same/diff segments
      const runs = []; // { same: bool, text: string (from b) }
      let i = 0;
      const len = Math.max(a.length, b.length);
      while (i < len) {
        const ca = i < a.length ? a[i] : '';
        const cb = i < b.length ? b[i] : '';
        const same = (ca === cb);
        let text = cb;
        let j = i + 1;
        while (j < len) {
          const na = j < a.length ? a[j] : '';
          const nb = j < b.length ? b[j] : '';
          if ((na === nb) !== same) break;
          text += nb;
          j++;
        }
        runs.push({ same, text });
        i = j;
      }
      
      // Build result: replace matching runs > 3 chars with '...'
      let result = '';
      for (const run of runs) {
        if (run.same) {
          result += run.text.length > 3 ? '...' : run.text;
        } else {
          result += run.text;
        }
      }
      
      // If result equals the stripped second name, files are identical
      if (result === b) return secondName;
      
      return result;
    }

    /**
     * Get current axis scale values from UI
     * @returns {{xScale: string, yScale: string}}
     */
    function getChartScales() {
      return {
        xScale: getElement('xAxisScale')?.value || 'linear',
        yScale: getElement('yAxisScale')?.value || 'linear'
      };
    }

    /**
     * Capture the current Plotly axis state (ranges and autorange flags)
     * so it can be restored after a chart rebuild.
     * @returns {Object|null} Saved axis state, or null if no chart exists
     */
    function captureAxisState() {
      const plotDiv = getElement('plotlyChart');
      if (!plotDiv || !plotDiv.layout) return null;
      const xaxis = plotDiv.layout.xaxis || {};
      const yaxis = plotDiv.layout.yaxis || {};
      return {
        xRange: xaxis.range ? [...xaxis.range] : null,
        yRange: yaxis.range ? [...yaxis.range] : null,
        xAutorange: xaxis.autorange,
        yAutorange: yaxis.autorange
      };
    }

    /**
     * Apply a previously captured axis state to a Plotly layout object.
     * Only overrides ranges when the user had manually zoomed/panned (autorange=false).
     * @param {Object} layout - Plotly layout to modify in-place
     * @param {Object} savedState - State from captureAxisState()
     */
    function applyAxisState(layout, savedState) {
      if (!savedState) return;
      if (savedState.xRange && savedState.xAutorange === false) {
        layout.xaxis.range = savedState.xRange;
        layout.xaxis.autorange = false;
      }
      if (savedState.yRange && savedState.yAutorange === false) {
        layout.yaxis.range = savedState.yRange;
        layout.yaxis.autorange = false;
      }
    }
    
    /**
     * Create base layout configuration for Plotly charts
     * @param {Object} options - Layout options
     * @param {string} options.title - Chart title
     * @param {string} options.xAxisTitle - X axis title
     * @param {string} options.yAxisTitle - Y axis title
     * @param {string} [options.xScale='linear'] - X axis scale type
     * @param {string} [options.yScale='linear'] - Y axis scale type
     * @returns {Object} Plotly layout configuration
     */
    function createBaseLayout({ title, xAxisTitle, yAxisTitle, xScale = 'linear', yScale = 'linear' }) {
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#e8ddd0' : '#2d2416';
      const gridColor = isDark ? '#4a3f35' : '#e5ddd5';
      const bgColor = isDark ? '#2a221b' : '#ffffff';

      return {
        title: {
          text: '',
          font: { size: 14, color: textColor },
          xanchor: 'left',
          x: 0
        },
        paper_bgcolor: bgColor,
        plot_bgcolor: bgColor,
        font: { color: textColor },
        xaxis: { 
          title: xAxisTitle,
          type: xScale,
          gridcolor: gridColor,
          zerolinecolor: gridColor,
          color: textColor
        },
        yaxis: { 
          title: yAxisTitle,
          type: yScale,
          gridcolor: gridColor,
          zerolinecolor: gridColor,
          color: textColor,
          ...CHART_YAXIS_EXPONENT
        },
        hovermode: 'closest',
        showlegend: true,
        legend: { ...CHART_LEGEND_CONFIG, font: { color: textColor } },
        margin: CHART_MARGIN_WITH_LEGEND
      };
    }

    // ChartService: factories for traces and theme relayout helpers
    window.ChartService = {
      createBaseLayout: function(opts) { return createBaseLayout(opts); },

      timeSeriesTrace({ x, y, name, line = {}, hovertemplate = undefined, showlegend = true }) {
        const trace = { x, y, mode: 'lines', type: 'scatter', name, line, showlegend };
        if (hovertemplate) trace.hovertemplate = hovertemplate;
        return trace;
      },

      histogramTrace({ samples, name = 'Samples', color, lineColor, opacity = 0.85, histnorm = 'probability density' }) {
        return {
          x: samples,
          type: 'histogram',
          histnorm,
          marker: { color, line: { color: lineColor, width: 1 } },
          opacity,
          name
        };
      },

      pdfOverlayTrace({ x, y, color, width = 2.5, name = 'PDF', showlegend = true }) {
        return { x, y, type: 'scatter', mode: 'lines', line: { color, width }, name, showlegend };
      },

      relayoutForTheme(isDark) {
        const textColor = isDark ? '#e8ddd0' : '#2d2416';
        const gridColor = isDark ? '#4a3f35' : '#e5ddd5';
        const bgColor  = isDark ? '#2a221b' : '#ffffff';
        return {
          paper_bgcolor: bgColor,
          plot_bgcolor: bgColor,
          'font.color': textColor,
          'xaxis.gridcolor': gridColor,
          'xaxis.zerolinecolor': gridColor,
          'xaxis.color': textColor,
          'yaxis.gridcolor': gridColor,
          'yaxis.zerolinecolor': gridColor,
          'yaxis.color': textColor,
          'legend.font.color': textColor
        };
      }
    };

    // Update Plotly chart colours when theme changes
    new MutationObserver(() => {
      const el = document.getElementById('plotlyChart');
      if (!el) return;
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#e8ddd0' : '#2d2416';
      const gridColor = isDark ? '#4a3f35' : '#e5ddd5';
      const bgColor  = isDark ? '#2a221b' : '#ffffff';

      if (currentPdfHistogram && currentPdfHistogramData) {
        // Re-render the whole histogram with correct theme colours
        createPdfHistogram(currentPdfHistogramData);
        return;
      }

      if (!currentChartData) return;
      Plotly.relayout(el, ChartService.relayoutForTheme(isDark));
    }).observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

    /**
     * Hide the chart container and clear chart data
     */
    function hideChart() {
      const container = getElement('plotlyChartContainer');
      if (container) {
        container.classList.remove('visible');
        // Restore chart controls visibility (may have been hidden for PDF histograms)
        const controls = container.querySelector('.chart-controls');
        if (controls) controls.style.display = '';
      }
      currentChartData = null;
      currentPdfHistogram = false;
      currentPdfHistogramData = null;
      const histControls = document.getElementById('histControls');
      if (histControls) histControls.style.display = 'none';
    }
    
    /**
     * Reset info panel to default message
     */
    function resetInfoPanel() {
      const info = getElement('info');
      if (info) {
        info.innerHTML = INFO_PANEL_DEFAULT_MESSAGE;
      }
    }
    
    /**
     * Assign legendrank to traces so that in the legend they are grouped by
     * line width (thick first, thin second) and within each group sorted by
     * the maximum Y value in descending order.
     * @param {Array} traces - Array of Plotly trace objects
     */
    function assignLegendRanks(traces) {
      // Classify traces into groups by line width (thick = first file, thin = secondary files)
      const thick = [];
      const thin = [];
      for (let i = 0; i < traces.length; i++) {
        const w = traces[i].line?.width || 2;
        const maxY = Math.max(...(traces[i].y || []).filter(v => v != null && isFinite(v)));
        const entry = { index: i, maxY: isFinite(maxY) ? maxY : 0 };
        if (w >= 2) {
          thick.push(entry);
        } else {
          thin.push(entry);
        }
      }
      // Sort each group by maxY descending
      thick.sort((a, b) => b.maxY - a.maxY);
      thin.sort((a, b) => b.maxY - a.maxY);
      // Assign legendrank: thick group first, then thin group
      let rank = 0;
      for (const entry of thick) {
        traces[entry.index].legendrank = rank++;
      }
      for (const entry of thin) {
        traces[entry.index].legendrank = rank++;
      }
    }

    /**
     * Render a Plotly chart with standard configuration
     * @param {Array} traces - Plotly trace data
     * @param {Object} layout - Plotly layout configuration
     * @param {string} path - Dataset path (for storing in currentChartData)
     */
    function renderChart(traces, layout, path) {
      const container = getElement('plotlyChartContainer');
      const config = getPlotlyConfig('chart');
      
      // Restore chart controls (may have been hidden for PDF histograms)
      if (container) {
        const controls = container.querySelector('.chart-controls');
        if (controls) controls.style.display = '';
      }
      const histControls = document.getElementById('histControls');
      if (histControls) histControls.style.display = 'none';

      if (dynamicLegendEnabled) {
        assignLegendRanks(traces);
      }

      currentChartData = { traces, layout, path };
      if (container) {
        container.classList.add('visible');
      }
      
      Plotly.newPlot('plotlyChart', traces, layout, config).then(() => {
        setupDynamicLegend(getElement('plotlyChart'));
      });
    }

    /**
     * Render a PDF histogram in the main chart area (#plotlyChart).
     * Handles both single-distribution and lookup-table (multi-index) cases.
     * @param {Object} data - pdfHistogramData object
     */
    function createPdfHistogram(data) {
      const container = getElement('plotlyChartContainer');
      if (!container) return;

      // Store data globally for re-rendering on theme / log toggle
      currentPdfHistogramData = data;

      // Hide time-series controls, show histogram controls when applicable
      const controls = container.querySelector('.chart-controls');
      if (controls) controls.style.display = 'none';
      const histControls = document.getElementById('histControls');

      // Determine if all sample values are strictly positive (log10 is only meaningful then)
      let allPositive = true;
      if (data.type === 'single') {
        allPositive = data.samples.every(v => v > 0);
      } else if (data.type === 'lookup') {
        allPositive = data.entries.every(e => e.samples.every(v => v > 0));
      }

      // Always show the Data preview header when a histogram is rendered.
      // Show/hide only the Log10 checkbox based on positivity and clear it when hidden.
      if (histControls) {
        histControls.style.display = ''; // show Data preview area for any histogram
        const logLabel = document.getElementById('histLogLabel');
        const logCheckbox = document.getElementById('histLogScale');
        if (logLabel) logLabel.style.display = allPositive ? '' : 'none';
        if (!allPositive && logCheckbox) logCheckbox.checked = false;
      }
      
      // // Determine if all sample values are strictly positive (log10 is only meaningful then)
      // let allPositive = true;
      // if (data.type === 'single') {
      //   allPositive = data.samples.every(v => v > 0);
      // } else if (data.type === 'lookup') {
      //   allPositive = data.entries.every(e => e.samples.every(v => v > 0));
      // }
      // if (histControls) histControls.style.display = allPositive ? '' : 'none';

      const useLog = allPositive && document.getElementById('histLogScale') && document.getElementById('histLogScale').checked;

      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#e8ddd0' : '#2d2416';
      const gridColor = isDark ? '#4a3f35' : '#e5ddd5';
      const bgColor  = isDark ? '#2a221b' : '#ffffff';
      const barColor  = isDark ? 'rgba(243,184,123,0.45)' : 'rgba(187,108,93,0.45)';
      const barLine   = isDark ? 'rgba(243,184,123,0.8)'  : 'rgba(187,108,93,0.8)';
      const pdfLineColor = isDark ? 'rgba(255,220,160,1)' : 'rgba(140,60,45,1)';
      const detColor  = isDark ? '#ff6b6b' : '#d63031';

      const palette = [
        { bar: isDark ? 'rgba(243,184,123,0.35)' : 'rgba(187,108,93,0.35)', line: isDark ? 'rgba(243,184,123,0.8)' : 'rgba(187,108,93,0.8)', pdf: isDark ? 'rgba(255,220,160,1)' : 'rgba(140,60,45,1)' },
        { bar: isDark ? 'rgba(123,198,243,0.35)' : 'rgba(65,131,196,0.35)',  line: isDark ? 'rgba(123,198,243,0.8)' : 'rgba(65,131,196,0.8)',  pdf: isDark ? 'rgba(160,220,255,1)' : 'rgba(30,90,160,1)' },
        { bar: isDark ? 'rgba(168,230,160,0.35)' : 'rgba(80,160,72,0.35)',   line: isDark ? 'rgba(168,230,160,0.8)' : 'rgba(80,160,72,0.8)',   pdf: isDark ? 'rgba(190,255,185,1)' : 'rgba(40,120,35,1)' },
        { bar: isDark ? 'rgba(230,168,230,0.35)' : 'rgba(170,80,170,0.35)',  line: isDark ? 'rgba(230,168,230,0.8)' : 'rgba(170,80,170,0.8)',  pdf: isDark ? 'rgba(250,200,250,1)' : 'rgba(130,40,130,1)' },
        { bar: isDark ? 'rgba(243,210,123,0.35)' : 'rgba(200,150,50,0.35)',  line: isDark ? 'rgba(243,210,123,0.8)' : 'rgba(200,150,50,0.8)',  pdf: isDark ? 'rgba(255,230,160,1)' : 'rgba(160,110,20,1)' },
        { bar: isDark ? 'rgba(243,150,150,0.35)' : 'rgba(200,80,80,0.35)',   line: isDark ? 'rgba(243,150,150,0.8)' : 'rgba(200,80,80,0.8)',   pdf: isDark ? 'rgba(255,185,185,1)' : 'rgba(160,40,40,1)' },
      ];

      /** Transform value into display-space (identity or log10) */
      const xform = useLog ? v => Math.log10(v) : v => v;

      let traces = [];
      let shapes = [];

      if (data.type === 'single') {
        const label = data.spec ? PDFSampler.pdfLabel(data.spec) : 'raw';

        // Histogram trace (probability density)
        traces.push(ChartService.histogramTrace({ samples: data.samples.map(xform), name: 'Samples', color: barColor, lineColor: barLine, opacity: 0.85 }));

        // Analytical PDF overlay line
        const overlay = data.spec ? computePdfOverlay(data.spec) : null;
        if (overlay) {
          if (useLog) {
            // Change of variable: f_log10(log10(x)) = f(x) ¬∑ x ¬∑ ln(10)
            const xLog = [], yLog = [];
            for (let k = 0; k < overlay.x.length; k++) {
              const xv = overlay.x[k];
              if (xv > 0) {
                xLog.push(Math.log10(xv));
                yLog.push(overlay.y[k] * xv * Math.LN10);
              }
            }
            traces.push(ChartService.pdfOverlayTrace({ x: xLog, y: yLog, color: pdfLineColor, width: 2.5, name: `PDF (${label})` }));
          } else {
            traces.push(ChartService.pdfOverlayTrace({ x: overlay.x, y: overlay.y, color: pdfLineColor, width: 2.5, name: `PDF (${label})` }));
          }
        }

        // Deterministic value vertical line
        if (data.deterministicValue !== null && data.deterministicValue !== undefined && isFinite(data.deterministicValue)) {
          const detX = xform(data.deterministicValue);
          shapes.push({
            type: 'line', x0: detX, x1: detX, y0: 0, y1: 1, yref: 'paper',
            line: { color: detColor, width: 2, dash: 'dashdot' },
          });
          traces.push({
            x: [detX], y: [0], type: 'scatter', mode: 'markers',
            marker: { color: detColor, size: 10, symbol: 'line-ns-open', line: { width: 2, color: detColor } },
            name: 'Deterministic (' + Number(data.deterministicValue.toPrecision(4)) + ')',
            showlegend: true,
          });
        }
      } else if (data.type === 'lookup') {
        data.entries.forEach((entry, i) => {
          const c = palette[i % palette.length];
          const label = entry.spec ? entry.label + ' (' + PDFSampler.pdfLabel(entry.spec) + ')' : entry.label;

          traces.push(ChartService.histogramTrace({ samples: entry.samples.map(xform), name: label, color: c.bar, lineColor: c.line, opacity: 0.7 }));

          const overlay = entry.spec ? computePdfOverlay(entry.spec) : null;
          if (overlay) {
            if (useLog) {
              const xLog = [], yLog = [];
              for (let k = 0; k < overlay.x.length; k++) {
                const xv = overlay.x[k];
                if (xv > 0) { xLog.push(Math.log10(xv)); yLog.push(overlay.y[k] * xv * Math.LN10); }
              }
              traces.push(ChartService.pdfOverlayTrace({ x: xLog, y: yLog, color: c.pdf, width: 2, name: 'PDF ' + entry.label, showlegend: false }));
            } else {
              traces.push(ChartService.pdfOverlayTrace({ x: overlay.x, y: overlay.y, color: c.pdf, width: 2, name: 'PDF ' + entry.label, showlegend: false }));
            }
          }

          if (entry.deterministicValue !== null && entry.deterministicValue !== undefined && isFinite(entry.deterministicValue)) {
            const detX = xform(entry.deterministicValue);
            shapes.push({
              type: 'line', x0: detX, x1: detX, y0: 0, y1: 1, yref: 'paper',
              line: { color: c.line, width: 1.5, dash: 'dashdot' },
            });
          }
        });
      }

      const layout = {
        barmode: data.type === 'lookup' ? 'overlay' : undefined,
        paper_bgcolor: bgColor,
        plot_bgcolor: bgColor,
        font: { color: textColor },
        xaxis: {
          title: useLog ? 'log\u2081\u2080(Value)' : 'Value',
          gridcolor: gridColor,
          zerolinecolor: gridColor,
          color: textColor,
        },
        yaxis: {
          title: 'Probability Density',
          gridcolor: gridColor,
          zerolinecolor: gridColor,
          color: textColor,
          rangemode: 'tozero',
        },
        margin: { t: 20, r: 30, b: 60, l: 60 },
        showlegend: true,
        legend: { font: { color: textColor } },
        shapes: shapes,
      };

      const config = getPlotlyConfig('pdf_histogram');

      currentPdfHistogram = true;
      currentChartData = null;
      container.classList.add('visible');

      Plotly.newPlot('plotlyChart', traces, layout, config);
    }

    /**
     * Toggle log\u2081\u2080 scale on the PDF histogram x-axis.
     * Re-renders the histogram from stored data.
     */
    function toggleHistLog() {
      if (currentPdfHistogramData) {
        createPdfHistogram(currentPdfHistogramData);
      }
    }


    /* ==========================================================================
       3. HDF5 DATA ACCESS
       ========================================================================== */
    
    /**
     * Check if a dataset or group exists at the given path in an HDF5 file.
     * Safely handles exceptions from invalid paths.
     * 
     * @param {Object} file - h5wasm File object
     * @param {string} path - HDF5 path to check (e.g., '/group/dataset')
     * @returns {boolean} True if the path exists and is accessible
     */
    function checkDatasetExistsInFile(file, path) {
      try {
        const dataset = FileService.get(file, path);
        return dataset !== null && dataset !== undefined;
      } catch (e) {
        return false;
      }
    }
    
    /**
     * Check if a path exists in a file referenced by filename.
     * Looks up the file in loadedFiles by name before checking.
     * 
     * @param {string} fileName - Key in loadedFiles object
     * @param {string} path - HDF5 path to check
     * @returns {boolean} True if file exists in loadedFiles and path is valid
     */
    function checkIfPathExistsInFile(fileName, path) {
      try {
        const file = loadedFiles[fileName];
        if (!file) return false;
        const node = FileService.get(file, path);
        return node !== null && node !== undefined;
      } catch (e) {
        return false;
      }
    }

    /**
     * Retrieve time axis data from the standard '/time' dataset.
     * This is the x-axis data for time-dependent plots.
     * 
     * @param {Object} file - h5wasm File object
     * @returns {number[]|null} Array of time values, or null if not found
     */
    function getTimeData(file) {
      try {
        const timeDataset = FileService.get(file, '/time');
        if (timeDataset && typeof timeDataset.value !== 'undefined') {
          let timeData = timeDataset.value;
          if (timeData && typeof timeData === 'object' && timeData.length !== undefined) {
            return Array.from(timeData);
          }
          return [timeData];
        }
      } catch (e) {
        console.warn('Could not read /time dataset:', e.message);
      }
      return null;
    }

    /**
     * Get the unit string from the '/time' dataset's 'unit' attribute.
     * Used for labeling the x-axis on time-dependent charts.
     * 
     * @param {Object} file - h5wasm File object
     * @returns {string} Time unit string (e.g., 'years', 's'), or empty string if not found
     */
    function getTimeUnit(file) {
      try {
        const timeDataset = FileService.get(file, '/time');
        if (timeDataset && timeDataset.attrs && typeof timeDataset.attrs === 'object') {
          for (const attrName in timeDataset.attrs) {
            if (attrName === 'unit') {
              const attrObj = timeDataset.attrs[attrName];
              if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                return attrObj.value;
              }
            }
          }
        }
      } catch (e) {
        console.warn('Could not read time unit:', e);
      }
      return '';
    }

    /**
     * Check if a dataset has the 'time_dependent' attribute set to a truthy value.
     * Datasets marked as time-dependent are eligible for time-series plotting.
     * 
     * @param {Object} dataset - h5wasm Dataset object with attrs property
     * @returns {boolean} True if the dataset has time_dependent=true/1/'TRUE'/'True'
     */
    function isTimeDependent(dataset) {
      try {
        if (dataset.attrs && typeof dataset.attrs === 'object') {
          for (const attrName in dataset.attrs) {
            if (attrName === 'time_dependent') {
              const attrObj = dataset.attrs[attrName];
              if (attrObj && typeof attrObj.value !== 'undefined') {
                const value = attrObj.value;
                return value === true || value === 1 || value === 'TRUE' || value === 'True';
              }
            }
          }
        }
      } catch (e) {
        console.warn('Error checking time_dependent attribute:', e);
      }
      return false;
    }
    
    /**
     * Check if a group contains radionuclide data suitable for special charting.
     * A radionuclides group must have:
     * - IndexLists attribute containing 'Radionuclides'
     * - time_dependent attribute set to true
     * 
     * These groups get special treatment: all child datasets are plotted together
     * with isotope-specific line styles and colors.
     * 
     * @param {Object} file - h5wasm File object
     * @param {string} path - HDF5 path to the group
     * @returns {boolean} True if the group is a radionuclides data container
     */
    function checkGroupForRadionuclides(file, path) {
      try {
        const group = FileService.get(file, path);
        if (!group || group.type.toLowerCase() !== 'group') {
          return false;
        }
        
        let hasRadionuclidesIndex = false;
        let isTimeDependentGroup = false;
        
        if (group.attrs && typeof group.attrs === 'object') {
          for (const attrName in group.attrs) {
            if (attrName === 'IndexLists') {
              const attrObj = group.attrs[attrName];
              if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                const value = attrObj.value;
                if (Array.isArray(value) && value.includes('Radionuclides')) {
                  hasRadionuclidesIndex = true;
                } else if (typeof value === 'string' && value === 'Radionuclides') {
                  hasRadionuclidesIndex = true;
                }
              }
            }
            
            if (attrName === 'time_dependent') {
              const attrObj = group.attrs[attrName];
              if (attrObj && typeof attrObj.value !== 'undefined') {
                const value = attrObj.value;
                isTimeDependentGroup = value === true || value === 1 || value === 'TRUE' || value === 'True';
              }
            }
          }
        }
        
        return hasRadionuclidesIndex && isTimeDependentGroup;
      } catch (e) {
        console.warn('Error checking group for radionuclides:', e);
        return false;
      }
    }


    /* ==========================================================================
       4. FILE MANAGEMENT
       ========================================================================== */
    
    /**
     * Get list of filenames for currently enabled (visible) files.
     * Maintains the order from fileOrder array.
     * 
     * @returns {string[]} Array of enabled filenames in display order
     */
    function getEnabledFiles() {
      return fileOrder.filter(key => fileStates[key]);
    }
    
    /**
     * Get the filename of the first enabled file.
     * This file's structure is used to render the tree view.
     * 
     * @returns {string|null} Filename of first enabled file, or null if none enabled
     */
    function getTreeFile() {
      const enabledFiles = getEnabledFiles();
      return enabledFiles.length > 0 ? enabledFiles[0] : null;
    }

    /**
     * Check if intersect mode is active.
     * @returns {boolean}
     */
    function isIntersectMode() {
      const cb = document.getElementById('intersectCheckbox');
      return cb && cb.checked && getEnabledFiles().length > 1;
    }

    /**
     * Get the list of files to use for info/charts.
     * In non-intersect mode with a specific file selected, returns just that file.
     * In intersect mode, returns all enabled files.
     * @returns {string[]}
     */
    function getEffectiveFiles() {
      if (isIntersectMode()) {
        return getEnabledFiles();
      }
      if (selectedFileKey && loadedFiles[selectedFileKey]) {
        return [selectedFileKey];
      }
      return getEnabledFiles();
    }

    /**
     * Toggle a file's enabled/disabled state and update the UI.
     * Enabled files contribute data to charts; disabled files are hidden.
     * 
     * @param {string} fileName - The filename to toggle
     */
    function toggleFileState(fileName) {
      fileStates[fileName] = !fileStates[fileName];
      updateTabs();
    }

    /**
     * Remove a file completely from the viewer.
     * Cleans up all references and updates the UI. If this was the last
     * file, resets the viewer to its initial empty state.
     * 
     * @param {string} fileName - The filename to remove
     * @returns {Promise<void>}
     */
    async function removeFile(fileName) {
      delete loadedFiles[fileName];
      delete fileStates[fileName];
      fileOrder = fileOrder.filter(k => k !== fileName);
      
      const enabledFiles = getEnabledFiles();
      
      updateTabs();
      
      if (enabledFiles.length === 0) {
        // No enabled files - clear UI
        currentTreeFile = null;
        const tree = document.getElementById('tree');
        tree.innerHTML = '<div class="loading">Drop HDF5 files or click "+ Add Files" to start...</div>';
        tree.classList.add('loading');
        resetInfoPanel();
        hideChart();
        selectedDatasetPath = null;
        selectedIsRadionuclidesGroup = false;
        
        document.querySelector('.search-container').classList.remove('visible');
        
        const hint = document.getElementById('multiSelectHint');
        if (hint) {
          hint.style.display = 'none';
        }
      }
    }
    
    /**
     * Refresh the info panel and chart display after file selection changes.
     * Verifies the selected path still exists in the current tree file.
     * If the path no longer exists, clears the selection.
     * 
     * @returns {void}
     */
    function refreshInfoAndChart() {
      if (!selectedDatasetPath) {
        return;
      }

      // Use selectedFileKey if available, otherwise first enabled file
      const checkFile = selectedFileKey || getTreeFile();
      
      // If the selected path no longer exists in the current file OR
      // is excluded by the active intersected-path set, clear selection.
      const intersected = window._currentIntersectedPaths || getIntersectedPaths();
      if (!checkFile || !checkIfPathExistsInFile(checkFile, selectedDatasetPath) || (isIntersectMode() && intersected && !intersected.has(selectedDatasetPath))) {
        // Clear selection if path doesn't exist or is outside the intersection
        resetInfoPanel();
        hideChart();
        selectedDatasetPath = null;
        selectedIsRadionuclidesGroup = false;
        selectedFileKey = null;
        
        document.querySelectorAll('.tree-item.dataset.selected').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.tree-item.group.expanded').forEach(el => el.classList.remove('expanded'));
        return;
      }

      // Path exists, refresh display
      if (selectedIsRadionuclidesGroup) {
        showNodeAttributes(selectedDatasetPath, true);
        createRadionuclidesChart(selectedDatasetPath);
      } else {
        showNodeAttributes(selectedDatasetPath, false);
        
        try {
          const file = loadedFiles[checkFile];
          const dataset = FileService.get(file, selectedDatasetPath);
          if (dataset && dataset.type.toLowerCase() === 'dataset' && isTimeDependent(dataset)) {
            createPlotlyChart(selectedDatasetPath);
          }
        } catch (e) {
          console.warn('Error checking if dataset is time-dependent:', e);
        }
      }
    }


    /* ==========================================================================
       5. TAB MANAGEMENT
       ========================================================================== */
    
    /**
     * Update the file tabs display and reinitialize drag-drop sorting.
     * Renders a tab for each loaded file, handles click-to-toggle and
     * drag-to-reorder functionality via SortableJS.
     * 
     * Tab states:
     * - enabled: File data included in charts (blue indicator)
     * - disabled: File loaded but hidden from charts (gray)
     * 
     * @returns {void}
     */
    function updateTabs() {
      const tabsContainer = document.getElementById('fileTabs');
      const previousTreeFile = currentTreeFile;
      
      // Render tabs
      tabsContainer.innerHTML = fileOrder.map(key => {
        const isEnabled = fileStates[key];
        return `
          <div class="file-tab ${isEnabled ? 'enabled' : 'disabled'}" data-file="${escapeHtml(key)}">
            <div class="file-tab-name" title="${escapeHtml(key)}">${escapeHtml(key)}</div>
            <div class="file-tab-close" onclick="event.stopPropagation(); removeFile('${key.replace(/'/g, "\\'")}')">√ó</div>
          </div>
        `;
      }).join('');
      
      // Add click handlers for toggle
      document.querySelectorAll('.file-tab').forEach(tab => {
        const fileName = tab.getAttribute('data-file');
        tab.addEventListener('click', (e) => {
          if (!e.target.classList.contains('file-tab-close')) {
            toggleFileState(fileName);
          }
        });
      });
      
      // Initialize SortableJS for drag reordering
      if (window.Sortable && tabsContainer.children.length > 0) {
        Sortable.create(tabsContainer, {
          animation: 150,
          ghostClass: 'sortable-ghost',
          dragClass: 'sortable-drag',
          onEnd: function(evt) {
            const previousFirst = currentTreeFile;
            
            const newOrder = Array.from(tabsContainer.children).map(
              tab => tab.getAttribute('data-file')
            );
            fileOrder = newOrder;
            
            const newTreeFile = getTreeFile();
            currentTreeFile = newTreeFile;
            
            const treeFileChanged = previousFirst !== newTreeFile;
            
            console.log('Drag ended - Previous:', previousFirst, 'New:', newTreeFile, 'Changed:', treeFileChanged);
            
            if (treeFileChanged) {
              refreshTreeStructure();
            }
            
            refreshInfoAndChart();
          }
        });
      }
      
      // Check if tree file changed
      const newTreeFile = getTreeFile();
      const treeFileChanged = previousTreeFile !== newTreeFile;
      currentTreeFile = newTreeFile;
      
      // Show/hide Intersect checkbox based on number of enabled files
      const intersectLabel = document.getElementById('intersectLabel');
      const enabledCount = getEnabledFiles().length;
      if (intersectLabel) {
        intersectLabel.style.display = enabledCount > 1 ? 'flex' : 'none';
        // Uncheck if only one file left
        if (enabledCount <= 1) {
          const cb = document.getElementById('intersectCheckbox');
          if (cb) cb.checked = false;
        }
      }
      
      console.log('updateTabs - Previous:', previousTreeFile, 'New:', newTreeFile, 'Changed:', treeFileChanged);
      
      // Only refresh the tree when necessary (tree root changed or enabled set changed).
      // This prevents frequent/expensive refreshes and avoids triggering search-aware
      // background expansions on unrelated UI clicks.
      const prevEnabledCount = window._lastEnabledCount || 0;
      const needRefresh = treeFileChanged || (enabledCount !== prevEnabledCount);
      window._lastEnabledCount = enabledCount;

      let refreshPromise;
      if (needRefresh) {
        const isIntersect = isIntersectMode();

        // Immediate visual feedback in the tree while recalculation runs.
        try {
          const tree = document.getElementById('tree');
          if (tree) {
            if (isIntersect) {
              tree.innerHTML = `
                <div class="tree-item group root-node" data-path="/">
                  <div class="tree-toggle no-toggle"></div>
                  <div class="tree-icon folder"></div>
                  <div class="tree-label">/ (Intersection) <span class="tree-inline-spinner" aria-hidden="true"></span></div>
                </div>
                <div class="tree-group-children expanded" style="margin-left:20px;">
                  <div class="loading" style="padding:8px;font-size:12px;">Recalculating intersection‚Ä¶</div>
                </div>
              `;
            } else {
              tree.innerHTML = `<div class="loading">Refreshing tree‚Ä¶ <span class="tree-inline-spinner" aria-hidden="true"></span></div>`;
            }
            // force layout so the spinner paints immediately (Safari-safe)
            void tree.offsetHeight;
            document.querySelector('.search-container')?.classList.remove('visible');
          }
        } catch (e) { /* ignore UI update errors */ }

        // Show header ticker for intersect recalculation as well
        if (isIntersect) {
          try { showFileLoadTicker(0, 0, 'Recalculating intersection...'); } catch (e) {}
        }

        // Run the refresh asynchronously (yield so the spinner is visible first)
        refreshPromise = new Promise((resolve, reject) => {
          setTimeout(() => {
            refreshTreeStructure().then(resolve, reject);
          }, 20);
        }).finally(() => {
          if (isIntersect) {
            try { hideFileLoadTicker(); } catch (e) {}
          }
        });
      } else {
        refreshPromise = Promise.resolve();
      }

      refreshInfoAndChart();

      // Validate multi-selection against the active intersection (if any).
      function validateSelectedDatasets() {
        try {
          if (selectedDatasets && selectedDatasets.length > 0) {
            const intersected = window._currentIntersectedPaths || getIntersectedPaths();
            if (isIntersectMode() && intersected && intersected.size > 0) {
              const before = selectedDatasets.length;
              selectedDatasets = selectedDatasets.filter(d => intersected.has(d.path));
              if (selectedDatasets.length === 0) {
                // clear UI selection
                resetInfoPanel();
                hideChart();
                document.querySelectorAll('.tree-item.dataset.selected').forEach(el => el.classList.remove('selected'));
              } else if (selectedDatasets.length < before) {
                // update shown attributes for the remaining selection
                showMultipleDatasetAttributes(selectedDatasets);
              }
            } else {
              // Non-intersect: remove any selected entries that no longer exist
              selectedDatasets = selectedDatasets.filter(d => checkIfPathExistsInFile(d.fileKey || getTreeFile(), d.path));
              if (selectedDatasets.length === 0) {
                resetInfoPanel();
                hideChart();
                document.querySelectorAll('.tree-item.dataset.selected').forEach(el => el.classList.remove('selected'));
              } else {
                showMultipleDatasetAttributes(selectedDatasets);
              }
            }
          }
        } catch (e) { console.warn('validate-selected-datasets error', e); }
      }

      validateSelectedDatasets();

      // Re-validate selection after async refresh completes (important for intersect changes)
      if (needRefresh && refreshPromise) {
        refreshPromise.then(() => {
          refreshInfoAndChart();
          validateSelectedDatasets();
        }).catch(e => console.warn('post-refresh validation failed', e));
      }

      return refreshPromise;
    }

    /* ==========================================================================
       6. TREE VIEW
       ========================================================================== */
    
    /**
     * Toggle the expand/collapse state of a group node in the tree.
     * Called when clicking the triangle toggle icon.
     * Does NOT select the group or trigger chart updates.
     * 
     * @param {Event} event - Click event on the toggle icon
     * @param {string} path - HDF5 path of the group
     * @returns {void}
     */
    function toggleGroupExpansion(event, path) {
      event.stopPropagation();
      
      const toggle = event.currentTarget;
      const groupItem = toggle.closest('.tree-item.group');
      const childrenDiv = groupItem.nextElementSibling;
      
      if (childrenDiv && childrenDiv.classList.contains('tree-group-children')) {
        const isExpanded = childrenDiv.classList.contains('expanded');
        
        if (isExpanded) {
          childrenDiv.classList.remove('expanded');
          toggle.classList.add('collapsed');
          groupItem.classList.remove('expanded');
        } else {
          // If children were rendered as lazy placeholders, load them on first expand
          if (childrenDiv && childrenDiv.getAttribute && childrenDiv.getAttribute('data-lazy') === 'true') {
            // If intersect mode is active and this path has no allowed descendants,
            // mark it as loaded-empty and avoid the load to save work.
            const intersected = window._currentIntersectedPaths || null;
            if (intersected && !Array.from(intersected).some(p => p === path || p.startsWith(path + '/'))) {
              childrenDiv.innerHTML = '<div style="color:#999;padding:8px;font-size:12px;">(empty)</div>';
              childrenDiv.setAttribute('data-loaded', 'true');
            } else {
              // fire-and-forget loader; it will set data-loaded when complete
              loadGroupChildren(groupItem, path).catch(e => console.error('Lazy load failed', e));
            }
          }
          childrenDiv.classList.add('expanded');
          toggle.classList.remove('collapsed');
        }
      }
    }
    
    /**
     * Lazy-load children for a group node the first time it is expanded.
     * Inserts the group's subtree HTML into the adjacent `.tree-group-children`.
     */
    async function loadGroupChildren(groupItem, path) {
      try {
        const childrenDiv = groupItem.nextElementSibling;
        if (!childrenDiv || childrenDiv.getAttribute('data-loaded') === 'true' || childrenDiv.getAttribute('data-loading') === 'true') return;
        childrenDiv.setAttribute('data-loading', 'true');
        childrenDiv.innerHTML = '<div class="loading" style="padding:8px;font-size:12px;">Loading‚Ä¶</div>';
        const fileKey = groupItem.getAttribute('data-file') || getTreeFile();
        const file = loadedFiles[fileKey];
        if (!file) {
          childrenDiv.innerHTML = '<div style="color:#999;padding:8px;font-size:12px;">(unavailable)</div>';
          childrenDiv.setAttribute('data-loaded', 'true');
          childrenDiv.removeAttribute('data-loading');
          return;
        }
        const node = FileService.get(file, path);
        if (!node) {
          childrenDiv.innerHTML = '<div style="color:#999;padding:8px;font-size:12px;">(unreadable)</div>';
          childrenDiv.setAttribute('data-loaded', 'true');
          childrenDiv.removeAttribute('data-loading');
          return;
        }
        // Build the subtree for this group (non-lazy recursive build).
        // If intersect mode is active, pass the intersectedPaths so children
        // that are not common to all enabled files are filtered out.
        const intersected = window._currentIntersectedPaths || null;
        // render only one level when expanding lazily to keep UI responsive
        const subHtml = await buildTree(node, path, true, '', intersected, fileKey, null, false, 1);
        childrenDiv.innerHTML = subHtml || '<div style="color:#999;padding:8px;font-size:12px;">(empty)</div>'; 
        childrenDiv.setAttribute('data-loaded', 'true');
        childrenDiv.removeAttribute('data-loading');
      } catch (e) {
        console.error('loadGroupChildren error', e);
        const childrenDiv = groupItem.nextElementSibling;
        if (childrenDiv) childrenDiv.innerHTML = `<div style="color:red;padding:8px;font-size:12px;">(error: ${escapeHtml(e.message)})</div>`;
      }
    }
    
    /**
     * Handle dataset selection in single or multi-select mode.
     * 
     * Single-click: Selects one dataset, shows its info and chart.
     * Ctrl/Cmd+click: Adds/removes dataset from multi-selection,
     *                 shows combined info and comparison chart.
     * 
     * @param {string} path - HDF5 path to the dataset
     * @param {Event} [evt] - Click event (used to detect Ctrl/Cmd key)
     * @returns {void}
     */
    function selectDataset(path, evt) {
      evt?.stopPropagation();
      
      const isCtrlKey = evt?.ctrlKey || evt?.metaKey;
      const datasetElement = evt?.target?.closest('.tree-item.dataset');
      
      // Determine which file this tree node belongs to
      const nodeFileKey = datasetElement?.getAttribute('data-file') || null;
      
      if (isCtrlKey) {
        // Multi-select mode ‚Äî allow cross-file selection
        multiSelectMode = true;
        selectedFileKey = null; // clear single-file scope
        
        const index = selectedDatasets.findIndex(d => d.path === path && d.fileKey === nodeFileKey);
        if (index > -1) {
          selectedDatasets.splice(index, 1);
          datasetElement?.classList.remove('selected');
        } else {
          selectedDatasets.push({ path, fileKey: nodeFileKey });
          datasetElement?.classList.add('selected');
        }
        
        selectedIsRadionuclidesGroup = false;
        document.querySelectorAll('.tree-item.group.expanded').forEach(el => {
          el.classList.remove('expanded');
        });
        
        if (selectedDatasets.length > 0) {
          showMultipleDatasetAttributes(selectedDatasets);
        } else {
          resetInfoPanel();
          document.getElementById('plotlyChartContainer').classList.remove('visible');
          currentChartData = null;
        }
      } else {
        // Single select mode
        multiSelectMode = false;
        selectedFileKey = nodeFileKey;
        selectedDatasets = [{ path, fileKey: nodeFileKey }];
        selectedDatasetPath = path;
        selectedIsRadionuclidesGroup = false;
        
        document.querySelectorAll('.tree-item.dataset.selected').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.tree-item.group.expanded').forEach(el => el.classList.remove('expanded'));
        
        datasetElement?.classList.add('selected');
        
        showNodeAttributes(path, false);
      }
    }
    
    /**
     * Handle group selection to show group info and radionuclides chart.
     * Clicking on a group (not its toggle icon) selects it for display.
     * If the group contains radionuclides data, triggers special charting.
     * 
     * @param {Event} event - Click event on the group element
     * @returns {void}
     */
    function toggleGroup(event) {
      event.stopPropagation();
      const groupItem = event.currentTarget;
      
      if (event.target.classList.contains('tree-toggle')) {
        return;
      }
      
      const path = groupItem.getAttribute('data-path');
      if (path) {
        multiSelectMode = false;
        selectedDatasets = [];
        
        // Determine which file this tree node belongs to
        const nodeFileKey = groupItem.getAttribute('data-file') || null;
        selectedFileKey = nodeFileKey;
        
        selectedDatasetPath = path;
        selectedIsRadionuclidesGroup = true;
        
        document.querySelectorAll('.tree-item.dataset.selected').forEach(el => {
          el.classList.remove('selected');
        });
        
        document.querySelectorAll('.tree-item.group.expanded').forEach(el => {
          el.classList.remove('expanded');
        });
        
        groupItem.classList.add('expanded');
        
        showNodeAttributes(path, true);
      }
    }

    /**
     * Toggle the Intersect checkbox and rebuild the tree.
     */
    async function toggleIntersect() {
      // Clear per-file selection when switching modes
      selectedFileKey = null;
      selectedDatasetPath = null;
      selectedIsRadionuclidesGroup = false;
      selectedDatasets = [];
      multiSelectMode = false;
      resetInfoPanel();
      hideChart();

      // Immediately show the Intersection root + inline spinner so the UI
      // responds instantly while the expensive intersection calculation runs.
      try {
        const tree = document.getElementById('tree');
        if (tree) {
          tree.innerHTML = `
            <div class="tree-item group root-node" data-path="/">
              <div class="tree-toggle no-toggle"></div>
              <div class="tree-icon folder"></div>
              <div class="tree-label">/ (Intersection) <span class="tree-inline-spinner" aria-hidden="true"></span></div>
            </div>
            <div class="tree-group-children expanded" style="margin-left:20px;">
              <div class="loading" style="padding:8px;font-size:12px;">Calculating intersection‚Ä¶</div>
            </div>
          `;
          // force layout so browsers (Safari) paint the inserted spinner immediately
          void tree.offsetHeight;
          tree.classList.remove('loading');
          document.querySelector('.search-container')?.classList.remove('visible');
        }
      } catch (e) { /* ignore UI update errors */ }

      // Let the browser paint the inline spinner before starting the expensive work.
      // Use setTimeout to yield to the event loop (more reliable on Safari).
      await new Promise(r => setTimeout(r, 0));

      // Start refresh asynchronously so the UI paint is never blocked in Safari.
      const cb = document.getElementById('intersectCheckbox');
      if (cb) cb.disabled = true;
      setTimeout(() => {
        refreshTreeStructure().finally(() => { if (cb) cb.disabled = false; });
      }, 20);

      // return immediately so the inline spinner remains visible while work runs
      return;
    }

    /**
     * Recursively collect all paths (groups and datasets) from an HDF5 file.
     * @param {Object} group - h5wasm Group object
     * @param {string} prefix - Current path prefix
     * @returns {Set<string>} Set of all paths in the group
     */
    function collectAllPaths(group, prefix = '') {
      const paths = new Set();
      try {
        let keys = [];
        if (typeof group.keys === 'function') {
          keys = Array.from(group.keys());
        }
        for (const key of keys) {
          const path = prefix ? `${prefix}/${key}` : `/${key}`;
          paths.add(path);
          try {
            const obj = group.get(key);
            if (obj && String(obj.type).toLowerCase() === 'group') {
              for (const subPath of collectAllPaths(obj, path)) {
                paths.add(subPath);
              }
            }
          } catch (e) { /* skip */ }
        }
      } catch (e) { /* skip */ }
      return paths;
    }

    /**
     * Get the set of paths that exist in ALL enabled files (full-path intersection).
     * Only paths that are present (identical) in every enabled file will be
     * returned ‚Äî this enforces that the displayed tree nodes have the same
     * hierarchy in all enabled files.
     *
     * @returns {Set<string>|null} Intersected paths, or null if intersect is off
     */
    function getIntersectedPaths() {
      const checkbox = document.getElementById('intersectCheckbox');
      if (!checkbox || !checkbox.checked) return null;
      
      const enabledFiles = getEnabledFiles();
      if (enabledFiles.length < 2) return null;
      
      let intersection = null;
      for (const fileKey of enabledFiles) {
        const file = loadedFiles[fileKey];
        if (!file) continue;
        const filePaths = collectAllPaths(file);
        if (intersection === null) {
          intersection = filePaths;
        } else {
          // Keep only paths present in both sets
          for (const p of intersection) {
            if (!filePaths.has(p)) intersection.delete(p);
          }
        }
      }
      return intersection || new Set();
    }

    /**
     * Walk the HDF5 group and count items (datasets + groups) so we can show
     * determinate progress while building the tree. Honors the optional
     * intersectedPaths filter.
     *
     * @param {Object} group - h5wasm Group or File
     * @param {Set|null} intersectedPaths - optional filter set
     * @returns {Promise<number>} total items
     */
    async function countTreeItems(group, intersectedPaths = null) {
      let cnt = 0;
      try {
        const keys = (typeof group.keys === 'function') ? Array.from(group.keys()).sort() : [];
        for (const key of keys) {
          try {
            const obj = group.get(key);
            if (!obj) continue;
            const path = group === loadedFiles[Object.keys(loadedFiles)[0]] ? `/${key}` : `${group.name || ''}/${key}`;
            if (intersectedPaths && !intersectedPaths.has(path)) continue;
            // count this node
            cnt += 1;
            if (String(obj.type).toLowerCase() === 'group') {
              cnt += await countTreeItems(obj, intersectedPaths);
            }
          } catch (e) {
            // ignore individual errors while counting
          }
        }
      } catch (e) {
        // best-effort counting; return what we've got
      }
      return cnt;
    }

    /**
     * Refresh the tree view from the first enabled file's structure.
     * Rebuilds the entire tree HTML and applies any active search filter.
     * Shows loading state during refresh and handles errors gracefully.
     * 
     * @returns {Promise<void>}
     */
    async function refreshTreeStructure() {
      const tree = document.getElementById('tree');
      const searchContainer = document.querySelector('.search-container');
      const enabledFiles = getEnabledFiles();

      // indicate busy for accessibility and automated tests
      try { tree && tree.setAttribute('aria-busy', 'true'); } catch(e) {}
      
      if (enabledFiles.length === 0) {
        tree.innerHTML = '<div class="loading">Drop HDF5 files or click "+ Add Files" to start...</div>';
        tree.classList.add('loading');
        resetInfoPanel();
        hideChart();
        searchContainer.classList.remove('visible');
        try { tree && tree.removeAttribute('aria-busy'); } catch(e) {}
        return;
      }
      
      try {
        const intersectedPaths = getIntersectedPaths();
        try { window._currentIntersectedPaths = intersectedPaths; } catch(e) {}
        let treeHtml = '';

        // Shallow estimate to avoid a full pre-traversal (fast, best-effort).
        // Use top-level key counts as a cheap heuristic; fall back to
        // indeterminate mode when the estimate is small/uncertain.
        let totalItems = 0;
        try {
          for (const fk of enabledFiles) {
            const f = loadedFiles[fk];
            if (!f || typeof f.keys !== 'function') continue;
            totalItems += Array.from(f.keys()).length || 0;
          }
          // treat small estimates as unknown so UI stays indeterminate
          if (totalItems < 20) totalItems = 0;
        } catch (e) {
          totalItems = 0;
        }

        // use a single progress callback shared across builds (throttled)
        let progressSeen = 0;
        const progressCb = (() => {
          let lastPct = -1;
          let lastTs = 0;
          return (inc = 1, label = '') => {
            progressSeen += (typeof inc === 'number' ? inc : 1);
            const now = Date.now();
            if (totalItems > 0) {
              const pct = Math.floor((progressSeen / totalItems) * 100);
              if (pct !== lastPct) {
                lastPct = pct;
                updateFileLoadTicker(progressSeen, totalItems, label || 'Building tree...');
              }
            } else {
              // indeterminate ‚Äî update at most every 500ms or on coarse increments
              if (now - lastTs > 500 || progressSeen % 100 === 0) {
                lastTs = now;
                updateFileLoadTicker(progressSeen, 0, label || 'Building tree...');
              }
            }
          };
        })();

        if (totalItems > 0) {
          showFileLoadTicker(0, totalItems, 'Building tree...');
        } else {
          // no reliable total ‚Äî show indeterminate spinner
          showFileLoadTicker(0, 0, 'Building tree...');
        }

        // Clear tree and render incrementally so users see content immediately.
        tree.innerHTML = '';
        if (intersectedPaths) {
          // Intersect mode: single tree from first file, filtered to common paths
          const file = loadedFiles[enabledFiles[0]];
          const fileHtml = await buildTree(file, '', false, 'Intersection', intersectedPaths, null, progressCb, true);
          tree.insertAdjacentHTML('beforeend', fileHtml || '<div style="color:#999;">No items found</div>');
        } else {
          // Non-intersect: append each file as it finishes so UI is responsive
          for (const fileKey of enabledFiles) {
            const file = loadedFiles[fileKey];
            const fileHtml = await buildTree(file, '', false, fileKey, null, fileKey, progressCb, true);
            tree.insertAdjacentHTML('beforeend', fileHtml || '<div style="color:#999;padding:8px;font-size:12px;">(empty)</div>');
            // yield to allow the browser to paint between files
            await new Promise(r => setTimeout(r, 0));
          }
        }

        // finalize progress and UI
        if (totalItems > 0) updateFileLoadTicker(totalItems, totalItems, 'Done');
        hideFileLoadTicker();

        if (!tree.innerHTML || tree.innerHTML.trim() === '') {
          tree.innerHTML = '<div style="color:#999;">No items found</div>';
        }
        tree.classList.remove('loading');
        searchContainer.classList.add('visible');
        try { tree && tree.removeAttribute('aria-busy'); } catch(e) {}

        // Post-refresh validation: ensure the right-panel selection/chart
        // reflect the newly-built tree / intersected set.
        try { refreshInfoAndChart(); } catch (e) { console.warn('refreshInfoAndChart after refreshTreeStructure failed', e); }
      } catch (err) {
        tree.innerHTML = `<div class="error">Error loading tree: ${escapeHtml(err.message)}</div>`;
        console.error(err);
        searchContainer.classList.remove('visible');
        try { tree && tree.removeAttribute('aria-busy'); } catch(e) {}
      }
    }
    
    // Decorator: Show multi-select hint after tree refresh
    const originalRefreshTreeStructure2 = refreshTreeStructure;
    refreshTreeStructure = async function() {
      await originalRefreshTreeStructure2();
      const hint = document.getElementById('multiSelectHint');
      const tree = document.getElementById('tree');
      
      if (hint) {
        const hasEnabledFiles = getEnabledFiles().length > 0;
        const isNotLoading = !tree.classList.contains('loading');
        const hasTreeContent = tree.querySelector('.tree-item') !== null;
        
        if (hasEnabledFiles && isNotLoading && hasTreeContent) {
          hint.style.display = 'flex';
          // Notify user that tree refresh completed
        } else {
          hint.style.display = 'none';
        }
      }
    };
    
    /**
     * Recursively build HTML tree structure from an HDF5 group.
     * Creates collapsible group nodes and selectable dataset nodes.
     * Preserves selection state when rebuilding.
     * 
     * @param {Object} group - h5wasm Group object to traverse
     * @param {string} [prefix=''] - Path prefix for nested items
     * @param {boolean} [isNested=false] - Whether this is a nested call (not root)
     * @returns {Promise<string>} HTML string for the tree structure
     */
    async function buildTree(group, prefix = '', isNested = false, fileName = '', intersectedPaths = null, fileKey = null, progressCb = null, lazyLoad = false, maxDepth = Infinity) {
      const childrenHtml = [];
      // depth guard for incremental rendering (maxDepth=0 => render nothing)
      if (typeof maxDepth === 'number' && maxDepth <= 0) return ''; 
      const fileAttr = fileKey ? ` data-file="${escapeHtml(fileKey)}"` : '';
      
      // Add root group item only at top level
      if (prefix === '') {
        const isRootSelected = selectedDatasetPath === '/' && selectedIsRadionuclidesGroup;
        const rootLabel = fileName ? fileName : 'root';
        // decide whether root is expandable under the active intersect filter
        let rootExpandable = true;
        if (intersectedPaths) {
          // root is expandable if there exists any intersected path deeper than '/'
          rootExpandable = Array.from(intersectedPaths).some(p => p !== '/' && p.startsWith('/'));
        }
        const toggleHtmlRoot = rootExpandable ? `<div class="tree-toggle ${isRootSelected ? '' : 'collapsed'}" onclick="event.stopPropagation(); toggleGroupExpansion(event, '/')">‚ñ∂</div>` : `<div class="tree-toggle no-toggle"></div>`;
        const rootHtml = `<div class="tree-item group root-node ${isRootSelected ? 'expanded' : ''}" onclick="toggleGroup(event)" data-path="/"${fileAttr}>
          ${toggleHtmlRoot}
          <div class="tree-icon folder"></div>
          <div class="tree-label">/ (${escapeHtml(rootLabel)})</div>
        </div>`;
        childrenHtml.push(rootHtml);
        
        const rootChildrenStart = `<div class="tree-group-children ${isRootSelected ? 'expanded' : ''}" style="margin-left: 20px;">`;
        childrenHtml.push(rootChildrenStart);
      }
      
      try {
        let keys = [];
        try {
          if (typeof group.keys === 'function') {
            keys = Array.from(group.keys());
          }
          keys.sort();

          // If an intersect filter is active and its set is smaller than the
          // number of keys in this group, derive the allowed child names from
          // the intersect set (faster than scanning all keys for large groups).
          if (intersectedPaths && intersectedPaths.size > 0 && keys.length > 0 && intersectedPaths.size < keys.length) {
            const allowed = new Set();
            const prefixWithSlash = prefix === '' ? '/' : (prefix + '/');
            for (const p of intersectedPaths) {
              if (!p.startsWith(prefixWithSlash)) continue;
              const rest = p.substring(prefixWithSlash.length);
              const child = rest.split('/')[0];
              if (child) allowed.add(child);
            }
            if (allowed.size > 0) {
              keys = keys.filter(k => allowed.has(k));
            }
          }
        } catch (e) {
          console.error('Error getting keys:', e.message);
          if (prefix === '') {
            childrenHtml.push('</div>');
          }
          return childrenHtml.join('');
        }
        
        const topLevelLazy = !!lazyLoad && prefix === '';

        if (keys.length === 0) {
          if (prefix === '') {
            childrenHtml.push('<div style="color:#999;padding:8px;font-size:12px;">(empty)</div>');
            childrenHtml.push('</div>');
          }
          return childrenHtml.join('');
        }
        
        // yield periodically during long traversals so the browser can paint
        let _yieldCounter = 0;
        for (const key of keys) {
          try {
            const obj = group.get(key);
            if (!obj) continue;
            
            const path = prefix ? `${prefix}/${key}` : `/${key}`;
            const objType = String(obj.type).toLowerCase();
            
            // Skip this node if intersect is active and path is not in the intersection
            if (intersectedPaths && !intersectedPaths.has(path)) continue;
            
            // Detect link info for badge
            const linkInfo = getLinkInfo(group, path, obj);
            const linkBadge = buildLinkBadge(linkInfo);
            
            // Handle broken soft links ‚Äî cannot be traversed
            if (objType === 'brokensoftlink') {
              const isSelected = selectedDatasetPath === path && !selectedIsRadionuclidesGroup;
              const brokenHtml = `<div class="tree-item broken-link ${isSelected ? 'selected' : ''}" onclick="selectDataset('${path.replace(/'/g, "\\'")}', event)" data-path="${escapeHtml(path)}"${fileAttr}>
                <div class="tree-icon broken-link"></div>
                <div class="tree-label">${escapeHtml(key)}${linkBadge}</div>
                <div class="tree-meta" style="color:var(--color-kvot-accent);">broken link</div>
              </div>`;
              childrenHtml.push(brokenHtml);
              if (typeof progressCb === 'function') progressCb(1, path);
              continue;
            }
            
            // Handle external links ‚Äî show external file reference
            if (objType === 'externallink') {
              const isSelected = selectedDatasetPath === path && !selectedIsRadionuclidesGroup;
              const extLabel = linkInfo ? linkInfo.filename : '?';
              const externalHtml = `<div class="tree-item external-link ${isSelected ? 'selected' : ''}" onclick="selectDataset('${path.replace(/'/g, "\\'")}', event)" data-path="${escapeHtml(path)}"${fileAttr}>
                <div class="tree-icon external-link"></div>
                <div class="tree-label">${escapeHtml(key)}${linkBadge}</div>
                <div class="tree-meta">\u2192 ${escapeHtml(extLabel)}</div>
              </div>`;
              childrenHtml.push(externalHtml);
              if (typeof progressCb === 'function') progressCb(1, path);
              continue;
            }
            
            if (objType === 'group') {
              const isSelected = selectedDatasetPath === path && selectedIsRadionuclidesGroup;

              // determine whether this group has intersected descendants (if filter active)
              let groupExpandable = true;
              if (intersectedPaths) {
                // expandability means there is at least one intersected path that
                // equals this path or is a descendant of it
                groupExpandable = Array.from(intersectedPaths).some(p => p === path || p.startsWith(path + '/'));
              }

              const toggleHtml = groupExpandable ? `<div class="tree-toggle ${isSelected ? '' : 'collapsed'}" onclick="event.stopPropagation(); toggleGroupExpansion(event, '${path.replace(/'/g, "\\'")}')">‚ñ∂</div>` : `<div class="tree-toggle no-toggle"></div>`;

              const groupHtml = `<div class="tree-item group ${isSelected ? 'expanded' : ''}" onclick="toggleGroup(event)" data-path="${escapeHtml(path)}"${fileAttr}>
                  ${toggleHtml}
                  <div class="tree-icon folder"></div>
                  <div class="tree-label">${escapeHtml(key)}${linkBadge}</div>
                </div>`;
              childrenHtml.push(groupHtml);
              if (typeof progressCb === 'function') progressCb(1, path);

              try {
                if (topLevelLazy && prefix === '') {
                  // render an empty placeholder that will be populated when the
                  // user expands this group for the first time
                  const placeholder = `<div class="tree-group-children ${isSelected ? 'expanded' : ''}" data-lazy="true" data-loaded="false"></div>`;
                  childrenHtml.push(placeholder);
                } else {
                  const subItems = await buildTree(obj, path, true, '', intersectedPaths, fileKey, progressCb, false, (typeof maxDepth === 'number' ? maxDepth - 1 : Infinity));
                  let childrenWrapper = '';
                  if (subItems && String(subItems).trim() !== '') {
                    childrenWrapper = `<div class="tree-group-children ${isSelected ? 'expanded' : ''}">${subItems}</div>`;
                  } else {
                    // depth-limited/unrendered subtree ‚Äî if the group actually has children,
                    // show a lazy placeholder so further expansion can load them.
                    const hasChildren = (FileService.keys(obj) || []).length > 0;
                    if (hasChildren) {
                      childrenWrapper = `<div class="tree-group-children ${isSelected ? 'expanded' : ''}" data-lazy="true" data-loaded="false"></div>`;
                    } else {
                      childrenWrapper = `<div class="tree-group-children ${isSelected ? 'expanded' : ''}"><div style="color:#999;padding:8px;font-size:12px;">(empty)</div></div>`;
                    }
                  }
                  childrenHtml.push(childrenWrapper);
                }
              } catch (subErr) {
                console.error('Error getting sub-items for', key, subErr);
                const errorWrapper = `<div class="tree-group-children"><div style="color:red;padding:8px;font-size:12px;">(error: ${escapeHtml(subErr.message)})</div></div>`;
                childrenHtml.push(errorWrapper);
                if (typeof progressCb === 'function') progressCb(1, path);
              }
            } else if (objType === 'dataset') {
              const shape = obj.shape?.length ? `${obj.shape.join('√ó')}` : 'scalar';
              const formattedDtype = formatDataType(obj.dtype);
              const isSelected = selectedDatasetPath === path && !selectedIsRadionuclidesGroup;
              const datasetHtml = `<div class="tree-item dataset ${isSelected ? 'selected' : ''}" onclick="selectDataset('${path.replace(/'/g, "\\'")}', event)" data-path="${escapeHtml(path)}"${fileAttr}>
                <div class="tree-icon dataset"></div>
                <div class="tree-label">${escapeHtml(key)}${linkBadge}</div>
                <div class="tree-meta">${escapeHtml(formattedDtype)} [${escapeHtml(shape)}]</div>
              </div>`;
              childrenHtml.push(datasetHtml);
              if (typeof progressCb === 'function') progressCb(1, path);
            }
          } catch (e) {
            console.error('Error with key', key, ':', e.message);
            childrenHtml.push(`<div class="tree-item" style="color:red;font-size:12px;">‚ö†Ô∏è ${escapeHtml(key)}</div>`);
          }
          // yield every 50 items to keep UI responsive during large traversals
          if (++_yieldCounter % 50 === 0) await new Promise(r => setTimeout(r, 0));
        }
      } catch (e) {
        console.error('buildTree error:', e);
      }
      
      if (prefix === '') {
        childrenHtml.push('</div>');
      }
      
      return childrenHtml.join('');
    }


    /* ==========================================================================
       7. RADIONUCLIDE LINE STYLES
       ========================================================================== */
    
    /**
     * Get the line style (color, dash pattern) for a radionuclide isotope.
     * 
     * Predefined styles are provided for common isotopes in categories:
     * - Actinides (Ac, Am, Cm, Np, Pa, Pu, Th, U)
     * - Fission products (Ag, Cs, I, Pd, Se, Sm, Sn, Sr, Tc, Zr)
     * - Activation products (Be, C, Cl, Co, H, Ni, Nb, Mo)
     * - Other radionuclides (various)
     * 
     * Colors are chosen for visual distinction on both light backgrounds
     * and when multiple isotopes are plotted together.
     * 
     * @param {string} name - Isotope name (e.g., 'U-238', 'Cs-137', 'C-14-org')
     * @returns {{color: string|null, dash: string, width: number}} Line style object
     * 
     * @example
     * getLineStyle('U-238')  // { color: 'rgb(255,0,0)', dash: 'solid', width: 2 }
     * getLineStyle('unknown') // { color: null, dash: 'solid', width: 2 }
     */
    function getLineStyle(name) {
      const lineStyles = {
        // Actinides
        'Ac-227': { color: 'rgb(128,0,0)', dash: 'solid' },
        'Am-241': { color: 'rgb(72,209,204)', dash: 'dashdot' },
        'Am-242m': { color: 'rgb(72,209,204)', dash: 'dash' },
        'Am-243': { color: 'rgb(72,209,204)', dash: 'solid' },
        'Cm-242': { color: 'rgb(175,238,238)', dash: 'dash' },
        'Cm-243': { color: 'rgb(175,238,238)', dash: 'solid' },
        'Cm-244': { color: 'rgb(175,238,238)', dash: 'dot' },
        'Cm-245': { color: 'rgb(175,238,238)', dash: 'dash' },
        'Cm-246': { color: 'rgb(175,238,238)', dash: 'dashdot' },
        'Np-237': { color: 'rgb(218,165,32)', dash: 'solid' },
        'Pa-231': { color: 'rgb(85,107,47)', dash: 'solid' },
        'Pu-238': { color: 'rgb(0,255,255)', dash: 'dot' },
        'Pu-239': { color: 'rgb(0,255,255)', dash: 'solid' },
        'Pu-240': { color: 'rgb(0,255,255)', dash: 'dash' },
        'Pu-241': { color: 'rgb(0,255,255)', dash: 'dashdot' },
        'Pu-242': { color: 'rgb(0,255,255)', dash: 'dash' },
        'Th-228': { color: 'rgb(75,0,130)', dash: 'dash' },
        'Th-229': { color: 'rgb(75,0,130)', dash: 'dot' },
        'Th-230': { color: 'rgb(75,0,130)', dash: 'solid' },
        'Th-232': { color: 'rgb(75,0,130)', dash: 'dash' },
        'U-232': { color: 'rgb(255,0,0)', dash: 'longdash' },
        'U-233': { color: 'rgb(255,0,0)', dash: 'dash' },
        'U-234': { color: 'rgb(255,0,0)', dash: 'dot' },
        'U-235': { color: 'rgb(255,0,0)', dash: 'dash' },
        'U-236': { color: 'rgb(255,0,0)', dash: 'dashdot' },
        'U-238': { color: 'rgb(255,0,0)', dash: 'solid' },
        
        // Fission products
        'Ag-108m': { color: 'rgb(128,128,0)', dash: 'solid' },
        'Cs-135': { color: 'rgb(0,128,0)', dash: 'solid' },
        'Cs-137': { color: 'rgb(0,128,0)', dash: 'dash' },
        'I-129': { color: 'rgb(30,144,255)', dash: 'solid' },
        'Pd-107': { color: 'rgb(216,191,216)', dash: 'solid' },
        'Se-79': { color: 'rgb(112,128,144)', dash: 'solid' },
        'Sm-151': { color: 'rgb(138,43,226)', dash: 'solid' },
        'Sn-126': { color: 'rgb(0,0,0)', dash: 'solid' },
        'Sr-90': { color: 'rgb(255,215,0)', dash: 'solid' },
        'Tc-99': { color: 'rgb(0,0,128)', dash: 'solid' },
        'Zr-93': { color: 'rgb(144,238,144)', dash: 'solid' },
        
        // Activation products
        'Be-10': { color: 'rgb(65,105,225)', dash: 'solid' },
        'C-14': { color: 'rgb(0,0,255)', dash: 'solid' },
        'C-14-org': { color: 'rgb(0,0,255)', dash: 'solid' },
        'C-14-ind': { color: 'rgb(0,0,255)', dash: 'dash' },
        'C-14-inorg': { color: 'rgb(0,0,255)', dash: 'dot' },
        'Cl-36': { color: 'rgb(210,105,30)', dash: 'solid' },
        'Co-60': { color: 'rgb(0,255,127)', dash: 'solid' },
        'H-3': { color: 'rgb(0,0,205)', dash: 'solid' },
        'Ni-59': { color: 'rgb(255,0,255)', dash: 'solid' },
        'Ni-63': { color: 'rgb(255,0,255)', dash: 'dash' },
        'Nb-93m': { color: 'rgb(210,180,140)', dash: 'solid' },
        'Nb-94': { color: 'rgb(210,180,140)', dash: 'dash' },
        'Mo-93': { color: 'rgb(0,255,0)', dash: 'solid' },
        
        // Other radionuclides
        'Ar-39': { color: 'rgb(152,251,152)', dash: 'solid' },
        'Ba-133': { color: 'rgb(70,130,180)', dash: 'solid' },
        'Ca-41': { color: 'rgb(128,0,128)', dash: 'solid' },
        'Cd-113m': { color: 'rgb(124,252,0)', dash: 'solid' },
        'Eu-150': { color: 'rgb(205,133,63)', dash: 'dash' },
        'Eu-152': { color: 'rgb(205,133,63)', dash: 'solid' },
        'Gd-148': { color: 'rgb(255,255,0)', dash: 'solid' },
        'Ho-166m': { color: 'rgb(100,149,237)', dash: 'solid' },
        'K-40': { color: 'rgb(139,69,19)', dash: 'solid' },
        'La-137': { color: 'rgb(255,248,220)', dash: 'solid' },
        'Pb-210': { color: 'rgb(148,0,211)', dash: 'dash' },
        'Po-210': { color: 'rgb(148,0,211)', dash: 'dot' },
        'Ra-226': { color: 'rgb(148,0,211)', dash: 'solid' },
        'Ra-228': { color: 'rgb(148,0,211)', dash: 'dash' },
        'Re-186m': { color: 'rgb(255,160,122)', dash: 'solid' },
        'Si-32': { color: 'rgb(255,228,181)', dash: 'solid' },
        'Tb-157': { color: 'rgb(221,160,221)', dash: 'solid' },
        'Tb-158': { color: 'rgb(221,160,221)', dash: 'dash' },
        'Ti-44': { color: 'rgb(218,112,214)', dash: 'solid' }
      };
      
      const defaultStyle = { color: null, dash: 'solid', width: 2 };
      
      if (name in lineStyles) {
        return { ...defaultStyle, ...lineStyles[name] };
      }
      
      return defaultStyle;
    }


    /* ==========================================================================
       8. CHART CONTROLS
       ========================================================================== */
    
    /**
     * Update the chart axis scales based on dropdown selections.
     * Applies new scale types (linear/log) without rebuilding the entire chart.
     * 
     * @returns {void}
     */
    function updateChartScales() {
      if (!currentChartData) return;
      
      const xScale = document.getElementById('xAxisScale').value;
      const yScale = document.getElementById('yAxisScale').value;
      
      const update = {
        'xaxis.type': xScale,
        'yaxis.type': yScale
      };
      
      Plotly.relayout('plotlyChart', update);
    }

    /**
     * Apply preset axis ranges optimized for viewing release data.
     * Sets both axes to log scale with ranges suitable for radionuclide releases.
     * X-axis: 100 - 100,000 (years)
     * Y-axis: 10,000 - 1e9 (activity units)
     * 
     * @returns {void}
     */
    function applyReleasePresetView() {
      if (!currentChartData) return;
      
      document.getElementById('xAxisScale').value = 'log';
      document.getElementById('yAxisScale').value = 'log';
      
      const update = {
        'xaxis.type': 'log',
        'xaxis.range': [Math.log10(100), Math.log10(100000)],
        'yaxis.type': 'log',
        'yaxis.range': [Math.log10(10000), Math.log10(1e9)]
      };
      
      Plotly.relayout('plotlyChart', update);
    }

    /**
     * Apply preset axis ranges optimized for viewing dose data.
     * Sets both axes to log scale with ranges suitable for dose rates.
     * X-axis: 1,000 - 100,000 (years)
     * Y-axis: 1e-10 - 1e-5 (Sv/year or similar units)
     * 
     * @returns {void}
     */
    function applyDosePresetView() {
      if (!currentChartData) return;
      
      document.getElementById('xAxisScale').value = 'log';
      document.getElementById('yAxisScale').value = 'log';
      
      const update = {
        'xaxis.type': 'log',
        'xaxis.range': [Math.log10(1000), Math.log10(1e5)],
        'yaxis.type': 'log',
        'yaxis.range': [Math.log10(1e-10), Math.log10(1e-5)]
      };
      
      Plotly.relayout('plotlyChart', update);
    }

    /**
     * Export current chart data to a CSV file.
     * Creates a downloadable file with columns: Series, X, Y.
     * Each trace in the chart becomes a series in the CSV.
     * 
     * @returns {void}
     */
    function downloadChartData() {
      if (!currentChartData) {
        alert('No chart data available');
        return;
      }
      
      let csv = 'Series,X,Y\n';
      
      for (const trace of currentChartData.traces) {
        const name = trace.name;
        for (let i = 0; i < trace.x.length; i++) {
          csv += `"${name}",${trace.x[i]},${trace.y[i]}\n`;
        }
      }
      
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `chart_data_${Date.now()}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    /**
     * Export current chart data to an Excel file (.xlsx).
     * Creates a workbook with two sheets:
     * - "Chart": Contains a native Excel scatter chart with the same look as Plotly
     * - "Data": Contains the chart data with time column and one column per trace
     * 
     * Uses xlsxwrite.js for native Excel chart creation with full feature support.
     * Creates a chart that matches the Plotly chart styling:
     * - Same axis type (log/linear) with proper logarithmic scale support
     * - Same line colors from traces
     * - Same dash patterns (solid, dash, dot, dashdot, longdash)
     * - Gridlines matching the Plotly style
     * - Lines without markers
     * 
     * @returns {Promise<void>}
     */
    async function downloadChartDataAsExcel() {
      if (!currentChartData) {
        alert('No chart data available');
        return;
      }
      
      // Check if xlsxwrite.js is ready
      if (!window.xlsxReady || !window.XlsxWriter) {
        alert('Excel export library is not loaded. Please refresh the page.');
        return;
      }
      
      try {
        const allTraces = currentChartData.traces;
        const layout = currentChartData.layout;
        
        // Get current state from the actual Plotly chart element
        const chartDiv = document.getElementById('plotlyChart');
        const plotlyTraces = chartDiv && chartDiv.data ? chartDiv.data : allTraces;
        const plotlyLayout = chartDiv && chartDiv.layout ? chartDiv.layout : layout;
        
        // Check if Dynamic Legend is enabled and we should filter by viewport
        const dynamicLegendCheckbox = document.getElementById('dynamicLegend');
        const isDynamicLegendEnabled = dynamicLegendCheckbox && dynamicLegendCheckbox.checked;
        
        let traces;
        
        if (isDynamicLegendEnabled && plotlyLayout.xaxis && plotlyLayout.yaxis) {
          // Filter traces based on whether they have data points in the current viewport
          const xRange = plotlyLayout.xaxis.range;
          const yRange = plotlyLayout.yaxis.range;
          
          if (xRange && yRange) {
            const xIsLog = plotlyLayout.xaxis.type === 'log';
            const yIsLog = plotlyLayout.yaxis.type === 'log';
            
            const xMin = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
            const xMax = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
            const yMin = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
            const yMax = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
            
            traces = plotlyTraces.filter(trace => {
              // Check if trace has any data points in the current viewport
              for (let j = 0; j < trace.x.length; j++) {
                const x = trace.x[j];
                const y = trace.y[j];
                if (x !== null && x !== undefined && y !== null && y !== undefined) {
                  if (x >= xMin && x <= xMax && y >= yMin && y <= yMax) {
                    return true;
                  }
                }
              }
              return false;
            });
          } else {
            traces = plotlyTraces;
          }
        } else {
          // Dynamic Legend off - export all traces (or filter by visible property)
          traces = plotlyTraces.filter(trace => {
            const visible = trace.visible;
            return visible === undefined || visible === true;
          });
        }
        
        if (traces.length === 0) {
          alert('No visible traces to export. Please show at least one trace in the chart.');
          return;
        }
        
        // Find the longest x array to determine row count
        const maxLength = Math.max(...traces.map(t => t.x ? t.x.length : 0));
        
        // Extract chart metadata
        const chartTitle = layout && layout.title && layout.title.text 
          ? layout.title.text 
          : 'Chart Data';
        const xAxisTitle = layout && layout.xaxis && layout.xaxis.title && layout.xaxis.title.text
          ? layout.xaxis.title.text
          : 'Time';
        const yAxisTitle = layout && layout.yaxis && layout.yaxis.title && layout.yaxis.title.text
          ? layout.yaxis.title.text
          : 'Value';
        
        // Detect axis types from Plotly layout
        const xAxisType = plotlyLayout && plotlyLayout.xaxis && plotlyLayout.xaxis.type ? plotlyLayout.xaxis.type : 'linear';
        const yAxisType = plotlyLayout && plotlyLayout.yaxis && plotlyLayout.yaxis.type ? plotlyLayout.yaxis.type : 'linear';
        
        // Helper function to parse rgb color string to [R, G, B] array
        const parseRgbColor = (colorStr) => {
          if (!colorStr) return null;
          // Handle rgb(r,g,b) format
          const rgbMatch = colorStr.match(/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i);
          if (rgbMatch) {
            return [parseInt(rgbMatch[1]), parseInt(rgbMatch[2]), parseInt(rgbMatch[3])];
          }
          // Handle hex format #RRGGBB or RRGGBB
          const hexMatch = colorStr.match(/#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
          if (hexMatch) {
            return [parseInt(hexMatch[1], 16), parseInt(hexMatch[2], 16), parseInt(hexMatch[3], 16)];
          }
          // Handle short hex format #RGB
          const shortHexMatch = colorStr.match(/^#?([a-f\d])([a-f\d])([a-f\d])$/i);
          if (shortHexMatch) {
            return [
              parseInt(shortHexMatch[1] + shortHexMatch[1], 16),
              parseInt(shortHexMatch[2] + shortHexMatch[2], 16),
              parseInt(shortHexMatch[3] + shortHexMatch[3], 16)
            ];
          }
          return null;
        };
        
        // Map Plotly dash type to Excel dash type (using sys variants for standard Excel look)
        const mapDashType = (plotlyDash) => {
          if (!plotlyDash || plotlyDash === 'solid') return 'solid';
          switch (plotlyDash) {
            case 'dash': return 'sysDash';
            case 'dot': return 'sysDot';
            case 'dashdot': return 'sysDashDot';
            case 'longdash': return 'lgDash';
            case 'longdashdot': return 'lgDashDot';
            default: return 'solid';
          }
        };
        
        // Fallback Plotly-like color palette (brighter colors)
        const plotlyColors = [
          [0x1F, 0x77, 0xB4], // blue
          [0xFF, 0x7F, 0x0E], // orange
          [0x2C, 0xA0, 0x2C], // green
          [0xD6, 0x27, 0x28], // red
          [0x94, 0x67, 0xBD], // purple
          [0x8C, 0x56, 0x4B], // brown
          [0xE3, 0x77, 0xC2], // pink
          [0x7F, 0x7F, 0x7F], // gray
          [0xBC, 0xBD, 0x22], // olive
          [0x17, 0xBE, 0xCF]  // cyan
        ];
        
        // Create workbook using xlsxwrite.js
        const xlsx = new XlsxWriter();
        
        // Plotly-like gridline color (light gray)
        const gridColor = 'E5ECF6';
        const minorGridColor = 'EEF2F8';
        
        // ============ CREATE CHART ============
        // Configure chart with axis settings
        const chartConfig = {
          width: 800,
          height: 500,
          scatterStyle: 'line',  // Line without markers
          showBorder: false,     // Remove chart border
          xAxis: {
            title: { text: xAxisTitle },
            numberFormat: '[>1000]### ### ### ##0;General',
            fontSize: 9,
            majorGridlines: { color: gridColor, width: 0.75 }
          },
          yAxis: {
            title: { text: yAxisTitle, customAngle: -90 },
            numberFormat: '0E+0',
            fontSize: 9,
            majorGridlines: { color: gridColor, width: 0.75 }
          },
          legend: { position: 'r', fontSize: 8 }
        };
        
        // Set logarithmic scale if Plotly uses it, and add minor gridlines/ticks
        if (xAxisType === 'log') {
          chartConfig.xAxis.logBase = 10;
          chartConfig.xAxis.minorGridlines = { color: minorGridColor, width: 0.5 };
          chartConfig.xAxis.minorTickMark = 'out';
        }
        if (yAxisType === 'log') {
          chartConfig.yAxis.logBase = 10;
          chartConfig.yAxis.minorGridlines = { color: minorGridColor, width: 0.5 };
          chartConfig.yAxis.minorTickMark = 'out';
        }
        
        // Set axis min/max to match current Plotly view
        // For log scale: always set limits (needed for proper scaling)
        // For linear scale: only set limits if user has zoomed (autorange is false)
        if (plotlyLayout.xaxis && plotlyLayout.xaxis.range) {
          const xRange = plotlyLayout.xaxis.range;
          const xIsLog = xAxisType === 'log';
          const xIsZoomed = plotlyLayout.xaxis.autorange === false;
          if (xIsLog || xIsZoomed) {
            chartConfig.xAxis.minimum = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
            chartConfig.xAxis.maximum = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
          }
        }
        if (plotlyLayout.yaxis && plotlyLayout.yaxis.range) {
          const yRange = plotlyLayout.yaxis.range;
          const yIsLog = yAxisType === 'log';
          const yIsZoomed = plotlyLayout.yaxis.autorange === false;
          if (yIsLog || yIsZoomed) {
            chartConfig.yAxis.minimum = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
            chartConfig.yAxis.maximum = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
          }
        }
        
        const chart = xlsx.newChart(chartConfig);
        
        // Get x values from the first trace
        const xValues = traces.length > 0 && traces[0].x ? traces[0].x : [];
        
        // Add series to chart
        traces.forEach((trace, idx) => {
          // Get color from trace or use fallback
          let color = plotlyColors[idx % plotlyColors.length];
          const traceColor = trace.line?.color || trace.marker?.color || null;
          if (traceColor) {
            const parsedColor = parseRgbColor(traceColor);
            if (parsedColor) {
              color = parsedColor;
            }
          }
          
          // Get dash type from trace
          const dashType = mapDashType(trace.line?.dash);
          
          // Get line width from trace (default to 2 if not specified)
          const lineWidth = trace.line?.width || 2;
          
          // Filter out null/undefined values
          const yVals = trace.y || [];
          const xVals = trace.x || xValues;
          
          // Create series with xlsxwrite.js
          const series = xlsx.newSeries({
            name: { text: trace.name || `Series ${idx + 1}` },
            x: { values: xVals.map(v => v === null || v === undefined ? NaN : v) },
            y: { values: yVals.map(v => v === null || v === undefined ? NaN : v) },
            length: Math.max(xVals.length, yVals.length),
            line: {
              color: { option: 'Solid', value: color },
              width: lineWidth,
              dashType: dashType,
              capType: 'rnd',
              compoundType: 'sng',
              joinType: 'round',
              beginType: 'none',
              endType: 'none'
            },
            marker: { option: 'NoMarker' }
          });
          
          chart.series.push(series);
        });
        
        // ============ PREPARE DATA ============
        // Build data array with headers
        const headers = ['Time', ...traces.map((t, i) => t.name || `Series ${i + 1}`)];
        const dataRows = [];
        
        for (let i = 0; i < maxLength; i++) {
          const row = [xValues[i] !== undefined ? xValues[i] : null];
          traces.forEach(trace => {
            row.push(trace.y && trace.y[i] !== undefined ? trace.y[i] : null);
          });
          dataRows.push(row);
        }
        
        // Position chart to the right of the data (after all data columns)
        chart.x = (traces.length + 2) * 64;  // Offset by number of columns + margin
        chart.y = 0;
        
        // Write Data sheet with both data AND chart
        xlsx.writeData([headers, ...dataRows], 'Data', { chart: chart });
        
        // Generate filename
        const safeTitle = chartTitle.replace(/[^a-z0-9]/gi, '_').substring(0, 50);
        const filename = `${safeTitle}_${Date.now()}.xlsx`;
        
        // Save and download the file
        await xlsx.saveAs(filename);
        
      } catch (err) {
        console.error('Excel export failed:', err);
        alert('Failed to export to Excel: ' + err.message);
      }
    }
    
    /**
     * Handle "Show Total" checkbox toggle for radionuclides charts.
     * When checked, adds a trace showing the sum of all radionuclide activities.
     * Only applicable when viewing a radionuclides group.
     * 
     * @returns {void}
     */
    function toggleShowTotal() {
      if (selectedIsRadionuclidesGroup && selectedDatasetPath) {
        const savedAxis = captureAxisState();
        createRadionuclidesChart(selectedDatasetPath, savedAxis);
      }
    }

    /**
     * Handle "Show Ratio" checkbox toggle for radionuclides charts.
     * When checked, appends the ratio of max values (thick/thin) to the legend
     * name of thick-line traces.
     * 
     * @returns {void}
     */
    function toggleShowRatio() {
      if (selectedIsRadionuclidesGroup && selectedDatasetPath) {
        const savedAxis = captureAxisState();
        createRadionuclidesChart(selectedDatasetPath, savedAxis);
      }
    }


    /* ==========================================================================
       9. CHART CREATION
       ========================================================================== */
    
    /**
     * Create a Plotly chart for a single time-dependent dataset.
     * Plots the dataset from all enabled files as separate traces,
     * allowing comparison across files.
     * 
     * @param {string} path - HDF5 path to the dataset
     * @returns {void}
     */
    function createPlotlyChart(path) {
      const plotDiv = getElement('plotlyChart');
      const chartContainer = getElement('plotlyChartContainer');
      plotDiv.innerHTML = '';

      // Hide "Show Total" and "Show Ratio" checkboxes (only for radionuclides groups)
      setShowTotalVisible(false);
      setShowRatioVisible(false);

      const traces = [];
      const enabledFiles = getEffectiveFiles();

      let timeUnit = '';
      let yAxisUnit = '';
      let yAxisName = path.split('/').pop();

      if (enabledFiles.length > 0) {
        const firstFile = loadedFiles[enabledFiles[0]];
        timeUnit = getTimeUnit(firstFile);

        // Get y-axis unit from the first file's dataset (best-effort)
        try {
          const dataset = FileService.get(firstFile, path);
          if (dataset && dataset.attrs && typeof dataset.attrs === 'object') {
            for (const attrName in dataset.attrs) {
              if (attrName === 'unit') {
                const attrObj = dataset.attrs[attrName];
                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                  yAxisUnit = attrObj.value;
                }
              }
            }
          }
        } catch (e) {
          console.warn('Could not read unit from dataset:', e);
        }
      }

      // Build traces for each enabled file
      for (const fileKey of enabledFiles) {
        const file = loadedFiles[fileKey];

        if (!checkDatasetExistsInFile(file, path)) {
          continue;
        }

        try {
          const dataset = FileService.get(file, path);

          if (!isTimeDependent(dataset)) {
            continue;
          }

          const timeData = getTimeData(file);
          if (!timeData) {
            console.warn(`No /time dataset found in ${fileKey}`);
            continue;
          }

          let yData;
          if (typeof dataset.value !== 'undefined') {
            yData = dataset.value;
          } else if (typeof dataset.toArray === 'function') {
            yData = dataset.toArray();
          }

          if (yData) {
            let yArray = PDFSampler.normalizeDataArray(yData);

            // Handle probabilistic data (take mean)
            if (checkIsProbabilistic(dataset)) {
              yArray = computeProbabilisticMean(yArray, timeData);
            }

            // Handle length mismatch
            const minLength = Math.min(timeData.length, yArray.length);
            if (timeData.length !== yArray.length) {
              console.warn(`Time data length (${timeData.length}) doesn't match data length (${yArray.length}) for ${fileKey}`);
            }

            traces.push(ChartService.timeSeriesTrace({ x: timeData.slice(0, minLength), y: yArray.slice(0, minLength), name: fileKey }));
          }
        } catch (e) {
          console.error(`Error creating trace for ${fileKey}:`, e);
        }
      }

      // Render chart if we have data
      if (traces.length > 0) {
        const { xScale, yScale } = getChartScales();

        let yAxisTitle = 'Value';
        if (yAxisUnit) {
          yAxisTitle = `Value (${yAxisUnit})`;
        }

        const paths = [path];
        const layout = ChartService.createBaseLayout({
          title: path,
          xAxisTitle: timeUnit ? `Time (${timeUnit})` : 'Time',
          yAxisTitle,
          xScale,
          yScale
        });
        layout.margin.r = 200; // Extra room for longer legend names

        const config = getPlotlyConfig('multi_dataset_chart');

        currentChartData = { traces, layout, paths };
        const container = getElement('plotlyChartContainer');
        if (container) container.classList.add('visible');
        if (dynamicLegendEnabled) {
          assignLegendRanks(traces);
        }
        Plotly.newPlot('plotlyChart', traces, layout, config).then(() => {
          setupDynamicLegend(getElement('plotlyChart'));
        });
      } else {
        hideChart();
      }
    }

    /**
     * Create a Plotly chart comparing multiple selected datasets.
     * Each selection item carries its own fileKey so cross-file comparisons work.
     * 
     * Used in multi-select mode (Ctrl+click on datasets, possibly from different files).
     * 
     * @param {{path: string, fileKey: string|null}[]} items - Array of selected dataset items
     * @returns {void}
     */
    function createMultiDatasetChart(items) {
      const plotDiv = getElement('plotlyChart');
      const chartContainer = getElement('plotlyChartContainer');
      plotDiv.innerHTML = '';
      
      // Hide "Show Total" and "Show Ratio" checkboxes (only for radionuclides groups)
      setShowTotalVisible(false);
      setShowRatioVisible(false);
      
      const traces = [];
      const yAxisUnits = new Set();
      let timeUnit = '';
      
      // Normalize items: if fileKey is null (intersect mode), expand to all enabled files
      const normalizedItems = [];
      for (const item of items) {
        if (item.fileKey && loadedFiles[item.fileKey]) {
          normalizedItems.push(item);
        } else {
          // Intersect mode ‚Äî expand to all enabled files
          for (const fk of getEnabledFiles()) {
            normalizedItems.push({ path: item.path, fileKey: fk });
          }
        }
      }
      
      // Collect unique file keys from items
      const uniqueFileKeys = [...new Set(normalizedItems.map(d => d.fileKey).filter(Boolean))];
      if (uniqueFileKeys.length === 0) return hideChart();
      
      // Use first file for time unit
      const firstFile = loadedFiles[uniqueFileKeys[0]];
      if (firstFile) timeUnit = getTimeUnit(firstFile);
      
      // Color palette for different datasets
      const colors = [
        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
        '#1abc9c', '#e67e22', '#34495e', '#c0392b', '#2980b9',
        '#27ae60', '#f1c40f', '#8e44ad', '#16a085', '#d35400'
      ];
      
      // Unique paths for color assignment
      const uniquePaths = [...new Set(normalizedItems.map(d => d.path))];
      const multiFile = uniqueFileKeys.length > 1;
      const multiPath = uniquePaths.length > 1;
      
      for (const [itemIndex, item] of normalizedItems.entries()) {
        const { path, fileKey } = item;
        const datasetName = path.split('/').pop();
        const pathIdx = uniquePaths.indexOf(path);
        const baseColor = colors[pathIdx % colors.length];
        
        const file = loadedFiles[fileKey];
        if (!file || !checkDatasetExistsInFile(file, path)) continue;
        
        try {
          const dataset = FileService.get(file, path);
          if (!isTimeDependent(dataset)) continue;
          
          // Get unit
          let yAxisUnit = '';
          if (dataset.attrs && typeof dataset.attrs === 'object') {
            for (const attrName in dataset.attrs) {
              if (attrName === 'unit') {
                const attrObj = dataset.attrs[attrName];
                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                  yAxisUnit = attrObj.value;
                  yAxisUnits.add(yAxisUnit);
                }
              }
            }
          }
          
          const timeData = getTimeData(file);
          if (!timeData) {
            console.warn(`No /time dataset found in ${fileKey}`);
            continue;
          }
          
          let yData;
          if (typeof dataset.value !== 'undefined') {
            yData = dataset.value;
          } else if (typeof dataset.toArray === 'function') {
            yData = dataset.toArray();
          }
          
          if (yData) {
            let yArray = PDFSampler.normalizeDataArray(yData);
            
            // Handle probabilistic data (take mean)
            if (checkIsProbabilistic(dataset)) {
              yArray = computeProbabilisticMean(yArray, timeData);
            }

            const minLength = Math.min(timeData.length, yArray.length);
            const trimmedTimeData = timeData.slice(0, minLength);
            const trimmedYData = yArray.slice(0, minLength);
            
            // Build trace name ‚Äî show file label when multiple files, path when multiple paths
            let traceName = datasetName;
            let lineWidth = 2;
            let lineDash = 'solid';
            
            if (multiFile && multiPath) {
              const diffLabel = filenameDiff(uniqueFileKeys[0], fileKey);
              traceName = `${datasetName} (${diffLabel})`;
            } else if (multiFile) {
              traceName = fileKey;
            }
            // else just datasetName for single-file multi-path
            
            if (multiFile) {
              const fileIdx = uniqueFileKeys.indexOf(fileKey);
              const dashStyles = ['solid', 'dash', 'dot', 'dashdot'];
              lineDash = dashStyles[fileIdx % dashStyles.length];
              lineWidth = 1.5;
            }
            
            traces.push(ChartService.timeSeriesTrace({ x: trimmedTimeData, y: trimmedYData, name: traceName, line: { color: baseColor, dash: lineDash, width: lineWidth }, hovertemplate: `<b>${traceName}</b><br>Time: %{x}<br>Value: %{y}<extra></extra>` }));
          }
        } catch (e) {
          console.error(`Error creating trace for ${path} in ${fileKey}:`, e);
        }
      }
      
      if (traces.length > 0) {
        const { xScale, yScale } = getChartScales();
        
        let yAxisTitle = 'Value';
        if (yAxisUnits.size === 1) {
          yAxisTitle = `Value (${Array.from(yAxisUnits)[0]})`;
        } else if (yAxisUnits.size > 1) {
          yAxisTitle = `Value (${Array.from(yAxisUnits).join(', ')})`;
        }
        
        const paths = normalizedItems.map(d => d.path);
        const layout = ChartService.createBaseLayout({
          title: `Comparing ${normalizedItems.length} dataset${normalizedItems.length > 1 ? 's' : ''}`,
          xAxisTitle: timeUnit ? `Time (${timeUnit})` : 'Time',
          yAxisTitle,
          xScale,
          yScale
        });
        layout.margin.r = 200; // Extra room for longer legend names
        
        const config = getPlotlyConfig('multi_dataset_chart');

        currentChartData = { traces, layout, paths };
        const container = getElement('plotlyChartContainer');
        if (container) container.classList.add('visible');
        if (dynamicLegendEnabled) {
          assignLegendRanks(traces);
        }
        Plotly.newPlot('plotlyChart', traces, layout, config).then(() => {
          setupDynamicLegend(getElement('plotlyChart'));
        });
      } else {
        hideChart();
      }
    }

    /**
     * Create a Plotly chart for a radionuclides data group.
     * Plots all child datasets (isotopes) with predefined line styles.
     * 
     * Features:
     * - Each isotope uses its characteristic color and dash pattern
     * - "Show Total" checkbox adds a summed trace
     * - Supports multi-file comparison with thinner lines for secondary files
     * 
     * @param {string} path - HDF5 path to the radionuclides group
     * @returns {void}
     */
    function createRadionuclidesChart(path, savedAxisState) {
      const plotDiv = getElement('plotlyChart');
      const chartContainer = getElement('plotlyChartContainer');
      plotDiv.innerHTML = '';
      
      // Show "Show Total" checkbox for radionuclides groups
      setShowTotalVisible(true);
      
      const traces = [];
      const enabledFiles = getEffectiveFiles();
      
      // Show "Show Ratio" checkbox only when exactly 2 files are enabled (thick + thin lines)
      // and secondary file has data for this path ‚Äî will be set after building traces
      const hasTwoFiles = enabledFiles.length === 2;
      setShowRatioVisible(false);
      
      // Store data for computing total
      const totalDataByFile = {};
      
      // Track the starting index of each file's traces in the traces array
      const fileTraceStartIndex = {};

      let timeUnit = '';
      let yAxisUnit = '';
      let yAxisName = path.split('/').pop();
      
      if (enabledFiles.length > 0) {
        const firstFile = loadedFiles[enabledFiles[0]];
        timeUnit = getTimeUnit(firstFile);
      }
      
      // Build traces for each file and each radionuclide
      for (const fileKey of enabledFiles) {
        const file = loadedFiles[fileKey];
        
        // Record where this file's traces begin
        fileTraceStartIndex[fileKey] = traces.length;
        
        if (!checkDatasetExistsInFile(file, path)) {
          continue;
        }
        
        try {
          const group = FileService.get(file, path);
          if (!group || group.type.toLowerCase() !== 'group') {
            continue;
          }
          
          const timeData = getTimeData(file);
          if (!timeData) {
            console.warn(`No /time dataset found in ${fileKey}`);
            continue;
          }
          
          let datasetKeys = [];
          try {
            if (typeof group.keys === 'function') {
              datasetKeys = Array.from(group.keys());
            }
          } catch (e) {
            console.error('Error getting dataset keys:', e);
            continue;
          }
          
          for (const datasetKey of datasetKeys) {
            try {
              const dataset = group.get(datasetKey);
              if (!dataset || dataset.type.toLowerCase() !== 'dataset') {
                continue;
              }
              
              let yData;
              if (typeof dataset.value !== 'undefined') {
                yData = dataset.value;
              } else if (typeof dataset.toArray === 'function') {
                yData = dataset.toArray();
              }
              
              if (yData) {
                let yArray = PDFSampler.normalizeDataArray(yData);
                
                // Handle probabilistic data
                if (checkIsProbabilistic(dataset)) {
                  yArray = computeProbabilisticMean(yArray, timeData);
                }

                const minLength = Math.min(timeData.length, yArray.length);
                const trimmedTimeData = timeData.slice(0, minLength);
                const trimmedYData = yArray.slice(0, minLength);
                
                // Store data for computing total
                if (!totalDataByFile[fileKey]) {
                  totalDataByFile[fileKey] = { timeData: trimmedTimeData, dataArrays: [] };
                }
                totalDataByFile[fileKey].dataArrays.push(trimmedYData);
                
                // Get line style for this radionuclide
                const lineStyle = getLineStyle(datasetKey);
                let traceName = datasetKey;
                let lineWidth = lineStyle.width;
                
                if (enabledFiles.length > 1 && enabledFiles.indexOf(fileKey) > 0) {
                  traceName = `${datasetKey} (${filenameDiff(enabledFiles[0], fileKey)})`;
                  lineWidth = lineWidth / 2;
                }
                
                traces.push(ChartService.timeSeriesTrace({ x: trimmedTimeData, y: trimmedYData, name: traceName, line: { color: lineStyle.color, dash: lineStyle.dash, width: lineWidth } }));
              }
            } catch (e) {
              console.error(`Error creating trace for ${datasetKey} in ${fileKey}:`, e);
            }
          }
        } catch (e) {
          console.error(`Error processing group for ${fileKey}:`, e);
        }
      }
      
      // Now that traces are built, show "Show Ratio" only if both files contributed data
      if (hasTwoFiles) {
        const secondaryFile = enabledFiles[1];
        const secondaryStart = fileTraceStartIndex[secondaryFile] != null ? fileTraceStartIndex[secondaryFile] : traces.length;
        const secondaryHasTraces = secondaryStart < traces.length;
        setShowRatioVisible(secondaryHasTraces);
      }

      // Collect max values per radionuclide per file (needed for ratio display)
      const showRatioCheckbox = getElement('showRatio');
      const showRatioChecked = hasTwoFiles && showRatioCheckbox && showRatioCheckbox.checked;
      const maxByFileAndName = {}; // { datasetKey: { fileKey: maxVal } }
      if (showRatioChecked) {
        for (const fileKey of enabledFiles) {
          const fileData = totalDataByFile[fileKey];
          if (!fileData) continue;
          const file = loadedFiles[fileKey];
          const group = FileService.get(file, path);
          let datasetKeys = [];
          try {
            if (typeof group.keys === 'function') {
              datasetKeys = Array.from(group.keys());
            }
          } catch (e) { /* ignore */ }
          // Match datasetKeys to dataArrays by index
          for (let i = 0; i < datasetKeys.length && i < fileData.dataArrays.length; i++) {
            const key = datasetKeys[i];
            const arr = fileData.dataArrays[i];
            const maxVal = Math.max(...arr);
            if (!maxByFileAndName[key]) maxByFileAndName[key] = {};
            maxByFileAndName[key][fileKey] = maxVal;
          }
        }
      }

      const primaryFile = enabledFiles[0];
      const secondaryFile = hasTwoFiles ? enabledFiles[1] : null;

      /**
       * Format a ratio value to a display string (3 significant digits).
       * @param {number} ratio
       * @returns {string}
       */
      function formatRatio(ratio) {
        if (ratio === 0 || !isFinite(ratio)) return ratio.toString();
        return ratio.toPrecision(3);
      }

      // Add total traces, each at the top of its corresponding file's group in the legend
      const showTotalCheckbox = getElement('showTotal');
      if (showTotalCheckbox && showTotalCheckbox.checked) {
        // Compute total per file and collect total max values for ratio
        const totalMaxByFile = {}; // { fileKey: maxTotalValue }
        const totalTracesByFile = {}; // { fileKey: traceObject }
        for (const fileKey of Object.keys(totalDataByFile)) {
          const fileData = totalDataByFile[fileKey];
          if (fileData.dataArrays.length > 0) {
            const timeData = fileData.timeData;
            const totalY = new Array(timeData.length).fill(0);
            
            // Sum all data arrays
            for (const dataArray of fileData.dataArrays) {
              for (let i = 0; i < Math.min(dataArray.length, totalY.length); i++) {
                totalY[i] += dataArray[i];
              }
            }
            
            totalMaxByFile[fileKey] = Math.max(...totalY);

            let traceName = 'Total';
            let lineWidth = 2;
            
            if (enabledFiles.length > 1 && enabledFiles.indexOf(fileKey) > 0) {
              traceName = `Total (${filenameDiff(enabledFiles[0], fileKey)})`;
              lineWidth = 1;
            }
            
            totalTracesByFile[fileKey] = {
              x: timeData,
              y: totalY,
              mode: 'lines',
              name: traceName,
              line: {
                color: '#000000',
                dash: 'solid',
                width: lineWidth
              },
              type: 'scatter'
            };
          }
        }

        // If Show Ratio is checked, append ratio to the primary Total trace name
        if (showRatioChecked && secondaryFile) {
          const t = totalTracesByFile[primaryFile];
          if (t && t.name === 'Total') {
            const maxPrimary = totalMaxByFile[primaryFile];
            const maxSecondary = totalMaxByFile[secondaryFile];
            if (maxSecondary != null && maxSecondary !== 0) {
              t.name = `Total (${formatRatio(maxPrimary / maxSecondary)})`;
            } else if (maxSecondary === 0 && maxPrimary > 0) {
              t.name = `Total (‚àû)`;
            }
          }
        }

        // Insert each total trace at the beginning of its file's group.
        // Process files in reverse order so earlier splice positions stay valid.
        const filesWithTotals = enabledFiles.filter(fk => totalTracesByFile[fk]);
        for (let i = filesWithTotals.length - 1; i >= 0; i--) {
          const fk = filesWithTotals[i];
          const insertIdx = fileTraceStartIndex[fk] != null ? fileTraceStartIndex[fk] : traces.length;
          traces.splice(insertIdx, 0, totalTracesByFile[fk]);
        }
      }

      // Update thick-line trace names with ratio of max values if "Show Ratio" is checked
      if (showRatioChecked) {
        for (const trace of traces) {
          // Thick-line traces are those from the primary file (no fileKey suffix, not Total)
          for (const datasetKey of Object.keys(maxByFileAndName)) {
            if (trace.name === datasetKey) {
              const maxPrimary = maxByFileAndName[datasetKey][primaryFile];
              const maxSecondary = maxByFileAndName[datasetKey][secondaryFile];
              if (maxSecondary != null && maxSecondary !== 0) {
                trace.name = `${datasetKey} (${formatRatio(maxPrimary / maxSecondary)})`;
              } else if (maxSecondary === 0 && maxPrimary > 0) {
                trace.name = `${datasetKey} (‚àû)`;
              }
              break;
            }
          }
        }
        
        // Hide thin-line (secondary file) traces from legend ‚Äî keep them visible in chart.
        // Secondary file traces have halved line widths compared to primary ones.
        for (const trace of traces) {
          const w = trace.line && trace.line.width;
          // Thick (primary) traces have width >= 2, thin (secondary) have width < 2
          // Total traces: primary=2, secondary=1. Radionuclide traces: primary=original, secondary=original/2.
          // We keep ratio-annotated traces and primary Total in the legend.
          if (w != null && w < 2) {
            trace.showlegend = false;
            trace._hiddenFromLegend = true; // preserve across dynamic legend updates
          }
        }
      }
      
      // Render chart if we have traces
      if (traces.length > 0) {
        // Get unit from group
        const firstFile = loadedFiles[enabledFiles[0]];
        try {
          const group = firstFile.get(path);
          if (group && group.attrs && typeof group.attrs === 'object') {
            for (const attrName in group.attrs) {
              if (attrName === 'unit') {
                const attrObj = group.attrs[attrName];
                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                  yAxisUnit = attrObj.value;
                }
              }
            }
          }
        } catch (e) {
          console.warn('Could not read unit from group:', e);
        }
        
        const { xScale, yScale } = getChartScales();
        const yAxisTitle = yAxisUnit ? `${yAxisName} (${yAxisUnit})` : yAxisName;
        
        const layout = ChartService.createBaseLayout({
          title: path,
          xAxisTitle: timeUnit ? `Time (${timeUnit})` : 'Time',
          yAxisTitle,
          xScale,
          yScale
        });
        
        // Preserve axis ranges when toggling controls (Show Total, Show Ratio)
        applyAxisState(layout, savedAxisState);
        
        renderChart(traces, layout, path);
      } else {
        hideChart();
      }
    }
    
    /**
     * Get standard Plotly configuration with custom toolbar buttons.
     * Configures the mode bar with:
     * - Copy to clipboard button (PNG export)
     * - Download CSV button (data export)
     * - Download Excel button (xlsx export)
     * - Standard Plotly zoom/pan/reset tools
     * - SVG export configuration
     * 
     * @param {string} filename - Base filename for exported images/data
     * @returns {Object} Plotly config object
     */
    function getPlotlyConfig(filename) {
      return {
        displayLogo: false,
        scrollZoom: true,
        showLink: false,
        plotlyServerURL: "https://chart-studio.plotly.com",
        modeBarButtonsToAdd: [
          'v1hovermode',
          {
            name: 'Copy chart to clipboard',
            icon: {
              width: 500,
              height: 600,
              path: 'M224 0c-35.3 0-64 28.7-64 64V288v64 64c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V288 160 64c0-35.3-28.7-64-64-64H224zm0 64H448V160H224V64zM160 448c0 17.7-14.3 32-32 32H64c-17.7 0-32-14.3-32-32V384H160v64zm0-96H32V288H160v64zM32 240V176H160v64H32zM160 128V64h32v64H160z'
            },
            click: function(gd) {
              copyChartToClipboard();
            }
          },
          {
            name: 'Download data as CSV',
            icon: {
              width: 512,
              height: 512,
              path: 'M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zm368 56a24 24 0 1 1 0 48 24 24 0 1 1 0-48z'
            },
            click: function(gd) {
              downloadChartData();
            }
          },
          {
            name: 'Download data as Excel',
            icon: {
              width: 384,
              height: 512,
              path: 'M64 0C28.7 0 0 28.7 0 64V448c0 35.3 28.7 64 64 64H320c35.3 0 64-28.7 64-64V160H256c-17.7 0-32-14.3-32-32V0H64zM256 0V128H384L256 0zM155.7 250.2L192 302.1l36.3-51.9c7.6-10.9 22.6-13.5 33.4-5.9s13.5 22.6 5.9 33.4L221.3 344l46.4 66.2c7.6 10.9 5 25.8-5.9 33.4s-25.8 5-33.4-5.9L192 385.8l-36.3 51.9c-7.6 10.9-22.6 13.5-33.4 5.9s-13.5-22.6-5.9-33.4L162.7 344l-46.4-66.2c-7.6-10.9-5-25.8 5.9-33.4s25.8-5 33.4 5.9z'
            },
            click: function(gd) {
              downloadChartDataAsExcel();
            }
          }
        ],
        responsive: true,
        toImageButtonOptions: {
          format: 'svg',
          filename: filename,
          height: 600,
          width: 800,
          scale: 1
        }
      };
    }


    /* ==========================================================================
       10. DYNAMIC LEGEND
       ========================================================================== */
    
    /**
     * Toggle dynamic legend filtering on/off.
     * When enabled, only traces with data points visible in the current
     * viewport are shown in the legend. When disabled, all traces are shown.
     * 
     * @returns {void}
     */
    function toggleDynamicLegend() {
      dynamicLegendEnabled = document.getElementById('dynamicLegend').checked;
      
      const plotDiv = document.getElementById('plotlyChart');
      if (!plotDiv || !plotDiv.data || !plotDiv.layout) {
        return;
      }
      
      if (!dynamicLegendEnabled) {
        // Show all legend items (except those explicitly hidden, e.g. by Show Ratio)
        const showlegendValues = plotDiv.data.map(trace => !trace._hiddenFromLegend);
        
        Plotly.restyle(plotDiv, { showlegend: showlegendValues }).then(() => {
          const statusEl = document.getElementById('legendStatus');
          if (statusEl) {
            statusEl.style.display = 'none';
          }
        });
      } else {
        // Re-apply dynamic filtering based on current view
        const layout = plotDiv.layout;
        
        // Re-apply legend sorting by max Y value
        assignLegendRanks(plotDiv.data);

        let xRange = layout.xaxis?.range;
        let yRange = layout.yaxis?.range;
        
        if (!xRange || !yRange) {
          return;
        }
        
        const xIsLog = layout.xaxis?.type === 'log';
        const yIsLog = layout.yaxis?.type === 'log';
        
        const xMin = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
        const xMax = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
        const yMin = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
        const yMax = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
        
        let visibleCount = 0;
        const showlegendValues = plotDiv.data.map((trace) => {
          let isVisible = false;
          
          for (let j = 0; j < trace.x.length; j++) {
            const x = trace.x[j];
            const y = trace.y[j];
            
            if (x === null || x === undefined || y === null || y === undefined) {
              continue;
            }
            
            if (x >= xMin && x <= xMax && y >= yMin && y <= yMax) {
              isVisible = true;
              break;
            }
          }
          
          // Never show in legend if explicitly hidden (e.g. by Show Ratio)
          const legendVisible = trace._hiddenFromLegend ? false : isVisible;
          if (legendVisible) visibleCount++;
          
          return legendVisible;
        });
        
        const legendrankValues = plotDiv.data.map(t => t.legendrank);
        Plotly.restyle(plotDiv, { showlegend: showlegendValues, legendrank: legendrankValues }).then(() => {
          const totalCount = plotDiv.data.length;
          const statusEl = document.getElementById('legendStatus');
          
          if (statusEl) {
            if (visibleCount < totalCount) {
              statusEl.textContent = `Showing ${visibleCount}/${totalCount} traces`;
              statusEl.style.display = 'block';
            } else {
              statusEl.style.display = 'none';
            }
          }
        });
      }
    }
    
    /**
     * Set up dynamic legend filtering on zoom/pan events.
     * Attaches a plotly_relayout listener that updates legend visibility
     * based on which traces have data points in the current viewport.
     * 
     * This helps reduce legend clutter when zoomed in on charts with many traces.
     * A status indicator shows "Showing X/Y traces" when filtering is active.
     * 
     * @param {HTMLElement} plotDiv - The Plotly chart DOM element
     * @returns {void}
     */
    function setupDynamicLegend(plotDiv) {
      plotDiv.on('plotly_relayout', function(eventData) {
        if (!dynamicLegendEnabled) return;
        
        if (!eventData || (!eventData['xaxis.range[0]'] && !eventData['xaxis.range'] && !eventData['xaxis.autorange'])) {
          return;
        }
        
        const fullData = plotDiv.data;
        const layout = plotDiv.layout;
        
        let xRange, yRange;
        
        if (eventData['xaxis.autorange'] || eventData['yaxis.autorange']) {
          // Autorange - show all traces (except those explicitly hidden, e.g. by Show Ratio)
          const visibility = fullData.map(trace => !trace._hiddenFromLegend);
          Plotly.restyle(plotDiv, { showlegend: visibility });
          
          const statusEl = document.getElementById('legendStatus');
          if (statusEl) {
            statusEl.style.display = 'none';
          }
          return;
        }
        
        // Get axis ranges
        if (eventData['xaxis.range[0]'] !== undefined) {
          xRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
        } else if (eventData['xaxis.range']) {
          xRange = eventData['xaxis.range'];
        } else if (layout.xaxis && layout.xaxis.range) {
          xRange = layout.xaxis.range;
        }
        
        if (eventData['yaxis.range[0]'] !== undefined) {
          yRange = [eventData['yaxis.range[0]'], eventData['yaxis.range[1]']];
        } else if (eventData['yaxis.range']) {
          yRange = eventData['yaxis.range'];
        } else if (layout.yaxis && layout.yaxis.range) {
          yRange = layout.yaxis.range;
        }
        
        if (!xRange || !yRange) return;
        
        // Convert log scale ranges
        const xIsLog = layout.xaxis && layout.xaxis.type === 'log';
        const yIsLog = layout.yaxis && layout.yaxis.type === 'log';
        
        const xMin = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
        const xMax = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
        const yMin = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
        const yMax = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
        
        // Check each trace for visibility (respect _hiddenFromLegend flag)
        const visibility = fullData.map((trace, i) => {
          if (trace._hiddenFromLegend) return false;
          for (let j = 0; j < trace.x.length; j++) {
            const x = trace.x[j];
            const y = trace.y[j];
            
            if (x === null || x === undefined || y === null || y === undefined) {
              continue;
            }
            
            if (x >= xMin && x <= xMax && y >= yMin && y <= yMax) {
              return true;
            }
          }
          return false;
        });
        
        Plotly.restyle(plotDiv, { showlegend: visibility }).then(() => {
          const visibleCount = visibility.filter(v => v).length;
          const totalCount = fullData.length;
          const statusEl = document.getElementById('legendStatus');
          
          if (statusEl) {
            if (visibleCount < totalCount) {
              statusEl.textContent = `Showing ${visibleCount}/${totalCount} traces`;
              statusEl.style.display = 'block';
            } else {
              statusEl.style.display = 'none';
            }
          }
        });
      });
    }


    /* ==========================================================================
       11. DATASET INFORMATION DISPLAY
       ========================================================================== */
    
    /**
     * Display node attributes and information for a selected path
     * Shows data preview, attributes table, and triggers chart if time-dependent
     * @param {string} path - HDF5 path to the node
     * @param {boolean} isGroup - Whether the node is a group (vs dataset)
     */
    function showNodeAttributes(path, isGroup = false) {
      const infoDiv = document.getElementById('info');
      infoDiv.innerHTML = '<div class="loading">Loading...</div>';
      
      const jsonReplacer = PDFSampler.jsonReplacer;
      
      try {
        const enabledFiles = getEffectiveFiles();
        let html = '';
        let hasTimeDependentData = false;
        let isRadionuclidesGroup = false;
        let pdfHistogramData = null;
        
        // Check if this is a radionuclides group
        if (isGroup && enabledFiles.length > 0) {
          const firstFile = loadedFiles[enabledFiles[0]];
          isRadionuclidesGroup = checkGroupForRadionuclides(firstFile, path);
          selectedIsRadionuclidesGroup = isRadionuclidesGroup;
        } else {
          selectedIsRadionuclidesGroup = false;
        }
        
        // Build HTML for each enabled file
        for (const fileKey of enabledFiles) {
          const file = loadedFiles[fileKey];
          
          if (!checkDatasetExistsInFile(file, path)) {
            continue;
          }
          
          const node = FileService.get(file, path);
          if (!node) continue;
          
          const isFirstFile = fileKey === enabledFiles[0];
          const fileColor = isFirstFile ? '#0066cc' : '#10b981';
          const nodeType = String(node.type);
          
          // Detect link info
          const linkInfo = getLinkInfo(file, path, node);
          
          html += `<div class="file-data-section" style="border-left-color: ${fileColor};">`;
          html += `<h4>${escapeHtml(fileKey)}</h4>`;
          
          // Handle broken soft links
          if (nodeType === 'BrokenSoftLink') {
            html += `<div class="info-section">
              <div class="info-label">Path</div>
              <div class="info-content">${escapeHtml(path)}</div>
            </div>`;
            html += `<div class="info-section">
              <div class="info-label">Type</div>
              <div class="info-content">Broken Soft Link</div>
            </div>`;
            html += `<div class="info-section link-info broken">
              <div class="info-label">üîó Link Target</div>
              <div class="info-content">${escapeHtml(node.target || '?')} <span style="color:var(--color-kvot-accent);">(target not found)</span></div>
            </div>`;
            html += '</div>';
            continue;
          }
          
          // Handle external links
          if (nodeType === 'ExternalLink') {
            html += `<div class="info-section">
              <div class="info-label">Path</div>
              <div class="info-content">${escapeHtml(path)}</div>
            </div>`;
            html += `<div class="info-section">
              <div class="info-label">Type</div>
              <div class="info-content">External Link</div>
            </div>`;
            html += `<div class="info-section link-info external">
              <div class="info-label">üîó External File</div>
              <div class="info-content">${escapeHtml(node.filename || '?')}</div>
            </div>`;
            html += `<div class="info-section link-info external">
              <div class="info-label">üîó External Path</div>
              <div class="info-content">${escapeHtml(node.obj_path || '?')}</div>
            </div>`;
            html += '</div>';
            continue;
          }
          
          // Show path, type, dtype, shape only for first file
          if (isFirstFile) {
            html += `<div class="info-section">
              <div class="info-label">Path</div>
              <div class="info-content">${escapeHtml(path)}</div>
            </div>`;
            
            html += `<div class="info-section">
              <div class="info-label">Type</div>
              <div class="info-content">${escapeHtml(nodeType)}</div>
            </div>`;
            
            // Show link info for resolved soft links
            if (linkInfo && linkInfo.type === 'soft') {
              html += `<div class="info-section link-info soft">
                <div class="info-label">üîó Soft Link</div>
                <div class="info-content">Target: ${escapeHtml(linkInfo.target)}</div>
              </div>`;
            }
            
            if (!isGroup && node.dtype) {
              const readableDtype = formatDataType(node.dtype);
              html += `<div class="info-section">
                <div class="info-label">Data Type</div>
                <div class="info-content">${escapeHtml(readableDtype)}</div>
              </div>`;
            }
            
            if (node.shape && Array.isArray(node.shape)) {
              html += `<div class="info-section">
                <div class="info-label">Shape</div>
                <div class="info-content">${node.shape.join(', ')}</div>
              </div>`;
            }
          }
          
          // Show data preview for datasets (not groups)
          if (!isGroup) {
            if (isTimeDependent(node)) {
              hasTimeDependentData = true;
            }
            
            try {
              let data;
              if (typeof node.value !== 'undefined') {
                data = node.value;
              } else if (typeof node.toArray === 'function') {
                data = node.toArray();
              }
              
              if (data !== undefined) {
                let preview;
                let itemCount;
                let fullData;
                
                if (Array.isArray(data)) {
                  preview = data.slice(0, 100);
                  itemCount = data.length;
                  fullData = data;
                } else if (data && typeof data === 'object' && data.length !== undefined) {
                  preview = Array.from(data).slice(0, 100);
                  itemCount = data.length;
                  fullData = Array.from(data);
                } else {
                  preview = [data];
                  itemCount = 1;
                  fullData = [data];
                }
                
                const isScalar = itemCount === 1;
                const downloadBtnId = `downloadData_${fileKey.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`;
                
                const previewLabel = isScalar ? 'Data Preview' : `Data Preview (first ${preview.length}/${itemCount} items)`;
                let previewText;
                if (isScalar) {
                  // Single value: show without brackets or quotes
                  let val = preview[0];
                  val = PDFSampler.toNumber(val);
                  previewText = String(val);
                } else {
                  previewText = JSON.stringify(preview, jsonReplacer, 2);
                }

                html += `<div class="info-section">
                  <div class="info-label" style="display: flex; align-items: center; justify-content: space-between;">
                    <span>${previewLabel}</span>
                    ${!isScalar ? `<button 
                      id="${downloadBtnId}" 
                      class="download-data-btn" 
                      style="padding: 4px 8px; background: var(--color-kvot-background); color: var(--color-kvot-bright); border: none; border-radius: 3px; cursor: pointer; font-size: 11px; font-weight: 500; transition: all 0.2s;"
                      onmouseover="this.style.background='var(--color-kvot-primary)'" 
                      onmouseout="this.style.background='var(--color-kvot-background)'"
                      title="Download full dataset as CSV">
                      ‚¨á Download CSV
                    </button>` : ''}
                  </div>
                  <div class="info-content">${escapeHtml(previewText)}</div>
                </div>`;
                
                // Setup download button handler
                if (!isScalar) {
                  setTimeout(() => {
                    const downloadBtn = document.getElementById(downloadBtnId);
                    if (downloadBtn) {
                      downloadBtn.addEventListener('click', () => {
                        downloadDatasetAsCSV(node, fullData, path, fileKey);
                      });
                    }
                  }, 0);
                }
              }
            } catch (e) {
              console.warn('Could not read data:', e.message);
            }
          }
          
          // Show attributes table
          const attrs = {};
          let hasAttributes = false;
          
          try {
            if (node.attrs && typeof node.attrs === 'object') {
              for (const attrName in node.attrs) {
                if (!attrName.startsWith('_')) {
                  try {
                    const attrObj = node.attrs[attrName];
                    let attrValue;
                    // prefer attrObj.value when present (h5wasm attribute wrapper), otherwise use primitive/string directly
                    if (attrObj && typeof attrObj === 'object' && 'value' in attrObj) {
                      attrValue = attrObj.value;
                    } else {
                      attrValue = attrObj;
                    }

                    attrs[attrName] = attrValue;
                    hasAttributes = true;
                  } catch (e) {
                    attrs[attrName] = `(unreadable: ${e.message})`;
                  }
                }
              }
            }
          } catch (e) {
            console.warn('Error reading attributes:', e.message);
          }
          
          if (hasAttributes && Object.keys(attrs).length > 0) {
            html += buildAttributesTable(attrs, jsonReplacer);
          }
          
          // Collect PDF histogram data (only from the first file that has a pdf attr)
          if (!isGroup && attrs.pdf && !pdfHistogramData) {
            try {
              let pdfRaw = attrs.pdf;
              // Parse JSON string if needed
              if (typeof pdfRaw === 'string') {
                pdfRaw = JSON.parse(pdfRaw);
              }

              const isLookupTable = Array.isArray(pdfRaw);
              const indexAttr = attrs.index;

              if (isLookupTable && indexAttr) {
                // Lookup-table: array of per-index PDF specs
                const indexLabels = Array.isArray(indexAttr) ? indexAttr : Array.from(indexAttr);
                const entries = [];
                for (let i = 0; i < pdfRaw.length; i++) {
                  const spec = pdfRaw[i];
                  if (!spec) {
                    // No pdf for this index ‚Äî use the node value at that index
                    try {
                      let rawData;
                      if (typeof node.value !== 'undefined') rawData = node.value;
                      else if (typeof node.toArray === 'function') rawData = node.toArray();
                      if (rawData !== undefined) {
                        const arr = Array.isArray(rawData) ? rawData : Array.from(rawData);
                        entries.push({ label: String(indexLabels[i] ?? i), samples: [arr[i]], spec: null });
                      }
                    } catch (_) { /* skip */ }
                    continue;
                  }

                  if (spec.type && spec.type.toLowerCase() === 'raw') {
                    // Raw data: column i from the 2D dataset
                    try {
                      let rawData;
                      if (typeof node.value !== 'undefined') rawData = node.value;
                      else if (typeof node.toArray === 'function') rawData = node.toArray();
                      if (rawData !== undefined) {
                        const flat = Array.isArray(rawData) ? rawData : Array.from(rawData);
                        const nCols = pdfRaw.length;
                        const nRows = Math.floor(flat.length / nCols);
                        const shift = (spec.include_deterministic) ? 1 : 0;
                        const detVal = (spec.include_deterministic && nRows > 0) ? flat[0 * nCols + i] : null;
                        const col = [];
                        for (let r = shift; r < nRows; r++) col.push(flat[r * nCols + i]);
                        entries.push({ label: String(indexLabels[i] ?? i), samples: col, spec: spec, deterministicValue: detVal });
                      }
                    } catch (_) { /* skip */ }
                  } else {
                    // Standard distribution ‚Äî read deterministic value from node column
                    let detVal = null;
                    try {
                      let rawData;
                      if (typeof node.value !== 'undefined') rawData = node.value;
                      else if (typeof node.toArray === 'function') rawData = node.toArray();
                      if (rawData !== undefined) {
                        const flat = Array.isArray(rawData) ? rawData : Array.from(rawData);
                        const nCols = pdfRaw.length;
                        if (flat.length >= nCols) detVal = Number(flat[i]);
                      }
                    } catch (_) { /* skip */ }
                    let samples = generatePdfSamples(spec, 1000);
                    if (samples) {
                      samples = PDFSampler.normalizeDataArray(samples);
                      entries.push({ label: String(indexLabels[i] ?? i), samples: Array.from(samples), spec: spec, deterministicValue: isFinite(detVal) ? detVal : null });
                    } else {
                      console.warn('generatePdfSamples returned null for spec (lookup index)', spec);
                    }
                  }
                }
                if (entries.length > 0) {
                  pdfHistogramData = { type: 'lookup', entries, path };
                }
              } else if (!isLookupTable && pdfRaw.type) {
                // Single PDF spec
                if (pdfRaw.type.toLowerCase() === 'raw') {
                  // Raw data from the dataset
                  try {
                    let rawData;
                    if (typeof node.value !== 'undefined') rawData = node.value;
                    else if (typeof node.toArray === 'function') rawData = node.toArray();
                    if (rawData !== undefined) {
                      const flat = PDFSampler.normalizeDataArray(rawData);
                      const shift = (pdfRaw.include_deterministic) ? 1 : 0;
                      const detVal = (pdfRaw.include_deterministic && flat.length > 0) ? flat[0] : null;
                      pdfHistogramData = { type: 'single', samples: flat.slice(shift), spec: pdfRaw, path, deterministicValue: detVal };
                    }
                  } catch (_) { /* skip */ }
              // const label = path.split('/').pop();
              // const entries = collectPdfEntries(node, attrs, label);
              // if (entries && entries.length > 0) {
              //   if (entries.length === 1 && entries[0].spec) {
              //     const e = entries[0];
              //     pdfHistogramData = {
              //       type: 'single',
              //       samples: Array.from(e.samples, v => (typeof v === 'bigint' ? Number(v) : v)),
              //       spec: e.spec,
              //       path,
              //       deterministicValue: e.deterministicValue ?? null
              //     };
                } else {
                  // Standard distribution ‚Äî read deterministic value from the node
                  let detVal = null;
                  try {
                    let rawData;
                    if (typeof node.value !== 'undefined') rawData = node.value;
                    else if (typeof node.toArray === 'function') rawData = node.toArray();
                    if (rawData !== undefined) {
                      if (typeof rawData === 'number') detVal = rawData;
                      else if (rawData && rawData.length !== undefined && rawData.length > 0) detVal = Number(rawData[0]);
                    }
                  } catch (_) { /* skip */ }

                  let samples = generatePdfSamples(pdfRaw, 1000);
                  if (samples) {
                    samples = PDFSampler.normalizeDataArray(samples);
                    pdfHistogramData = { type: 'single', samples: Array.from(samples), spec: pdfRaw, path, deterministicValue: isFinite(detVal) ? detVal : null };
                  } else {
                    console.warn('generatePdfSamples returned null for pdf spec', pdfRaw, 'at', path);
                  }
                  // pdfHistogramData = {
                  //   type: 'lookup',
                  //   entries: entries.map(ent => ({ ...ent, samples: ent.samples.map(v => (typeof v === 'bigint' ? Number(v) : v)), deterministicValue: ent.deterministicValue ?? null })),
                  //   path
                  // };
                }
              }
            } catch (err) {
              console.warn('PDF collect error:', err);
            }
          }
          
          // Add Excel download button for datasets (not groups)
          if (!isGroup) {
            const escapedPath = path.replace(/'/g, "\\'");
            const escapedFileKey = fileKey.replace(/'/g, "\\'");
            html += `<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--color-border);">
              <button onclick="downloadDatasetAsExcel('${escapedPath}', '${escapedFileKey}')" 
                style="padding: 6px 12px; background: #217346; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500; transition: all 0.2s;"
                onmouseover="this.style.background='#1e6b3f'" 
                onmouseout="this.style.background='#217346'"
                title="Download this dataset to Excel">
                üìä Download Excel
              </button>
            </div>`;
          }
          
          html += '</div>';
        }
        
        infoDiv.innerHTML = html || '<div style="color:#999;">No data available for this path</div>';
        
        // Create chart if appropriate
        if (isRadionuclidesGroup) {
          currentPdfHistogram = false;
          createRadionuclidesChart(path);
        } else if (hasTimeDependentData && !isGroup) {
          currentPdfHistogram = false;
          createPlotlyChart(path);
        } else if (pdfHistogramData) {
          createPdfHistogram(pdfHistogramData);
        } else {
          currentPdfHistogram = false;
          document.getElementById('plotlyChartContainer').classList.remove('visible');
          currentChartData = null;
        }
      } catch (e) {
        infoDiv.innerHTML = `<div class="error">Error: ${escapeHtml(e.message)}</div>`;
        console.error(e);
      }
    }

    /**
     * Download dataset data as CSV file
     * @param {Object} node - HDF5 dataset node
     * @param {Array} fullData - Full data array
     * @param {string} path - Dataset path
     * @param {string} fileKey - File name
     */
    function downloadDatasetAsCSV(node, fullData, path, fileKey) {
      // Get index attribute if it exists
      let headerRow = null;
      try {
        if (node.attrs && typeof node.attrs === 'object') {
          for (const attrName in node.attrs) {
            if (attrName === 'index') {
              const attrObj = node.attrs[attrName];
              if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                const indexValue = attrObj.value;
                if (Array.isArray(indexValue)) {
                  headerRow = indexValue;
                } else if (indexValue && indexValue.length !== undefined) {
                  headerRow = Array.from(indexValue);
                }
              }
            }
          }
        }
      } catch (e) {
        console.warn('Could not read index attribute:', e);
      }
      
      // Determine data shape and build CSV
      let csvContent = '';
      const shape = node.shape || [];
      
      if (shape.length === 1) {
        // 1D array - single column
        if (headerRow && headerRow.length === 1) {
          csvContent += escapeCSV(headerRow[0]) + '\n';
        }
        fullData.forEach(value => {
          csvContent += escapeCSV(value) + '\n';
        });
      } else if (shape.length === 2) {
        // 2D array - rows and columns
        const numRows = shape[0];
        const numCols = shape[1];
        
        if (headerRow && headerRow.length === numCols) {
          csvContent += headerRow.map(h => escapeCSV(h)).join(',') + '\n';
        }
        
        for (let i = 0; i < numRows; i++) {
          const row = [];
          for (let j = 0; j < numCols; j++) {
            row.push(escapeCSV(fullData[i * numCols + j]));
          }
          csvContent += row.join(',') + '\n';
        }
      } else if (shape.length === 0) {
        // Scalar or flat array
        if (headerRow && headerRow.length > 0) {
          csvContent += headerRow.map(h => escapeCSV(h)).join(',') + '\n';
        }
        
        if (headerRow && headerRow.length > 1) {
          const numCols = headerRow.length;
          const numRows = Math.floor(fullData.length / numCols);
          for (let i = 0; i < numRows; i++) {
            const row = [];
            for (let j = 0; j < numCols; j++) {
              row.push(escapeCSV(fullData[i * numCols + j]));
            }
            csvContent += row.join(',') + '\n';
          }
        } else {
          fullData.forEach(value => {
            csvContent += escapeCSV(value) + '\n';
          });
        }
      } else {
        // Higher dimensional - flatten to 2D
        console.warn('Multi-dimensional array, flattening to 2D');
        if (headerRow) {
          csvContent += headerRow.map(h => escapeCSV(h)).join(',') + '\n';
        }
        
        const lastDim = shape[shape.length - 1];
        const numRows = Math.floor(fullData.length / lastDim);
        
        for (let i = 0; i < numRows; i++) {
          const row = [];
          for (let j = 0; j < lastDim; j++) {
            row.push(escapeCSV(fullData[i * lastDim + j]));
          }
          csvContent += row.join(',') + '\n';
        }
      }
      
      // Create and download CSV
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const safePath = path.replace(/[^a-zA-Z0-9]/g, '_');
      const safeFileName = fileKey.replace(/\.[^/.]+$/, '');
      a.download = `${safeFileName}${safePath}_data.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /**
     * Download selected dataset information, attributes, and data as Excel file
     * Uses xlsxwrite.js library
     */
    async function downloadDatasetAsExcel(datasetPath, datasetFileKey) {
      // Use provided parameters or fall back to selected dataset
      const path = datasetPath || selectedDatasetPath;
      if (!path) {
        alert('No dataset selected');
        return;
      }
      
      const enabledFiles = getEffectiveFiles();
      if (enabledFiles.length === 0) {
        alert('No files enabled');
        return;
      }
      
      try {
        // Use specified file or first enabled file
        const fileKey = datasetFileKey || enabledFiles[0];
        const file = loadedFiles[fileKey];
        if (!file) {
          alert('File not found: ' + fileKey);
          return;
        }
        const node = FileService.get(file, path);
        
        if (!node) {
          alert('Could not access dataset');
          return;
        }
        
        const isGroup = node.type === 'Group';
        const safeFileName = fileKey.replace(/\.[^/.]+$/, '').replace(/[^a-zA-Z0-9]/g, '_');
        const safePath = path.replace(/[^a-zA-Z0-9]/g, '_');
        
        // Create workbook
        const xlsx = new XlsxWriter(`${safeFileName}${safePath}.xlsx`);
        
        // Create formats
        const headerFormat = xlsx.addFormat({
          bold: true,
          bg_color: '217346',
          font_color: 'FFFFFF',
          align: 'center',
          valign: 'vcenter',
          border: 1
        });
        
        const labelFormat = xlsx.addFormat({
          bold: true,
          bg_color: 'E2EFDA',
          border: 1
        });
        
        const valueFormat = xlsx.addFormat({
          border: 1
        });
        
        const titleFormat = xlsx.addFormat({
          bold: true,
          font_size: 14,
          font_color: '217346'
        });
        
        // ========== SHEET 1: Information ==========
        xlsx.write(0, 0, 'Dataset Information', titleFormat, 'Information');
        xlsx.write(2, 0, 'Property', headerFormat, 'Information');
        xlsx.write(2, 1, 'Value', headerFormat, 'Information');
        xlsx.setColumn(0, 0, 20, null, {}, 'Information');
        xlsx.setColumn(1, 1, 50, null, {}, 'Information');
        
        let row = 3;
        xlsx.write(row, 0, 'File', labelFormat, 'Information');
        xlsx.write(row, 1, fileKey, valueFormat, 'Information');
        row++;
        
        xlsx.write(row, 0, 'Path', labelFormat, 'Information');
        xlsx.write(row, 1, path, valueFormat, 'Information');
        row++;
        
        xlsx.write(row, 0, 'Type', labelFormat, 'Information');
        xlsx.write(row, 1, String(node.type), valueFormat, 'Information');
        row++;
        
        if (!isGroup && node.dtype) {
          xlsx.write(row, 0, 'Data Type', labelFormat, 'Information');
          xlsx.write(row, 1, formatDataType(node.dtype), valueFormat, 'Information');
          row++;
        }
        
        if (node.shape && Array.isArray(node.shape)) {
          xlsx.write(row, 0, 'Shape', labelFormat, 'Information');
          xlsx.write(row, 1, node.shape.join(' √ó '), valueFormat, 'Information');
          row++;
        }
        
        xlsx.write(row, 0, 'Export Date', labelFormat, 'Information');
        xlsx.write(row, 1, new Date().toISOString(), valueFormat, 'Information');
        
        // ========== SHEET 2: Attributes ==========
        const attrs = {};
        if (node.attrs && typeof node.attrs === 'object') {
          for (const attrName in node.attrs) {
            if (!attrName.startsWith('_')) {
              try {
                const attrObj = node.attrs[attrName];
                let attrValue;
                if (attrObj && typeof attrObj === 'object' && 'value' in attrObj) {
                  attrValue = attrObj.value;
                } else {
                  attrValue = attrObj;
                }
                attrs[attrName] = attrValue;
              } catch (e) {
                attrs[attrName] = `(unreadable: ${e.message})`;
              }
            }
          }
        }
        
        xlsx.write(0, 0, 'Attributes', titleFormat, 'Attributes');
        xlsx.write(2, 0, 'Name', headerFormat, 'Attributes');
        xlsx.write(2, 1, 'Value', headerFormat, 'Attributes');
        xlsx.setColumn(0, 0, 25, null, {}, 'Attributes');
        xlsx.setColumn(1, 1, 60, null, {}, 'Attributes');
        
        row = 3;
        for (const [key, value] of Object.entries(attrs)) {
          let displayValue;
          if (typeof value === 'string') {
            displayValue = value;
          } else if (Array.isArray(value)) {
            displayValue = `[${value.join(', ')}]`;
          } else if (value === null) {
            displayValue = 'null';
          } else if (value === undefined) {
            displayValue = 'undefined';
          } else if (typeof value === 'object') {
            if (value.length !== undefined) {
              displayValue = `[${Array.from(value).slice(0, 10).join(', ')}${value.length > 10 ? '...' : ''}]`;
            } else {
              displayValue = JSON.stringify(value);
            }
          } else if (typeof value === 'bigint') {
            displayValue = String(PDFSampler.toNumber(value));
          } else {
            displayValue = String(value);
          }
          
          xlsx.write(row, 0, key, labelFormat, 'Attributes');
          xlsx.write(row, 1, displayValue, valueFormat, 'Attributes');
          row++;
        }
        
        if (Object.keys(attrs).length === 0) {
          xlsx.write(3, 0, '(No attributes)', valueFormat, 'Attributes');
        }
        
        // ========== SHEET 3: Data ==========
        if (!isGroup) {
          let data;
          try {
            if (typeof node.value !== 'undefined') {
              data = node.value;
            } else if (typeof node.toArray === 'function') {
              data = node.toArray();
            }
          } catch (e) {
            console.warn('Could not read data:', e);
          }
          
          if (data !== undefined) {
            let fullData;
            if (Array.isArray(data)) {
              fullData = data;
            } else if (data && typeof data === 'object' && data.length !== undefined) {
              fullData = Array.from(data);
            } else {
              fullData = [data];
            }
            
            xlsx.write(0, 0, 'Data', titleFormat, 'Data');
            
            // Check for index attribute (column headers)
            let headerRow = null;
            try {
              if (node.attrs && node.attrs['index']) {
                const indexAttr = node.attrs['index'];
                const indexValue = indexAttr.value !== undefined ? indexAttr.value : indexAttr;
                if (Array.isArray(indexValue)) {
                  headerRow = indexValue;
                } else if (indexValue && indexValue.length !== undefined) {
                  headerRow = Array.from(indexValue);
                }
              }
            } catch (e) {
              console.warn('Could not read index attribute:', e);
            }
            
            // Try to get time data for time-series datasets
            let timeData = null;
            let timeUnit = '';
            try {
              timeData = getTimeData(file);
              timeUnit = getTimeUnit(file);
            } catch (e) {
              console.warn('Could not read time data:', e);
            }
            
            const shape = node.shape || [];
            
            if (shape.length <= 1) {
              // 1D array - single column (possibly with time column)
              const hasTimeColumn = timeData && timeData.length === fullData.length;
              const colOffset = hasTimeColumn ? 1 : 0;
              
              // Write time header if available
              if (hasTimeColumn) {
                const timeHeader = timeUnit ? `Time (${timeUnit})` : 'Time';
                xlsx.write(2, 0, timeHeader, headerFormat, 'Data');
                xlsx.setColumn(0, 0, 15, null, {}, 'Data');
              }
              
              // Write data header
              if (headerRow && headerRow.length === 1) {
                xlsx.write(2, colOffset, headerRow[0], headerFormat, 'Data');
              } else {
                xlsx.write(2, colOffset, 'Value', headerFormat, 'Data');
              }
              
              // Write data (with time if available)
              for (let i = 0; i < fullData.length; i++) {
                if (hasTimeColumn) {
                  xlsx.write(3 + i, 0, timeData[i], null, 'Data');
                }
                const val = fullData[i];
                xlsx.write(3 + i, colOffset, typeof val === 'number' ? val : String(val), null, 'Data');
              }
              
              xlsx.setColumn(colOffset, colOffset, 15, null, {}, 'Data');
              
            } else if (shape.length === 2) {
              // 2D array (possibly with time column)
              const numRows = shape[0];
              const numCols = shape[1];
              const hasTimeColumn = timeData && timeData.length === numRows;
              const colOffset = hasTimeColumn ? 1 : 0;
              
              // Write time header if available
              if (hasTimeColumn) {
                const timeHeader = timeUnit ? `Time (${timeUnit})` : 'Time';
                xlsx.write(2, 0, timeHeader, headerFormat, 'Data');
              }
              
              // Write headers
              if (headerRow && headerRow.length === numCols) {
                for (let j = 0; j < numCols; j++) {
                  xlsx.write(2, j + colOffset, String(headerRow[j]), headerFormat, 'Data');
                }
              } else {
                for (let j = 0; j < numCols; j++) {
                  xlsx.write(2, j + colOffset, `Col ${j + 1}`, headerFormat, 'Data');
                }
              }
              
              // Write data (with time if available)
              for (let i = 0; i < numRows; i++) {
                if (hasTimeColumn) {
                  xlsx.write(3 + i, 0, timeData[i], null, 'Data');
                }
                for (let j = 0; j < numCols; j++) {
                  const val = fullData[i * numCols + j];
                  xlsx.write(3 + i, j + colOffset, typeof val === 'number' ? val : String(val), null, 'Data');
                }
              }
              
              // Set column widths
              if (hasTimeColumn) {
                xlsx.setColumn(0, 0, 15, null, {}, 'Data');
              }
              for (let j = 0; j < numCols; j++) {
                xlsx.setColumn(j + colOffset, j + colOffset, 12, null, {}, 'Data');
              }
              
            } else {
              // Higher dimensional - flatten with index attribute hints (possibly with time column)
              const numCols = headerRow ? headerRow.length : (shape[shape.length - 1] || 1);
              const numRows = Math.floor(fullData.length / numCols);
              const hasTimeColumn = timeData && timeData.length === numRows;
              const colOffset = hasTimeColumn ? 1 : 0;
              
              // Write time header if available
              if (hasTimeColumn) {
                const timeHeader = timeUnit ? `Time (${timeUnit})` : 'Time';
                xlsx.write(2, 0, timeHeader, headerFormat, 'Data');
              }
              
              // Write headers
              if (headerRow) {
                for (let j = 0; j < headerRow.length; j++) {
                  xlsx.write(2, j + colOffset, String(headerRow[j]), headerFormat, 'Data');
                }
              } else {
                for (let j = 0; j < numCols; j++) {
                  xlsx.write(2, j + colOffset, `Col ${j + 1}`, headerFormat, 'Data');
                }
              }
              
              // Write data (with time if available)
              for (let i = 0; i < numRows; i++) {
                if (hasTimeColumn) {
                  xlsx.write(3 + i, 0, timeData[i], null, 'Data');
                }
                for (let j = 0; j < numCols; j++) {
                  const idx = i * numCols + j;
                  if (idx < fullData.length) {
                    const val = fullData[idx];
                    xlsx.write(3 + i, j + colOffset, typeof val === 'number' ? val : String(val), null, 'Data');
                  }
                }
              }
              
              // Set column widths
              if (hasTimeColumn) {
                xlsx.setColumn(0, 0, 15, null, {}, 'Data');
              }
              for (let j = 0; j < numCols; j++) {
                xlsx.setColumn(j + colOffset, j + colOffset, 12, null, {}, 'Data');
              }
            }
          }
        }
        
        // Save and download
        const content = await xlsx.save();
        
        // Browser download
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${safeFileName}${safePath}.xlsx`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
      } catch (e) {
        console.error('Error creating Excel file:', e);
        alert('Error creating Excel file: ' + e.message);
      }
    }

    /**
     * Build HTML table for node attributes
     * @param {Object} attrs - Attributes object
     * @param {Function} jsonReplacer - JSON replacer for BigInt etc.
     * @returns {string} HTML string for attributes section
     */
    function buildAttributesTable(attrs, jsonReplacer) {
      let attrsHtml = '<table class="attrs-table">';
      attrsHtml += '<tr class="attrs-header"><th>Name</th><th>Value</th></tr>';
      
      for (const [key, value] of Object.entries(attrs)) {
        let displayValue;
        if (typeof value === 'string') {
          displayValue = value;
        } else if (Array.isArray(value)) {
          displayValue = `[${value.join(', ')}]`;
        } else if (value === null) {
          displayValue = 'null';
        } else if (value === undefined) {
          displayValue = 'undefined';
        } else if (typeof value === 'object') {
          if (value.length !== undefined) {
            displayValue = `[${Array.from(value).slice(0, 10).join(', ')}${value.length > 10 ? '...' : ''}]`;
          } else {
            displayValue = JSON.stringify(value, jsonReplacer, 0);
          }
        } else if (typeof value === 'bigint') {
          displayValue = String(Number(value));
        } else {
          displayValue = String(value);
        }
      // for (const [key, value] of Object.entries(attrs).slice(0, 5)) {
      //   let displayValue = String(value);
      //   if (displayValue.length > 50) {
      //     displayValue = displayValue.substring(0, 50) + '...';
      //   }
        attrsHtml += `<tr class="attrs-row">
          <td><strong>${escapeHtml(key)}</strong></td>
          <td class="attrs-value">${escapeHtml(displayValue)}</td>
        </tr>`;
      }
      
      attrsHtml += '</table>';
      return `<div class="info-section">
        <div class="info-label">Attributes (${Object.keys(attrs).length})</div>
        <div class="info-content" style="padding: 0; overflow-x: auto;">${attrsHtml}</div>
      </div>`;
    }

    /**
     * Display information for multiple selected datasets.
     * Each item carries its own fileKey for cross-file comparisons.
     * @param {{path: string, fileKey: string|null}[]} items - Array of selected dataset items
     */
    function showMultipleDatasetAttributes(items) {
      const infoDiv = document.getElementById('info');
      infoDiv.innerHTML = `<div class="loading">Loading ${items.length} datasets...</div>`;
      
      if (items.length === 0) return;
      
      // Normalize: expand null fileKey (intersect mode) to all enabled files
      const normalizedItems = [];
      for (const item of items) {
        if (item.fileKey && loadedFiles[item.fileKey]) {
          normalizedItems.push(item);
        } else {
          for (const fk of getEnabledFiles()) {
            normalizedItems.push({ path: item.path, fileKey: fk });
          }
        }
      }
      
      let html = `<div style="background: var(--color-kvot-bright); padding: 12px; border-radius: 6px; margin-bottom: 16px; font-weight: 600; color: var(--color-kvot-background);">
        üìä ${normalizedItems.length} datasets selected
      </div>`;
      
      let allTimeDependent = true;
      const combinedPdfEntries = [];   // collect histogram entries across all selected datasets
      
      for (const item of normalizedItems) {
        const { path, fileKey } = item;
        const file = loadedFiles[fileKey];
        if (!file) continue;
        
        html += `<div class="file-data-section" style="border-left-color: var(--color-kvot-accent);">`;
        html += `<h4>${escapeHtml(path)} <span style="font-weight:400;font-size:11px;color:#888;">(${escapeHtml(fileKey)})</span></h4>`;
        
        try {
          const dataset = FileService.get(file, path);
          if (!dataset) continue;
          
          const isTimeDep = isTimeDependent(dataset);
          if (!isTimeDep) allTimeDependent = false;
          
          html += `<div class="info-section">
            <div class="info-label">Type</div>
            <div class="info-content">${escapeHtml(String(dataset.type))} ${isTimeDep ? '‚è±Ô∏è (time-dependent)' : ''}</div>
          </div>`;
          
          if (dataset.dtype) {
            const readableDtype = formatDataType(dataset.dtype);
            html += `<div class="info-section">
              <div class="info-label">Data Type</div>
              <div class="info-content">${escapeHtml(readableDtype)}</div>
            </div>`;
          }
          
          if (dataset.shape && Array.isArray(dataset.shape)) {
            html += `<div class="info-section">
              <div class="info-label">Shape</div>
              <div class="info-content">${dataset.shape.join(', ')}</div>
            </div>`;
          }
          
          // Show key attributes
          const attrs = {};
          if (dataset.attrs && typeof dataset.attrs === 'object') {
            for (const attrName in dataset.attrs) {
              if (!attrName.startsWith('_')) {
                const attrObj = dataset.attrs[attrName];
                attrs[attrName] = (attrObj && typeof attrObj === 'object' && 'value' in attrObj) ? attrObj.value : attrObj;
              }
            }
          }
          
          if (Object.keys(attrs).length > 0) {
            html += `<div class="info-section">
              <div class="info-label">Key Attributes</div>
              <div class="info-content" style="font-size: 11px;">`;
            
            for (const [key, value] of Object.entries(attrs).slice(0, 5)) {
              let displayValue = String(value);
              if (displayValue.length > 50) {
                displayValue = displayValue.substring(0, 50) + '...';
              }
              html += `<strong>${escapeHtml(key)}:</strong> ${escapeHtml(displayValue)}<br>`;
            }
            
            html += `</div></div>`;
          }
          
          // Collect PDF histogram entries for combined chart
          try {
            if (attrs.pdf) {
              const datasetName = path.split('/').pop();
              const shortFile = normalizedItems.length > 1 && new Set(normalizedItems.map(d => d.fileKey)).size > 1
                ? ' (' + fileKey + ')' : '';
              const entryLabel = datasetName + shortFile;
              const pdfEntries = collectPdfEntries(dataset, attrs, entryLabel);
              if (pdfEntries) combinedPdfEntries.push(...pdfEntries);
            // const label = path.split('/').pop();
            // const entries = collectPdfEntries(dataset, attrs, label);
            // if (entries && entries.length > 0) {
            //   if (entries.length === 1 && entries[0].spec) {
            //     const e = entries[0];
            //     pdfHistogramData = {
            //       type: 'single',
            //       samples: Array.from(e.samples, v => (typeof v === 'bigint' ? Number(v) : v)),
            //       spec: e.spec,
            //       path,
            //       deterministicValue: e.deterministicValue ?? null
            //     };
            //   } else {
            //     pdfHistogramData = {
            //       type: 'lookup',
            //       entries: entries.map(ent => ({ ...ent, samples: ent.samples.map(v => (typeof v === 'bigint' ? Number(v) : v)), deterministicValue: ent.deterministicValue ?? null })),
            //       path
            //     };
            //   }
            }
          } catch (err) {
            console.warn('PDF collect error:', err);
          }
          
          // Add Excel download button for this dataset
          const escapedPath = path.replace(/'/g, "\\'");
          const escapedFileKey = fileKey.replace(/'/g, "\\'");
          html += `<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--color-border);">
            <button onclick="downloadDatasetAsExcel('${escapedPath}', '${escapedFileKey}')" 
              style="padding: 6px 12px; background: #217346; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500; transition: all 0.2s;"
              onmouseover="this.style.background='#1e6b3f'" 
              onmouseout="this.style.background='#217346'"
              title="Download this dataset to Excel">
              üìä Download Excel
            </button>
          </div>`;
          
        } catch (e) {
          html += `<div class="error">Error loading dataset: ${escapeHtml(e.message)}</div>`;
        }
        
        html += `</div>`;
      }
      
      infoDiv.innerHTML = html;
      
      // Create combined chart
      if (allTimeDependent && normalizedItems.length > 0) {
        createMultiDatasetChart(normalizedItems);
      } else if (combinedPdfEntries.length > 0) {
        // Show combined PDF histogram for all selected datasets
        createPdfHistogram({ type: 'lookup', entries: combinedPdfEntries, path: 'Multi-selection' });
      } else {
        document.getElementById('plotlyChartContainer').classList.remove('visible');
        currentChartData = null;
      }
    }


    /* ==========================================================================
       12. SEARCH FUNCTIONALITY
       ========================================================================== */

    /**
     * Convert wildcard pattern to regular expression
     * @param {string} pattern - Wildcard pattern (supports *)
     * @returns {RegExp} Compiled regular expression
     */
    function wildcardToRegex(pattern) {
      const escaped = pattern.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
      const regexPattern = escaped.replace(/\*/g, '.*');
      return new RegExp(regexPattern, 'i');
    }

    /**
     * Highlight matching text in a string
     * @param {string} text - Original text
     * @param {string} searchTerm - Search term to highlight
     * @returns {string} HTML with highlighted matches
     */
    function highlightText(text, searchTerm) {
      if (!searchTerm) return escapeHtml(text);
      
      const regex = wildcardToRegex(searchTerm);
      const match = text.match(regex);
      
      if (!match) return escapeHtml(text);
      
      const matchStart = match.index;
      const matchEnd = matchStart + match[0].length;
      
      const before = escapeHtml(text.substring(0, matchStart));
      const matched = escapeHtml(text.substring(matchStart, matchEnd));
      const after = escapeHtml(text.substring(matchEnd));
      
      return `${before}<span class="search-highlight">${matched}</span>${after}`;
    }

    /**
     * Filter tree view based on search term
     * Shows matching items and their parents, hides non-matching items
     * @param {string} searchTerm - Search term (supports wildcards)
     */
    function filterTree(searchTerm) {
      currentSearchTerm = searchTerm;
      const tree = document.getElementById('tree');
      const allItems = tree.querySelectorAll('.tree-item');
      const allChildren = tree.querySelectorAll('.tree-group-children');
      
      // Clear search - show everything, remove highlights
      if (!searchTerm.trim()) {
        allItems.forEach(item => {
          item.classList.remove('search-hidden', 'search-match');
          const label = item.querySelector('.tree-label');
          if (label) {
            const originalText = label.textContent;
            label.innerHTML = escapeHtml(originalText);
          }
        });
        
        allChildren.forEach(child => {
          child.classList.remove('search-expanded');
          const parentGroup = child.previousElementSibling;
          if (parentGroup && parentGroup.classList.contains('expanded')) {
            child.classList.add('expanded');
          } else {
            child.classList.remove('expanded');
          }
        });
        
        return;
      }
      
      const regex = wildcardToRegex(searchTerm);
      const matchingItems = new Set();
      const itemsToShow = new Set();
      
      // First pass: find all matching items
      allItems.forEach(item => {
        const label = item.querySelector('.tree-label');
        if (!label) return;
        
        const text = label.textContent;
        const matches = regex.test(text);
        
        if (matches) {
          matchingItems.add(item);
          item.classList.add('search-match');
          label.innerHTML = highlightText(text, searchTerm);
        } else {
          item.classList.remove('search-match');
          label.innerHTML = escapeHtml(text);
        }
      });
      
      // Second pass: build set of items to show (matches + their parents)
      matchingItems.forEach(item => {
        itemsToShow.add(item);
        
        let current = item;
        while (current) {
          const parentChildren = current.closest('.tree-group-children');
          if (parentChildren) {
            const parentGroup = parentChildren.previousElementSibling;
            if (parentGroup && parentGroup.classList.contains('tree-item')) {
              itemsToShow.add(parentGroup);
              current = parentGroup;
            } else {
              break;
            }
          } else {
            break;
          }
        }
      });
      
      // Third pass: hide non-matching items, show matching items and parents
      allItems.forEach(item => {
        if (itemsToShow.has(item)) {
          item.classList.remove('search-hidden');
        } else {
          item.classList.add('search-hidden');
        }
      });
      
      // Fourth pass: expand parent groups of matches
      allChildren.forEach(child => {
        const parentGroup = child.previousElementSibling;
        if (parentGroup && itemsToShow.has(parentGroup)) {
          child.classList.add('search-expanded');
          if (parentGroup) {
            const toggle = parentGroup.querySelector('.tree-toggle');
            if (toggle) {
              toggle.classList.remove('collapsed');
            }
            parentGroup.classList.add('expanded');
          }
        } else if (!child.classList.contains('expanded')) {
          child.classList.remove('search-expanded');
        }
      });
    }

    // ---- Search-aware lazy expansion helpers --------------------------------
    if (!window._searchExpansionState) window._searchExpansionState = { lastTerm: null, inProgress: false };

    /**
     * Async, non-blocking search for matching paths inside an HDF5 file.
     * Traverses groups with periodic yields to avoid freezing the UI.
     * Returns up to `limit` matching full paths.
     */
    async function asyncFindMatchingPaths(fileNode, regex, limit = 50) {
      const matches = [];
      const stack = [{ node: fileNode, prefix: '' }];
      let processed = 0;

      while (stack.length && matches.length < limit) {
        const { node, prefix } = stack.pop();
        let keys = [];
        try { keys = FileService.keys(node); } catch (e) { continue; }

        for (const key of keys) {
          const path = prefix ? `${prefix}/${key}` : `/${key}`;
          if (regex.test(key) || regex.test(path)) {
            matches.push(path);
            if (matches.length >= limit) break;
          }

          try {
            const child = node.get ? node.get(key) : null;
            if (child && String(child.type).toLowerCase() === 'group') {
              stack.push({ node: child, prefix: path });
            }
          } catch (e) { /* ignore unreadable nodes */ }

          if (++processed % 200 === 0) await new Promise(r => setTimeout(r, 0));
        }
      }
      return matches;
    }

    /**
     * Ensure all ancestor groups for `targetPath` are expanded and loaded.
     * Loads lazy placeholders top-down using `loadGroupChildren()`.
     */
    async function expandAndLoadPath(fileKey, targetPath) {
      const tree = document.getElementById('tree');
      const parts = targetPath.split('/').filter(Boolean);
      let cur = '';

      for (let i = 0; i < parts.length; i++) {
        cur += '/' + parts[i];
        const groupItems = Array.from(tree.querySelectorAll('.tree-item.group'));
        const groupItem = groupItems.find(el => el.getAttribute('data-path') === cur && (el.getAttribute('data-file') === fileKey || !el.getAttribute('data-file')));
        if (!groupItem) break; // cannot proceed if ancestor DOM node missing

        const childrenDiv = groupItem.nextElementSibling;
        if (childrenDiv && childrenDiv.getAttribute && childrenDiv.getAttribute('data-lazy') === 'true' && childrenDiv.getAttribute('data-loaded') !== 'true') {
          await loadGroupChildren(groupItem, cur);
          await new Promise(r => setTimeout(r, 0));
        }
      }
    }

    // Background expansion trigger (best-effort): find matches that are not
    // present in the DOM and expand their parents so they become visible.
    // Runs once per distinct search term to avoid repeated full traversals.
    (function attachSearchAwareExpansion() {
      const originalFilter = filterTree;
      filterTree = function(searchTerm) {
        originalFilter(searchTerm);

        if (!searchTerm || !searchTerm.trim()) return;
        if (window._searchExpansionState.inProgress) return;
        if (window._searchExpansionState.lastTerm === searchTerm) return;

        window._searchExpansionState.lastTerm = searchTerm;
        window._searchExpansionState.inProgress = true;

        (async () => {
          try {
            const regexLocal = wildcardToRegex(searchTerm);
            const enabled = getEnabledFiles();
            let expansions = 0;

            for (const fk of enabled) {
              const file = loadedFiles[fk];
              if (!file) continue;
              const matches = await asyncFindMatchingPaths(file, regexLocal, 50);
              for (const p of matches) {
                const exists = Array.from(document.querySelectorAll('.tree-item')).some(el => el.getAttribute('data-path') === p && (el.getAttribute('data-file') === fk || !el.getAttribute('data-file')));
                if (!exists) {
                  const parentPath = p.substring(0, p.lastIndexOf('/')) || '/';
                  await expandAndLoadPath(fk, parentPath);
                  expansions++;
                  await new Promise(r => setTimeout(r, 10));
                }
              }
            }

            if (expansions > 0) {
              // re-run synchronously to pick up newly loaded DOM nodes
              setTimeout(() => filterTree(searchTerm), 80);
            }
          } catch (e) {
            console.error('search-aware expansion error', e);
          } finally {
            window._searchExpansionState.inProgress = false;
          }
        })();
      };
    })();

    /* ==========================================================================
       13. DRAG & DROP FILE LOADING
       ========================================================================== */

    /**
     * Prevent default browser behavior for drag events.
     * Required to enable custom drop handling for HDF5 files.
     * 
     * @param {Event} e - Drag event to prevent
     * @returns {void}
     */
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    /*
     * Drag & Drop Event Registration
     * 
     * Uses a dragCounter to track nested drag enter/leave events,
     * ensuring the overlay is only hidden when the drag truly leaves
     * the document (not just moving between child elements).
     */
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    document.body.addEventListener('dragenter', (e) => {
      dragCounter++;
      document.getElementById('dropOverlay').classList.add('active');
    });

    document.body.addEventListener('dragleave', (e) => {
      dragCounter--;
      if (dragCounter === 0) {
        document.getElementById('dropOverlay').classList.remove('active');
      }
    });

    document.body.addEventListener('drop', (e) => {
      dragCounter = 0;
      document.getElementById('dropOverlay').classList.remove('active');
      
      const dt = e.dataTransfer;
      const files = dt.files;
      if (files.length > 0) {
        document.getElementById('fileInput').files = files;
        const event = new Event('change', { bubbles: true });
        document.getElementById('fileInput').dispatchEvent(event);
      }
    });


    /* ==========================================================================
       14. CLIPBOARD & EXPORT
       ========================================================================== */
    
    /**
     * Copy the current chart to clipboard as a PNG image.
     * Uses the Clipboard API with ClipboardItem for image data.
     * Falls back to file download if clipboard access is denied or unavailable.
     * 
     * The exported image is rendered at 2x scale (1200x800 at scale 2)
     * for high-quality output suitable for documents and presentations.
     * 
     * @returns {Promise<void>}
     */
    async function copyChartToClipboard() {
      if (!currentChartData) {
        alert('No chart available to copy');
        return;
      }
      
      const plotDiv = document.getElementById('plotlyChart');
      const btn = event.target;
      const originalText = btn.textContent;
      
      try {
        // Check clipboard API availability
        if (!navigator.clipboard || !navigator.clipboard.write) {
          throw new Error('Clipboard API not supported');
        }
        
        // Try to request permission if needed
        try {
          const permissionStatus = await navigator.permissions.query({ name: 'clipboard-write' });
          if (permissionStatus.state === 'denied') {
            throw new Error('Clipboard permission denied');
          }
        } catch (permErr) {
          console.log('Permission query not supported, attempting clipboard write anyway');
        }
        
        // Convert chart to PNG
        const dataUrl = await Plotly.toImage(plotDiv, {
          format: 'png',
          width: 1200,
          height: 800,
          scale: 2
        });
        
        const blob = await fetch(dataUrl).then(r => r.blob());
        
        // Write to clipboard
        await navigator.clipboard.write([
          new ClipboardItem({
            'image/png': blob
          })
        ]);
        
        // Show success feedback
        btn.textContent = '‚úì Copied!';
        btn.style.background = 'var(--color-kvot-accent)';
        
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.background = '';
        }, 2000);
        
      } catch (err) {
        console.error('Clipboard copy failed:', err);
        
        // Fallback to download
        try {
          const dataUrl = await Plotly.toImage(plotDiv, {
            format: 'png',
            width: 1200,
            height: 800,
            scale: 2
          });
          
          const link = document.createElement('a');
          link.href = dataUrl;
          link.download = `chart_${Date.now()}.png`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          // Show download feedback
          btn.textContent = '‚¨á Downloaded';
          btn.style.background = 'var(--color-kvot-accent)';
          
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
          }, 2000);
          
          if (err.message.includes('denied') || err.message.includes('permission')) {
            alert('Clipboard access was denied. The chart has been downloaded instead.');
          }
        } catch (downloadErr) {
          console.error('Download also failed:', downloadErr);
          alert('Failed to copy or download chart: ' + downloadErr.message);
        }
      }
    }


    /* ==========================================================================
       15. EVENT LISTENERS & INITIALIZATION
       ========================================================================== */
    
    /*
     * Application Initialization
     * 
     * The following code runs immediately when the script loads:
     * 1. Initialize DOM element cache for performance
     * 2. Register event handlers for file input, search, resize, etc.
     * 3. Set up keyboard shortcuts and accessibility features
     */
    
    // Initialize cached DOM element references
    initDOMReferences();

    // File load ticker helpers (show per-file progress and tree-refresh state)
    function showFileLoadTicker(current = 0, total = 0, text = '') {
      try {
        const el = document.getElementById('fileLoadTicker');
        if (!el) return;
        el.hidden = false;
        const spinner = el.querySelector('.spinner');
        const txt = el.querySelector('.ticker-text');
        if (spinner) spinner.style.display = 'inline-block';
        if (typeof current === 'number' && typeof total === 'number' && total > 0) {
          txt.textContent = `${current}/${total}${text ? ' ‚Äî ' + text : ' Loading files‚Ä¶'}`;
        } else {
          txt.textContent = text || 'Loading...';
        }
      } catch (e) { console.warn('showFileLoadTicker error', e); }
    }

    function updateFileLoadTicker(current = 0, total = 0, text = '') {
      try {
        const el = document.getElementById('fileLoadTicker');
        if (!el) return;
        el.hidden = false;
        const txt = el.querySelector('.ticker-text');
        txt.textContent = (typeof current === 'number' && total ? `${current}/${total}` : '') + (text ? (current && total ? ' ‚Äî ' + text : ' ' + text) : '');
      } catch (e) { console.warn('updateFileLoadTicker error', e); }
    }

    function hideFileLoadTicker() {
      try { const el = document.getElementById('fileLoadTicker'); if (!el) return; el.hidden = true; const bar = el.querySelector('.ticker-progress-bar'); if (bar) bar.style.width = '0%'; } catch (e) { console.warn(e); }
    }


    
    /**
     * File input change handler.
     * Processes selected HDF5 files, loads them via h5wasm,
     * and adds them to the file tabs for viewing.
     * 
     * @listens change
     */
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const files = Array.from(e.target.files || []);
      if (files.length === 0) return;

      // show progress ticker (file count known)
      showFileLoadTicker(0, files.length, 'Starting‚Ä¶');

      try {
        await waitForH5Wasm();

        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          // update ticker with current file being processed
          updateFileLoadTicker(i, files.length, file.name);
          try {
            const buffer = await file.arrayBuffer();
            
            const { FS, File } = window.h5wasm;
            if (!FS || !File) throw new Error('h5wasm not ready');
            
            const filename = `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.h5`;
            const data = new Uint8Array(buffer);
            
            FS.writeFile('/' + filename, data);
            const hf = new File('/' + filename, 'r');
            
            loadedFiles[file.name] = hf;
            fileStates[file.name] = true;
            if (!fileOrder.includes(file.name)) {
              fileOrder.push(file.name);
            }
            // log per-file load (toasts removed)
            console.log(`Loaded ${file.name}`);
          } catch (err) {
            console.error(`Error loading ${file.name}:`, err);
            alert(`Failed to load ${file.name}`);
          }
        }
        
        // Update tabs (returns a promise that resolves when tree rebuild completes)
        updateFileLoadTicker(files.length, files.length, 'Refreshing tree...');
        await updateTabs();
        hideFileLoadTicker();
      } catch (err) {
        hideFileLoadTicker();
        alert(`Error: ${err.message}`);
        console.error(err);
      }
      
      e.target.value = '';
    });

    /**
     * Search input handler with 200ms debouncing.
     * Filters the tree view to show only matching items.
     * Shows/hides the clear button based on input state.
     * 
     * @listens input
     */
    document.getElementById('treeSearch').addEventListener('input', (e) => {
      const searchTerm = e.target.value;
      const clearBtn = document.getElementById('clearSearch');
      
      if (searchTerm) {
        clearBtn.classList.add('visible');
      } else {
        clearBtn.classList.remove('visible');
      }
      
      // Debounce the search
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }
      
      searchTimeout = setTimeout(() => {
        filterTree(searchTerm);
      }, 200);
    });

    /**
     * Clear search button handler.
     * Resets search input, removes filter, and refocuses the input.
     * 
     * @listens click
     */
    document.getElementById('clearSearch').addEventListener('click', () => {
      const searchInput = document.getElementById('treeSearch');
      searchInput.value = '';
      document.getElementById('clearSearch').classList.remove('visible');
      filterTree('');
      searchInput.focus();
    });

    /**
     * Keyboard shortcut: Escape key clears the search input.
     * Provides quick way to reset the tree filter.
     * 
     * @listens keydown
     */
    document.getElementById('treeSearch').addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.getElementById('clearSearch').click();
      }
    });

    /**
    /**
     * Decorator: Re-apply search filter after tree structure refresh.
     * Ensures that if the user has an active search term, it persists
     * when the tree is rebuilt (e.g., after file reordering).
     */
    const originalRefreshTreeStructure = refreshTreeStructure;
    refreshTreeStructure = async function() {
      await originalRefreshTreeStructure();
      const searchTerm = document.getElementById('treeSearch').value;
      if (searchTerm) {
        setTimeout(() => filterTree(searchTerm), 50);
      }
    };

    /**
     * Responsive chart resizing using ResizeObserver.
     * Automatically resizes the Plotly chart when its container changes size.
     * Debounced to 100ms to prevent excessive resize operations.
     */
    const plotlyChart = document.getElementById('plotlyChart');
    let resizeTimeout;
    const resizeObserver = new ResizeObserver(entries => {
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = setTimeout(() => {
        for (const entry of entries) {
          if (entry.target === plotlyChart && plotlyChart.data) {
            Plotly.Plots.resize(plotlyChart);
          }
        }
      }, 100);
    });
    
    if (plotlyChart) {
      resizeObserver.observe(plotlyChart);
    }
  </script>

  <script>
    // Panel resize handle
    (function() {
      const handle = document.getElementById('resizeHandle');
      const leftPanel = document.getElementById('leftPanel');
      const container = leftPanel.parentElement;
      let startX, startWidth;

      handle.addEventListener('mousedown', function(e) {
        e.preventDefault();
        e.stopPropagation();
        startX = e.clientX;
        startWidth = leftPanel.getBoundingClientRect().width;
        handle.classList.add('active');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        // Block pointer events on everything else during drag
        container.style.pointerEvents = 'none';
        handle.style.pointerEvents = 'auto';

        function onMouseMove(e) {
          e.preventDefault();
          const dx = e.clientX - startX;
          const maxW = container.getBoundingClientRect().width * 0.6;
          const newWidth = Math.max(150, Math.min(startWidth + dx, maxW));
          leftPanel.style.flex = '0 0 ' + newWidth + 'px';
        }

        function onMouseUp() {
          handle.classList.remove('active');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          container.style.pointerEvents = '';
          handle.style.pointerEvents = '';
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          window.dispatchEvent(new Event('resize'));
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
    })();
  </script>
</body>
</html>