<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="icon" type="image/png" sizes="16x16" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB8lBMVEUARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARXYARHUARHUARHUARHUCRncUVIETU4AIS3oTU4ABRXYARHYANGlBdJkhXYi/0NypwNE8cZbC095OfqAAM2kAK2Ohus1Ug6Pf6O6OrcI2bJPr8fSzx9YAOGyguswpY4zf5+5XhKQyaZHs8fWctsoANWoAMmg/c5gsZY62ythKe57p7/NMfZ8AMGcAPG86b5VZhqbj6/Bah6br8PStw9MAN2sAKmKatslVg6Pg6O7k6/CpwNEANGo0a5IeW4aqwdGswtJEd5uwxtUvaJAAN2wDRncBRXYJS3sJS3sESHgJTHsARXYARXYARHUARHUARXYARXYARHUARHUARXYARHUARHUARXYARXYARHYARHUNTn0VVIEGSHgRUX8LTHsWVYIQUX+8ztvW4emBo7ulvc6MqsHX4enF1eDw9Pe9ztvf6O7g6O7k6/DI1+Hi6u/y9vh8oLlGeJz////6+/y+z9zX4urJ1+Katsn6/Pz4+vve5+1tlbGmvs/r8fTP3OW0yNbz9vjN2+Tn7fLI1uHX4unp7/Otw9PE1N96nreXs8eOrcLG1eCov9AHSnkKTHsISnoHSnoLTXwHSXlgx+EhAAAAanRSTlMLYnd2Um5xUXUZ0/6w7vOv/NSx/e7z/dSx7vOw/dQZGdSx7vOw/dQZGdSx7vOw/dQZ1LHu87D91BkZ1LHzsP3UGRnUsfOw/dQZGdSx7vPUGdSx7vOw/dQZ/rDu87D8DGR6eXpUcHRTd3tlDK+lHQAAAAFiS0dEhRXXaucAAAAHdElNRQfmCB4IBCY0DSgTAAAA8klEQVQY02NgYGRiZmZhZWZmY+dgZmJkYODkyuLm5uHNyuLjF+DO4uJk4BTMysoSAgnwCGdlCRInkJ2TJSSSky3KI5aTAxIQz83Ll5AsKJSSlikqlpVjkFcoKS1TVCqvUFZRraxSU2fQ0KyuqdXSrqvX0dVraNQ3YNAwbGpuMTJubTMxNWvvMLdgsLTqrO6yNu7usbG1a+q1d2BwdOrrn+CsPbHKxdVtUqm7B4On1+QpU719ptX4utpNn+FnweAfMHPW7MCgOXODQ0LnzQ8LB7pjwcKIyKhFi6NjYpcsFedkiItPSExKTklMSE1LT8zIjAMAkOZIz65wIlsAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjItMDgtMzBUMDg6MDQ6MzgrMDA6MDCWf9PgAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIyLTA4LTMwVDA4OjA0OjM4KzAwOjAw5yJrXAAAAFd6VFh0UmF3IHByb2ZpbGUgdHlwZSBpcHRjAAB4nOPyDAhxVigoyk/LzEnlUgADIwsuYwsTIxNLkxQDEyBEgDTDZAMjs1Qgy9jUyMTMxBzEB8uASKBKLgDqFxF08kI1lQAAAABJRU5ErkJggg=="/>
  <link rel="mask-icon" type="image/svg" href="data:image/svg;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iNzg0LjAwMDAwMHB0IiBoZWlnaHQ9Ijc4NC4wMDAwMDBwdCIgdmlld0JveD0iMCAwIDc4NC4wMDAwMDAgNzg0LjAwMDAwMCIKIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiPgo8bWV0YWRhdGE+CkNyZWF0ZWQgYnkgcG90cmFjZSAxLjE0LCB3cml0dGVuIGJ5IFBldGVyIFNlbGluZ2VyIDIwMDEtMjAxNwo8L21ldGFkYXRhPgo8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCw3ODQuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApIgpmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiPgo8cGF0aCBkPSJNNTMwIDM5MTUgbDAgLTM2MjUgMTA3NSAwIDEwNzUgMCAwIDM2MjUgMCAzNjI1IC0xMDc1IDAgLTEwNzUgMCAwCi0zNjI1eiBtMTczNCAyMDkgbDIzNiAtMjQ3IDAgLTI2OCAwIC0yNjkgLTM4MCAwIC0zODAgMCAtMiAyMTggLTMgMjE3IC0xMDcgMwotMTA4IDMgMCAtMzQ1IDAgLTM0NiAyMyAtNSBjMTIgLTMgMTIzIC0yNiAyNDcgLTUwIGwyMjUgLTQ1IDIzOCAtMjM4IDIzNwotMjM3IDAgLTUxMCAwIC01MTEgLTIwOCAtMjA3IC0yMDkgLTIwNyAtNDgwIDAgLTQ3OSAwIC0xOTcgMjI0IC0xOTcgMjI0IDAKMzAxIDAgMzAxIDM5OCAtMiAzOTcgLTMgMyAtMjI3IDIgLTIyOCAxMDUgMCAxMDUgMCAwIDMzNCBjMCAzMTAgLTEgMzM1IC0xNwozNDAgLTEwIDMgLTEyOCAyNiAtMjYzIDUxIC0xMzUgMjUgLTI1MiA0OSAtMjYxIDUzIC04IDQgLTExOCAxMTEgLTI0MiAyMzkKbC0yMjcgMjMyIDAgNTI0IDAgNTIzIDIzOCAyMDEgMjM3IDIwMiA0MTcgMCA0MTcgMSAyMzUgLTI0NnoiLz4KPHBhdGggZD0iTTI4NjAgMzkxNSBsMCAtMzYyNSAxMDc1IDAgMTA3NSAwIDAgMzYyNSAwIDM2MjUgLTEwNzUgMCAtMTA3NSAwIDAKLTM2MjV6IG05NzAgLTI4IGw1IC00ODggMTg1IDQ4NSAxODUgNDg2IDMzOSAwIDMzOCAwIC02IC0yMiBjLTMgLTEzIC05MyAtMzEzCi0yMDEgLTY2NyBsLTE5NiAtNjQ1IDI4IC0yNiBjMTUgLTE1IDEwMyAtOTYgMTk2IC0xODAgbDE2NyAtMTUyIDAgLTc5OSAwCi03OTkgLTQwNSAwIC00MDUgMCAtMiA2ODIgLTMgNjgzIC0xMTIgMyAtMTEzIDMgMCAtNjg2IDAgLTY4NSAtNDIwIDAgLTQyMCAwCjAgMTY1MCAwIDE2NTAgNDE4IC0yIDQxNyAtMyA1IC00ODh6Ii8+CjxwYXRoIGQ9Ik01MTkwIDM5MTUgbDAgLTM2MjUgMTA2MCAwIDEwNjAgMCAwIDM2MjUgMCAzNjI1IC0xMDYwIDAgLTEwNjAgMCAwCi0zNjI1eiBtMTc0NyAyNDMgbDIxMyAtMjEzIDAgLTQzNSAwIC00MzYgLTIwMiAtMTYwIGMtMTEyIC04OCAtMjAzIC0xNjUgLTIwMwotMTcxIDAgLTYgOTAgLTgwIDIwMCAtMTY1IGwyMDAgLTE1NCAzIC00MzkgMiAtNDQwIC0yNDcgLTIzNyAtMjQ4IC0yMzcgLTY0NwotMSAtNjQ4IDAgMCAxNjUwIDAgMTY1MCA2ODIgMCA2ODMgMCAyMTIgLTIxMnoiLz4KPHBhdGggZD0iTTYxODAgMzM5NSBsMCAtMzc1IDEyMCAwIDEyMCAwIC0yIDM3MyAtMyAzNzIgLTExNyAzIC0xMTggMyAwIC0zNzZ6Ii8+CjxwYXRoIGQ9Ik02MTgwIDIwODUgbDAgLTM3NiAxMTggMyAxMTcgMyAzIDM3MyAyIDM3MiAtMTIwIDAgLTEyMCAwIDAgLTM3NXoiLz4KPC9nPgo8L3N2Zz4K" color="#5bbad5">
  <title>HDF5 File Viewer</title>
  <link href="https://unpkg.com/leaflet@1.9.2/dist/leaflet.css" rel="stylesheet">
  <script src="https://unpkg.com/leaflet@1.9.2/dist/leaflet.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="resources/js/xlsxwrite.js"></script>
  <script>
    // xlsxwrite.js is ready immediately after loading (no WASM initialization needed)
    window.xlsxReady = true;
    console.log('xlsxwrite.js loaded');
  </script>
  <link rel="stylesheet" href="./resources/css/kvot.css">
  <link rel="stylesheet" href="./resources/css/rb.css">
</head>
<body>
  <div id="dropOverlay">
    <div class="message">üìÅ Drop HDF5 files here</div>
  </div>
  
  <header></header>

  <input id="fileInput" type="file" accept=".h5,.hdf5,.he5" multiple />

  <div class="container">
    <div class="panel" id="leftPanel">
      <div class="panel-heading">
        <h3>File Structure</h3>
        <label id="intersectLabel" class="intersect-checkbox" style="display: none;">
          <input type="checkbox" id="intersectCheckbox" onchange="toggleIntersect()">
          Intersect Data
        </label>
      </div>
      <div class="search-container">
        <input 
          type="text" 
          id="treeSearch" 
          placeholder="Search tree (use * for wildcard)..." 
          autocomplete="off"
        />
        <button id="clearSearch" class="clear-search-btn" title="Clear search">√ó</button>
      </div>
      <div id="tree" class="loading">Drop HDF5 files or click "+ Add Files" to start...</div>
    </div>

    <div class="resize-handle" id="resizeHandle"></div>

    <div class="panel">
      <div class="right-panel-content">
        <div id="plotlyChartContainer">
          <h3>Chart</h3>
          <div class="chart-controls">
            <label>
              X-axis:
              <select id="xAxisScale" onchange="updateChartScales()">
                <option value="linear">Linear</option>
                <option value="log">Log</option>
              </select>
            </label>
            <label>
              Y-axis:
              <select id="yAxisScale" onchange="updateChartScales()">
                <option value="linear">Linear</option>
                <option value="log">Log</option>
              </select>
            </label>
            <label >
              <input type="checkbox" id="dynamicLegend" checked onchange="toggleDynamicLegend()">
              Dynamic Legend
            </label>
            <label id="showTotalLabel" style="display: none;">
              <input type="checkbox" id="showTotal" checked onchange="toggleShowTotal()">
              Show Total
            </label>
            <label id="showRatioLabel" style="display: none;">
              <input type="checkbox" id="showRatio" onchange="toggleShowRatio()">
              Show Ratio
            </label>
            <span id="legendStatus" style=" font-size: 12px; color: var(--color-text-muted);"></span>
            <button onclick="applyReleasePresetView()" style="margin-left: auto;">Apply Release View</button>
            <button onclick="applyDosePresetView()">Apply Dose View</button>
          </div>
          <div id="histControls" class="chart-controls" style="display: none;">
            <span style="font-weight: 600; font-size: 13px; display: inline-flex; align-items: center; gap: 4px;">üìä Data preview</span>
            <label id="histLogLabel" style="margin-left: auto;">
              <input type="checkbox" id="histLogScale" onchange="toggleHistLog()">
              Log‚ÇÅ‚ÇÄ scale
            </label>
          </div>
          <div id="plotlyChart"></div>
        </div>
        
        <div>
          <h3>Dataset Information</h3>
            <div class="multi-select-hint" style="display: none;" id="multiSelectHint">
              üí° <strong>Tip:</strong> Hold Ctrl (‚åò on Mac) and click datasets to compare multiple
            </div>
            <div id="info">Select a dataset to view its details</div>
        </div>
      </div>
    </div>
  </div>

  <div id="map"></div>
  <footer></footer>

  <script src="./resources/js/erf.js"></script>
  <script src="./resources/js/site.js"></script>
  <script>
    KVOT.renderHeader('&nbsp;hdf result browser', '<div class="tabs-container"><div id="fileTabs"></div><button class="add-file-btn" onclick="document.getElementById(\'fileInput\').click()">+ Add Files</button></div>');
    KVOT.renderNav('rb.html');
    KVOT.renderFooter();
    KVOT.initMap('map');
  </script>

  <script src="https://cdn.jsdelivr.net/npm/h5wasm@latest/dist/iife/h5wasm.min.js"></script>
  <script>
    /* ==========================================================================
       HDF5 FILE VIEWER - JAVASCRIPT APPLICATION
       ==========================================================================
       
       Module Organization:
       1. GLOBAL STATE & CONFIGURATION
       2. UTILITY FUNCTIONS
       3. HDF5 DATA ACCESS
       4. FILE MANAGEMENT
       5. TAB MANAGEMENT
       6. TREE VIEW
       7. RADIONUCLIDE LINE STYLES
       8. CHART CONTROLS
       9. CHART CREATION
       10. DYNAMIC LEGEND
       11. DATASET INFORMATION DISPLAY
       12. SEARCH FUNCTIONALITY
       13. DRAG & DROP
       14. CLIPBOARD & EXPORT
       15. EVENT LISTENERS & INITIALIZATION
       
       ========================================================================== */


    /**
     * ==========================================================================
     * HDF5 FILE VIEWER APPLICATION
     * ==========================================================================
     * 
     * A browser-based viewer for HDF5 files with interactive tree navigation,
     * Plotly.js charting, and multi-file comparison capabilities.
     * 
     * @overview
     * - Section 1: Global State & Configuration
     * - Section 2: Utility Functions  
     * - Section 3: HDF5 Data Access
     * - Section 4: File Management
     * - Section 5: Tab Management
     * - Section 6: Tree View
     * - Section 7: Radionuclide Line Styles
     * - Section 8: Chart Controls
     * - Section 9: Chart Creation
     * - Section 10: Dynamic Legend
     * - Section 11: Dataset Information Display
     * - Section 12: Search Functionality
     * - Section 13: Drag & Drop
     * - Section 14: Clipboard & Export
     * - Section 15: Event Listeners & Initialization
     * 
     * @requires h5wasm - WebAssembly-based HDF5 library
     * @requires Plotly.js - Interactive charting library
     * @requires SortableJS - Drag-and-drop sorting library
     * 
     * @author KVOT Development Team
     * @version 2.0.0
     */

    /* ==========================================================================
       1. GLOBAL STATE & CONFIGURATION
       ========================================================================== */
    
    /**
     * @typedef {Object} FileState
     * @property {boolean} enabled - Whether the file is currently enabled for display
     */

    /**
     * @typedef {Object} ChartData
     * @property {Array} traces - Plotly trace data
     * @property {Object} layout - Plotly layout configuration
     * @property {string} path - Dataset path being charted
     */

    /** @type {Object.<string, Object>} Map of filename to HDF5 file objects */
    let loadedFiles = {};
    /** @type {Object.<string, boolean>} Map of filename to enabled/disabled state */
    let fileStates = {};
    /** @type {string[]} Ordered list of filenames (determines tab order) */
    let fileOrder = [];
    
    // Selection state
    /** @type {string|null} Currently selected HDF5 path in the tree view */
    let selectedDatasetPath = null;
    /** @type {boolean} True if the selected path is a radionuclides group (for special charting) */
    let selectedIsRadionuclidesGroup = false;
    /** @type {{path: string, fileKey: string|null}[]} Array of selected datasets in multi-select mode (Ctrl+click) */
    let selectedDatasets = [];
    /** @type {boolean} True when user is selecting multiple datasets with Ctrl/Cmd key */
    let multiSelectMode = false;
    /** @type {string|null} File key of the tree node that was clicked (null = use all enabled files) */
    let selectedFileKey = null;
    
    // Chart state
    /** @type {ChartData|null} Current chart data (traces, layout, path) for export/clipboard */
    let currentChartData = null;
    /** @type {boolean} True when the chart area is showing a PDF histogram (not a time-series chart) */
    let currentPdfHistogram = false;
    /** @type {Object|null} Stored PDF histogram data for re-rendering on theme/log change */
    let currentPdfHistogramData = null;
    /** @type {string|null} Filename of the first enabled file (determines tree structure source) */
    let currentTreeFile = null;
    
    // Dynamic legend state
    /** @type {boolean} When true, legend updates to show only traces visible in current viewport */
    let dynamicLegendEnabled = true;
    
    // Search state
    /** @type {number|null} Timeout ID for debounced search input */
    let searchTimeout = null;
    /** @type {string} Current search/filter term applied to tree view */
    let currentSearchTerm = '';
    
    // Drag & drop state
    /** @type {number} Counter for drag enter/leave events to handle nested elements */
    let dragCounter = 0;


    /* ==========================================================================
       1.1 CONSTANTS
       ========================================================================== */
    
    /**
     * Default placeholder message shown in the info panel when no dataset is selected.
     * @constant {string}
     */
    const INFO_PANEL_DEFAULT_MESSAGE = 'Select a dataset to view its details';
    
    /**
     * Standard legend positioning for Plotly charts.
     * Places legend to the right of the chart area.
     * @constant {Object}
     */
    const CHART_LEGEND_CONFIG = {
      x: 1.02,      // Slightly right of chart area
      y: 1,         // Top aligned
      xanchor: 'left',
      yanchor: 'top'
    };
    
    /**
     * Y-axis exponent display settings for scientific notation.
     * Shows all exponents in power format (e.g., 10^6 instead of 1e6).
     * @constant {Object}
     */
    const CHART_YAXIS_EXPONENT = {
      showexponent: 'all',
      exponentformat: 'power'
    };
    
    /**
     * Chart margins with extra right padding for legend.
     * @constant {Object}
     */
    const CHART_MARGIN_WITH_LEGEND = { t: 10, r: 150,  b: 60 };


    /* ==========================================================================
       1.2 DOM ELEMENT HELPERS
       ========================================================================== */
    
    /**
     * Cached DOM element references (initialized on DOMContentLoaded)
     * @type {Object.<string, HTMLElement>}
     */
    const DOM = {};
    
    /**
     * Initialize cached DOM element references
     * Call once after DOM is ready
     */
    function initDOMReferences() {
      DOM.plotlyChart = document.getElementById('plotlyChart');
      DOM.plotlyChartContainer = document.getElementById('plotlyChartContainer');
      DOM.info = document.getElementById('info');
      DOM.tree = document.getElementById('tree');
      DOM.xAxisScale = document.getElementById('xAxisScale');
      DOM.yAxisScale = document.getElementById('yAxisScale');
      DOM.searchInput = document.getElementById('searchInput');
      DOM.searchResults = document.getElementById('searchResults');
      DOM.tabs = document.getElementById('tabs');
      DOM.showTotal = document.getElementById('showTotal');
      DOM.showTotalContainer = document.getElementById('showTotalContainer');
      DOM.showTotalLabel = document.getElementById('showTotalLabel');
      DOM.showRatio = document.getElementById('showRatio');
      DOM.showRatioLabel = document.getElementById('showRatioLabel');
      DOM.dynamicLegendToggle = document.getElementById('dynamicLegendToggle');
      DOM.dropZone = document.getElementById('dropZone');
      DOM.fileTabs = document.getElementById('fileTabs');
    }
    
    /**
     * Get element by ID (with fallback if DOM cache not initialized)
     * @param {string} id - Element ID
     * @returns {HTMLElement|null}
     */
    function getElement(id) {
      return DOM[id] || document.getElementById(id);
    }
    
    /**
     * Show or hide the "Show Total" checkbox based on context
     * @param {boolean} show - Whether to show the checkbox
     */
    function setShowTotalVisible(show) {
      const label = getElement('showTotalLabel');
      if (label) {
        label.style.display = show ? '' : 'none';
      }
    }

    /**
     * Show or hide the "Show Ratio" checkbox based on context.
     * Only shown when there are exactly two enabled files (thick + thin lines).
     * @param {boolean} show - Whether to show the checkbox
     */
    function setShowRatioVisible(show) {
      const label = getElement('showRatioLabel');
      if (label) {
        label.style.display = show ? '' : 'none';
      }
    }


    /* ==========================================================================
       2. UTILITY FUNCTIONS
       ========================================================================== */
    
    /**
     * Wait for h5wasm library to be loaded and ready
     */
    async function waitForH5Wasm() {
      let attempts = 0;
      while (!window.h5wasm && attempts < 50) {
        await new Promise(r => setTimeout(r, 100));
        attempts++;
      }
      if (!window.h5wasm) throw new Error('h5wasm failed to load');
      if (window.h5wasm.ready instanceof Promise) await window.h5wasm.ready;
      return window.h5wasm;
    }

    /**
     * Escape HTML special characters for safe rendering
     */
    function escapeHtml(text) {
      const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
      return String(text).replace(/[&<>"']/g, m => map[m]);
    }
    
    /**
     * Detect if an HDF5 path is a soft link, external link, or broken soft link.
     * @param {Object} group - h5wasm Group or File object
     * @param {string} path - Absolute HDF5 path
     * @param {Object} [obj] - The object returned by group.get(key), if already fetched
     * @returns {Object|null} Link info or null if not a link
     */
    function getLinkInfo(group, path, obj) {
      try {
        if (obj && String(obj.type) === 'BrokenSoftLink') {
          return { type: 'broken', target: obj.target || '?' };
        }
        if (obj && String(obj.type) === 'ExternalLink') {
          return { type: 'external', filename: obj.filename || '?', obj_path: obj.obj_path || '?' };
        }
        // Check for resolved soft link
        const softTarget = group.get_link(path);
        if (softTarget) {
          return { type: 'soft', target: softTarget };
        }
      } catch (e) { /* not a link */ }
      return null;
    }

    /**
     * Build a small link badge HTML for the tree view.
     * @param {Object} linkInfo - Link info from getLinkInfo()
     * @returns {string} HTML string for the badge
     */
    function buildLinkBadge(linkInfo) {
      if (!linkInfo) return '';
      let tooltip, cls;
      if (linkInfo.type === 'broken') {
        tooltip = 'Broken link \u2192 ' + linkInfo.target;
        cls = 'broken';
      } else if (linkInfo.type === 'external') {
        tooltip = 'External \u2192 ' + linkInfo.filename + ':' + linkInfo.obj_path;
        cls = 'external';
      } else {
        tooltip = 'Link \u2192 ' + linkInfo.target;
        cls = 'soft';
      }
      return `<span class="link-badge ${cls}" title="${escapeHtml(tooltip)}"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg></span>`;
    }

    /* ==========================================================================
       PDF SAMPLING ENGINE
       Mirrors the Python Distribution class from samp_util.py.
       Supports: uniform, triangular, dtriangular, normal, exponential,
       loguniform, logtriangular, logdtriangular, lognormal, raw/empirical.
       ========================================================================== */

    /** Inverse CDF: Uniform(a, b) */
    function invUnif(p, a, b) { return a + (b - a) * p; }

    /** Inverse CDF: Triangular(a, b, m) */
    function invTriang(p, a, b, m) {
      const fc = (m - a) / (b - a);
      return p < fc
        ? a + Math.sqrt((b - a) * (m - a) * p)
        : b - Math.sqrt((b - a) * (b - m) * (1 - p));
    }

    /** Inverse CDF: Double-triangular(a, b, m) */
    function invDtriang(p, a, b, m) {
      return p <= 0.5
        ? a + Math.sqrt(2 * p) * (m - a)
        : b - (b - m) * Math.sqrt(2 * (1 - p));
    }

    /** Inverse CDF: Normal(mean, std) ‚Äî uses erfinv from erf.js */
    function invNorm(p, mean, std) {
      return mean + std * Math.SQRT2 * erfinv(2 * p - 1);
    }

    /** Inverse CDF: Exponential(mean) */
    function invExp(p, mean) { return -mean * Math.log(1 - p); }

    /** Inverse CDF: Log-uniform(a, b) */
    function invLogu(p, a, b) {
      return Math.exp(invUnif(p, Math.log(a), Math.log(b)));
    }

    /** Inverse CDF: Log-triangular(a, b, m) */
    function invLogt(p, a, b, m) {
      return Math.exp(invTriang(p, Math.log(a), Math.log(b), Math.log(m)));
    }

    /** Inverse CDF: Double-log-triangular(a, b, m) */
    function invLogdt(p, a, b, m) {
      return Math.exp(invDtriang(p, Math.log(a), Math.log(b), Math.log(m)));
    }

    /** Inverse CDF: Log-normal(gm, gsd) */
    function invLogn(p, gm, gsd) {
      return Math.exp(invNorm(p, Math.log(gm), Math.log(gsd)));
    }

    /** Inverse CDF: Empirical (quantile interpolation) */
    function invEmpirical(p, data) {
      const sorted = Float64Array.from(data).sort();
      const idx = p * (sorted.length - 1);
      const lo = Math.floor(idx);
      const hi = Math.min(lo + 1, sorted.length - 1);
      const frac = idx - lo;
      return sorted[lo] + frac * (sorted[hi] - sorted[lo]);
    }

    /**
     * CDF helper for truncation support.
     * Returns CDF(x) for the given distribution.
     */
    function cdfForDist(type, x, args) {
      // Only needed for trmin/trmax ‚Äî simplified implementations
      switch (type) {
        case 'uniform': case 'unif': {
          const { a, b } = args;
          return x <= a ? 0 : x >= b ? 1 : (x - a) / (b - a);
        }
        case 'triangular': case 'triang': {
          const { a, b, m } = args;
          if (x <= a) return 0; if (x >= b) return 1;
          return x <= m ? (x - a) ** 2 / ((m - a) * (b - a)) : 1 - (b - x) ** 2 / ((b - a) * (b - m));
        }
        case 'normal': case 'norm': {
          const { mean, std } = args;
          return 0.5 * (1 + erf((x - mean) / (std * Math.SQRT2)));
        }
        case 'exponential': case 'exp': {
          const { mean } = args;
          return x <= 0 ? 0 : 1 - Math.exp(-x / mean);
        }
        case 'loguniform': case 'logu': case 'logunif': {
          const { a, b } = args;
          return x <= a ? 0 : x >= b ? 1 : (Math.log(x) - Math.log(a)) / (Math.log(b) - Math.log(a));
        }
        case 'lognormal': case 'logn': case 'lognorm': {
          const { gm, gsd } = args;
          return 0.5 * (1 + erf((Math.log(x) - Math.log(gm)) / (Math.log(gsd) * Math.SQRT2)));
        }
        default: return null;
      }
    }

    /**
     * Evaluate the analytical probability density function (PDF) at x.
     * @param {string} type - Distribution type key
     * @param {number} x - Value at which to evaluate
     * @param {Object} args - Distribution parameters
     * @returns {number|null} PDF value, or null if type unsupported
     */
    function pdfEval(type, x, args) {
      switch (type) {
        case 'uniform': case 'unif': {
          const { a, b } = args;
          return (x >= a && x <= b) ? 1 / (b - a) : 0;
        }
        case 'triangular': case 'triang': {
          const { a, b, m } = args;
          if (x < a || x > b) return 0;
          return x <= m
            ? 2 * (x - a) / ((b - a) * (m - a))
            : 2 * (b - x) / ((b - a) * (b - m));
        }
        case 'dtriangular': case 'dtriang': {
          const { a, b, m } = args;
          if (x < a || x > b) return 0;
          return x <= m
            ? (x - a) / ((m - a) * (m - a))
            : (b - x) / ((b - m) * (b - m));
        }
        case 'normal': case 'norm': {
          const { mean, std } = args;
          const z = (x - mean) / std;
          return Math.exp(-0.5 * z * z) / (std * Math.sqrt(2 * Math.PI));
        }
        case 'exponential': case 'exp': {
          const { mean } = args;
          return x < 0 ? 0 : (1 / mean) * Math.exp(-x / mean);
        }
        case 'loguniform': case 'logu': case 'logunif': {
          const { a, b } = args;
          return (x <= a || x >= b) ? 0 : 1 / (x * (Math.log(b) - Math.log(a)));
        }
        case 'logtriangular': case 'logt': case 'logtriang': {
          const { a, b, m } = args;
          if (x <= a || x >= b) return 0;
          const la = Math.log(a), lb = Math.log(b), lm = Math.log(m), lx = Math.log(x);
          const fLog = lx <= lm
            ? 2 * (lx - la) / ((lb - la) * (lm - la))
            : 2 * (lb - lx) / ((lb - la) * (lb - lm));
          return fLog / x;
        }
        case 'logdtriangular': case 'logdt': case 'logdtriang': {
          const { a, b, m } = args;
          if (x <= a || x >= b) return 0;
          const la = Math.log(a), lb = Math.log(b), lm = Math.log(m), lx = Math.log(x);
          const fLog = lx <= lm
            ? (lx - la) / ((lm - la) * (lm - la))
            : (lb - lx) / ((lb - lm) * (lb - lm));
          return fLog / x;
        }
        case 'lognormal': case 'logn': case 'lognorm': {
          const { gm, gsd } = args;
          if (x <= 0) return 0;
          const mu = Math.log(gm), sigma = Math.log(gsd);
          const z = (Math.log(x) - mu) / sigma;
          return Math.exp(-0.5 * z * z) / (x * sigma * Math.sqrt(2 * Math.PI));
        }
        default: return null;
      }
    }

    /**
     * Map from type string to inverse-CDF caller.
     */
    const DIST_INV = {
      'unif':           (p, a) => invUnif(p, a.a, a.b),
      'uniform':        (p, a) => invUnif(p, a.a, a.b),
      'triang':         (p, a) => invTriang(p, a.a, a.b, a.m),
      'triangular':     (p, a) => invTriang(p, a.a, a.b, a.m),
      'dtriang':        (p, a) => invDtriang(p, a.a, a.b, a.m),
      'dtriangular':    (p, a) => invDtriang(p, a.a, a.b, a.m),
      'norm':           (p, a) => invNorm(p, a.mean, a.std),
      'normal':         (p, a) => invNorm(p, a.mean, a.std),
      'exp':            (p, a) => invExp(p, a.mean),
      'exponential':    (p, a) => invExp(p, a.mean),
      'logu':           (p, a) => invLogu(p, a.a, a.b),
      'logunif':        (p, a) => invLogu(p, a.a, a.b),
      'loguniform':     (p, a) => invLogu(p, a.a, a.b),
      'logt':           (p, a) => invLogt(p, a.a, a.b, a.m),
      'logtriang':      (p, a) => invLogt(p, a.a, a.b, a.m),
      'logtriangular':  (p, a) => invLogt(p, a.a, a.b, a.m),
      'logdt':          (p, a) => invLogdt(p, a.a, a.b, a.m),
      'logdtriang':     (p, a) => invLogdt(p, a.a, a.b, a.m),
      'logdtriangular': (p, a) => invLogdt(p, a.a, a.b, a.m),
      'logn':           (p, a) => invLogn(p, a.gm, a.gsd),
      'lognorm':        (p, a) => invLogn(p, a.gm, a.gsd),
      'lognormal':      (p, a) => invLogn(p, a.gm, a.gsd),
      'emp':            (p, a) => invEmpirical(p, a.data),
      'empirical':      (p, a) => invEmpirical(p, a.data),
    };

    /**
     * Generate n random samples from a PDF specification object.
     * Mirrors Python's Distribution(pdf).rnd() from samp_util.py.
     *
     * @param {Object} pdf - PDF spec, e.g. {type:'normal', mean:5, std:1}
     * @param {number} [n=1000] - Number of samples
     * @returns {Float64Array|null} Array of samples, or null if type unknown
     */
    function generatePdfSamples(pdf, n = 1000) {
      if (!pdf || !pdf.type) return null;
      const typeKey = pdf.type.toLowerCase();

      // "raw" type: return the data array from the dataset directly
      if (typeKey === 'raw') return null; // handled separately by caller

      const invFn = DIST_INV[typeKey];
      if (!invFn) return null;

      // Distribution parameters (everything except meta-keys)
      const args = { ...pdf };
      delete args.type;

      // Truncation params
      const pmin = pdf.pmin ?? 0;
      const pmax = pdf.pmax ?? 1;
      const trmin = pdf.trmin ?? null;
      const trmax = pdf.trmax ?? null;
      const shift = pdf.shift ?? 0;

      // Compute effective probability bounds with optional value truncation
      let effPmin = pmin;
      let effPmax = pmax;
      if (trmin !== null) {
        const c = cdfForDist(typeKey, trmin, args);
        if (c !== null) effPmin = Math.max(effPmin, c);
      }
      if (trmax !== null) {
        const c = cdfForDist(typeKey, trmax, args);
        if (c !== null) effPmax = Math.min(effPmax, c);
      }
      if (effPmin >= effPmax) effPmin = pmin; // fallback

      const samples = new Float64Array(n);
      for (let i = 0; i < n; i++) {
        const u = Math.random();
        const p = effPmin + (effPmax - effPmin) * u;
        samples[i] = invFn(p, args) + shift;
      }
      return samples;
    }

    /**
     * Build a human-readable label for a PDF spec.
     * @param {Object} pdf
     * @returns {string}
     */
    function pdfLabel(pdf) {
      if (!pdf || !pdf.type) return '';
      const t = pdf.type;
      const parts = [t];
      const keys = Object.keys(pdf).filter(k => !['type','pmin','pmax','trmin','trmax','shift','include_deterministic'].includes(k));
      for (const k of keys) {
        const v = pdf[k];
        if (typeof v === 'number') {
          // Compact number: use toPrecision(4) only when needed
          const s = Number.isInteger(v) ? String(v) : Number(v.toPrecision(4)).toString();
          parts.push(`${k}=${s}`);
        }
        // Skip array / object params (e.g. empirical 'data') to keep the label short
      }
      return parts.join(', ');
    }

    /**
     * Extract histogram entries from a dataset node that has a 'pdf' attribute.
     * Returns an array of {label, samples, spec, deterministicValue} objects,
     * or null if no histogram data can be produced.
     *
     * @param {Object} node  - HDF5 dataset node
     * @param {Object} attrs - Already-extracted attribute dict (must contain attrs.pdf)
     * @param {string} label - Human-readable label prefix for this dataset
     * @returns {Array|null}
     */
    function collectPdfEntries(node, attrs, label) {
      if (!attrs.pdf) return null;
      try {
        let pdfRaw = attrs.pdf;
        if (typeof pdfRaw === 'string') pdfRaw = JSON.parse(pdfRaw);

        const isLookupTable = Array.isArray(pdfRaw);
        const indexAttr = attrs.index;

        if (isLookupTable && indexAttr) {
          const indexLabels = Array.isArray(indexAttr) ? indexAttr : Array.from(indexAttr);
          const entries = [];
          for (let i = 0; i < pdfRaw.length; i++) {
            const spec = pdfRaw[i];
            if (!spec) {
              try {
                let rawData = typeof node.value !== 'undefined' ? node.value : (typeof node.toArray === 'function' ? node.toArray() : undefined);
                if (rawData !== undefined) {
                  const arr = Array.isArray(rawData) ? rawData : Array.from(rawData);
                  entries.push({ label: label + ' ‚Äì ' + String(indexLabels[i] ?? i), samples: [arr[i]], spec: null, deterministicValue: null });
                }
              } catch (_) {}
              continue;
            }
            if (spec.type && spec.type.toLowerCase() === 'raw') {
              try {
                let rawData = typeof node.value !== 'undefined' ? node.value : (typeof node.toArray === 'function' ? node.toArray() : undefined);
                if (rawData !== undefined) {
                  const flat = Array.isArray(rawData) ? rawData : Array.from(rawData);
                  const nCols = pdfRaw.length, nRows = Math.floor(flat.length / nCols);
                  const shift = spec.include_deterministic ? 1 : 0;
                  const detVal = spec.include_deterministic && nRows > 0 ? flat[0 * nCols + i] : null;
                  const col = [];
                  for (let r = shift; r < nRows; r++) col.push(flat[r * nCols + i]);
                  entries.push({ label: label + ' ‚Äì ' + String(indexLabels[i] ?? i), samples: col, spec, deterministicValue: detVal });
                }
              } catch (_) {}
            } else {
              let detVal = null;
              try {
                let rawData = typeof node.value !== 'undefined' ? node.value : (typeof node.toArray === 'function' ? node.toArray() : undefined);
                if (rawData !== undefined) {
                  const flat = Array.isArray(rawData) ? rawData : Array.from(rawData);
                  if (flat.length >= pdfRaw.length) detVal = Number(flat[i]);
                }
              } catch (_) {}
              const samples = generatePdfSamples(spec, 1000);
              if (samples) {
                entries.push({ label: label + ' ‚Äì ' + String(indexLabels[i] ?? i), samples: Array.from(samples), spec, deterministicValue: isFinite(detVal) ? detVal : null });
              }
            }
          }
          return entries.length > 0 ? entries : null;
        } else if (!isLookupTable && pdfRaw.type) {
          if (pdfRaw.type.toLowerCase() === 'raw') {
            try {
              let rawData = typeof node.value !== 'undefined' ? node.value : (typeof node.toArray === 'function' ? node.toArray() : undefined);
              if (rawData !== undefined) {
                const flat = Array.isArray(rawData) ? rawData : Array.from(rawData);
                const shift = pdfRaw.include_deterministic ? 1 : 0;
                const detVal = pdfRaw.include_deterministic && flat.length > 0 ? flat[0] : null;
                return [{ label, samples: flat.slice(shift), spec: pdfRaw, deterministicValue: detVal }];
              }
            } catch (_) {}
          } else {
            let detVal = null;
            try {
              let rawData = typeof node.value !== 'undefined' ? node.value : (typeof node.toArray === 'function' ? node.toArray() : undefined);
              if (rawData !== undefined) {
                if (typeof rawData === 'number') detVal = rawData;
                else if (rawData && rawData.length !== undefined && rawData.length > 0) detVal = Number(rawData[0]);
              }
            } catch (_) {}
            const samples = generatePdfSamples(pdfRaw, 1000);
            if (samples) {
              return [{ label, samples: Array.from(samples), spec: pdfRaw, deterministicValue: isFinite(detVal) ? detVal : null }];
            }
          }
        }
      } catch (e) {
        console.warn('collectPdfEntries error:', e.message);
      }
      return null;
    }

    /**
     * Compute analytical PDF curve points for a given distribution spec.
     * Accounts for truncation (trmin/trmax/pmin/pmax) and shift.
     * @param {Object} spec - PDF specification object
     * @param {number} [nPoints=200] - Number of points to evaluate
     * @returns {{x:number[], y:number[]}|null} Points for the line overlay
     */
    function computePdfOverlay(spec, nPoints = 200) {
      if (!spec || !spec.type) return null;
      const typeKey = spec.type.toLowerCase();
      if (['raw','emp','empirical'].includes(typeKey)) return null;

      const invFn = DIST_INV[typeKey];
      if (!invFn) return null;

      const args  = { ...spec };
      const shift = spec.shift ?? 0;
      const pmin  = spec.pmin  ?? 0;
      const pmax  = spec.pmax  ?? 1;
      const trmin = spec.trmin ?? null;
      const trmax = spec.trmax ?? null;

      // Effective probability bounds (mirrors generatePdfSamples)
      let effPmin = pmin, effPmax = pmax;
      if (trmin !== null) {
        const c = cdfForDist(typeKey, trmin, args);
        if (c !== null) effPmin = Math.max(effPmin, c);
      }
      if (trmax !== null) {
        const c = cdfForDist(typeKey, trmax, args);
        if (c !== null) effPmax = Math.min(effPmax, c);
      }
      if (effPmin >= effPmax) { effPmin = pmin; effPmax = pmax; }

      // x-range from probability bounds
      const eps = 1e-9;
      const xMin = invFn(Math.max(effPmin, eps), args) + shift;
      const xMax = invFn(Math.min(effPmax, 1 - eps), args) + shift;
      if (!isFinite(xMin) || !isFinite(xMax) || xMin >= xMax) return null;

      const normFactor = effPmax - effPmin;
      if (normFactor <= 0) return null;

      const x = [], y = [];
      for (let i = 0; i <= nPoints; i++) {
        const xi = xMin + (xMax - xMin) * i / nPoints;
        const fVal = pdfEval(typeKey, xi - shift, args);
        if (fVal !== null && isFinite(fVal)) {
          x.push(xi);
          y.push(fVal / normFactor);
        }
      }
      return x.length > 0 ? { x, y } : null;
    }

    /**
     * Escape value for CSV export (handle commas, quotes, newlines)
     */
    function escapeCSV(value) {
      if (value === null || value === undefined) {
        return '';
      }
      
      const str = String(value);
      
      if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
        return '"' + str.replace(/"/g, '""') + '"';
      }
      
      return str;
    }
    
    /**
     * Format HDF5 data type into human-readable string
     */
    function formatDataType(dtype) {
      if (!dtype) return 'unknown';
      
      let name = '';
      
      if (typeof dtype === 'object' && dtype.name) {
        name = dtype.name;
      } else if (typeof dtype === 'string') {
        name = dtype;
      } else {
        return String(dtype);
      }
      
      const typeMap = {
        'i': 'Integer', 'u': 'Unsigned Integer', 'f': 'Float', 'c': 'Complex',
        'q': 'Integer', 'Q': 'Unsigned Integer',
        'S': 'String (fixed)', 'U': 'Unicode String', 'V': 'Void/Compound',
        'O': 'Object Reference', 'b': 'Boolean', 't': 'Time', 'm': 'Timedelta',
        'M': 'Datetime', 'a': 'Bytes', 'A': 'Any', 'd': 'Float'
      };
      
      name = name.replace(/^[<>|=]/, '');
      
      const match = name.match(/^([a-zA-Z])(\d+)$/);
      if (match) {
        const [, type, bytes] = match;
        const baseType = typeMap[type] || type;
        const bitSize = parseInt(bytes) * 8;
        return `${baseType} (${bitSize}-bit)`;
      }
      
      const singleTypeMatch = name.match(/^([a-zA-Z])$/);
      if (singleTypeMatch) {
        const type = singleTypeMatch[1];
        return typeMap[type] || name;
      }
      
      return name;
    }
    
    /**
     * Check if a value represents a truthy attribute (handles various formats)
     * @param {*} value - The value to check
     * @returns {boolean} True if the value is truthy
     */
    function isTruthyAttribute(value) {
      return value === true || value === 1 || value === 'TRUE' || value === 'True' || value === 'true';
    }
    
    /**
     * Convert data to a proper array
     * @param {*} data - The data to convert (array, array-like, or scalar)
     * @returns {Array} The data as an array
     */
    function normalizeDataArray(data) {
      if (Array.isArray(data)) {
        return data;
      } else if (data && typeof data === 'object' && data.length !== undefined) {
        return Array.from(data);
      } else {
        return [data];
      }
    }
    
    /**
     * Check if a dataset has the 'probabilistic' attribute set to true
     * @param {Object} dataset - HDF5 dataset with attrs
     * @returns {boolean} True if probabilistic
     */
    function checkIsProbabilistic(dataset) {
      if (dataset && dataset.attrs && typeof dataset.attrs === 'object') {
        for (const attrName in dataset.attrs) {
          if (attrName === 'probabilistic') {
            const attrObj = dataset.attrs[attrName];
            if (attrObj && typeof attrObj.value !== 'undefined') {
              return isTruthyAttribute(attrObj.value);
            }
          }
        }
      }
      return false;
    }
    
    /**
     * Compute mean values from probabilistic data array
     * @param {Array} yArray - Raw data array (may contain realizations)
     * @param {Array} timeData - Time data for reference length
     * @returns {Array} Array of mean values per timestep
     */
    function computeProbabilisticMean(yArray, timeData) {
      if (Array.isArray(yArray[0])) {
        // Array of arrays: each timeSlice has multiple realizations
        return yArray.map(timeSlice => {
          if (Array.isArray(timeSlice)) {
            const sum = timeSlice.reduce((a, b) => a + b, 0);
            return sum / timeSlice.length;
          }
          return timeSlice;
        });
      } else if (yArray.length > timeData.length && yArray.length % timeData.length === 0) {
        // Flat array: realizations interleaved or sequential
        const numRealizations = Math.floor(yArray.length / timeData.length);
        const means = [];
        for (let t = 0; t < timeData.length; t++) {
          let sum = 0;
          for (let r = 0; r < numRealizations; r++) {
            sum += yArray[t * numRealizations + r];
          }
          means.push(sum / numRealizations);
        }
        return means;
      }
      return yArray;
    }
    
    /**
     * Compute a compact diff label showing only the parts of secondName
     * that differ from firstName, with '...' replacing matching segments
     * longer than 3 characters. Short matching runs (1-3 chars) are kept.
     * Example: firstName='SFR_FSAR_CCP1.h5', secondName='SFR_PSAR_CCP33.h5'
     *          returns '...P...33...'
     *
     * @param {string} firstName - The primary/reference filename
     * @param {string} secondName - The secondary filename to diff
     * @returns {string} Compact diff string
     */
    function filenameDiff(firstName, secondName) {
      // Strip .h5/.hdf5/.he5 extension for comparison
      const stripExt = s => s.replace(/\.(h5|hdf5|he5)$/i, '');
      const a = stripExt(firstName);
      const b = stripExt(secondName);
      
      // Build runs of same/diff segments
      const runs = []; // { same: bool, text: string (from b) }
      let i = 0;
      const len = Math.max(a.length, b.length);
      while (i < len) {
        const ca = i < a.length ? a[i] : '';
        const cb = i < b.length ? b[i] : '';
        const same = (ca === cb);
        let text = cb;
        let j = i + 1;
        while (j < len) {
          const na = j < a.length ? a[j] : '';
          const nb = j < b.length ? b[j] : '';
          if ((na === nb) !== same) break;
          text += nb;
          j++;
        }
        runs.push({ same, text });
        i = j;
      }
      
      // Build result: replace matching runs > 3 chars with '...'
      let result = '';
      for (const run of runs) {
        if (run.same) {
          result += run.text.length > 3 ? '...' : run.text;
        } else {
          result += run.text;
        }
      }
      
      // If result equals the stripped second name, files are identical
      if (result === b) return secondName;
      
      return result;
    }

    /**
     * Get current axis scale values from UI
     * @returns {{xScale: string, yScale: string}}
     */
    function getChartScales() {
      return {
        xScale: getElement('xAxisScale')?.value || 'linear',
        yScale: getElement('yAxisScale')?.value || 'linear'
      };
    }

    /**
     * Capture the current Plotly axis state (ranges and autorange flags)
     * so it can be restored after a chart rebuild.
     * @returns {Object|null} Saved axis state, or null if no chart exists
     */
    function captureAxisState() {
      const plotDiv = getElement('plotlyChart');
      if (!plotDiv || !plotDiv.layout) return null;
      const xaxis = plotDiv.layout.xaxis || {};
      const yaxis = plotDiv.layout.yaxis || {};
      return {
        xRange: xaxis.range ? [...xaxis.range] : null,
        yRange: yaxis.range ? [...yaxis.range] : null,
        xAutorange: xaxis.autorange,
        yAutorange: yaxis.autorange
      };
    }

    /**
     * Apply a previously captured axis state to a Plotly layout object.
     * Only overrides ranges when the user had manually zoomed/panned (autorange=false).
     * @param {Object} layout - Plotly layout to modify in-place
     * @param {Object} savedState - State from captureAxisState()
     */
    function applyAxisState(layout, savedState) {
      if (!savedState) return;
      if (savedState.xRange && savedState.xAutorange === false) {
        layout.xaxis.range = savedState.xRange;
        layout.xaxis.autorange = false;
      }
      if (savedState.yRange && savedState.yAutorange === false) {
        layout.yaxis.range = savedState.yRange;
        layout.yaxis.autorange = false;
      }
    }
    
    /**
     * Create base layout configuration for Plotly charts
     * @param {Object} options - Layout options
     * @param {string} options.title - Chart title
     * @param {string} options.xAxisTitle - X axis title
     * @param {string} options.yAxisTitle - Y axis title
     * @param {string} [options.xScale='linear'] - X axis scale type
     * @param {string} [options.yScale='linear'] - Y axis scale type
     * @returns {Object} Plotly layout configuration
     */
    function createBaseLayout({ title, xAxisTitle, yAxisTitle, xScale = 'linear', yScale = 'linear' }) {
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#e8ddd0' : '#2d2416';
      const gridColor = isDark ? '#4a3f35' : '#e5ddd5';
      const bgColor = isDark ? '#2a221b' : '#ffffff';

      return {
        title: {
          text: '',
          font: { size: 14, color: textColor },
          xanchor: 'left',
          x: 0
        },
        paper_bgcolor: bgColor,
        plot_bgcolor: bgColor,
        font: { color: textColor },
        xaxis: { 
          title: xAxisTitle,
          type: xScale,
          gridcolor: gridColor,
          zerolinecolor: gridColor,
          color: textColor
        },
        yaxis: { 
          title: yAxisTitle,
          type: yScale,
          gridcolor: gridColor,
          zerolinecolor: gridColor,
          color: textColor,
          ...CHART_YAXIS_EXPONENT
        },
        hovermode: 'closest',
        showlegend: true,
        legend: { ...CHART_LEGEND_CONFIG, font: { color: textColor } },
        margin: CHART_MARGIN_WITH_LEGEND
      };
    }
    
    // Update Plotly chart colours when theme changes
    new MutationObserver(() => {
      const el = document.getElementById('plotlyChart');
      if (!el) return;
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#e8ddd0' : '#2d2416';
      const gridColor = isDark ? '#4a3f35' : '#e5ddd5';
      const bgColor  = isDark ? '#2a221b' : '#ffffff';

      if (currentPdfHistogram && currentPdfHistogramData) {
        // Re-render the whole histogram with correct theme colours
        createPdfHistogram(currentPdfHistogramData);
        return;
      }

      if (!currentChartData) return;
      Plotly.relayout(el, {
        paper_bgcolor: bgColor,
        plot_bgcolor: bgColor,
        'font.color': textColor,
        'xaxis.gridcolor': gridColor,
        'xaxis.zerolinecolor': gridColor,
        'xaxis.color': textColor,
        'yaxis.gridcolor': gridColor,
        'yaxis.zerolinecolor': gridColor,
        'yaxis.color': textColor,
        'legend.font.color': textColor
      });
    }).observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

    /**
     * Hide the chart container and clear chart data
     */
    function hideChart() {
      const container = getElement('plotlyChartContainer');
      if (container) {
        container.classList.remove('visible');
        // Restore chart controls visibility (may have been hidden for PDF histograms)
        const controls = container.querySelector('.chart-controls');
        if (controls) controls.style.display = '';
      }
      currentChartData = null;
      currentPdfHistogram = false;
      currentPdfHistogramData = null;
      const histControls = document.getElementById('histControls');
      if (histControls) histControls.style.display = 'none';
    }
    
    /**
     * Reset info panel to default message
     */
    function resetInfoPanel() {
      const info = getElement('info');
      if (info) {
        info.innerHTML = INFO_PANEL_DEFAULT_MESSAGE;
      }
    }
    
    /**
     * Assign legendrank to traces so that in the legend they are grouped by
     * line width (thick first, thin second) and within each group sorted by
     * the maximum Y value in descending order.
     * @param {Array} traces - Array of Plotly trace objects
     */
    function assignLegendRanks(traces) {
      // Classify traces into groups by line width (thick = first file, thin = secondary files)
      const thick = [];
      const thin = [];
      for (let i = 0; i < traces.length; i++) {
        const w = traces[i].line?.width || 2;
        const maxY = Math.max(...(traces[i].y || []).filter(v => v != null && isFinite(v)));
        const entry = { index: i, maxY: isFinite(maxY) ? maxY : 0 };
        if (w >= 2) {
          thick.push(entry);
        } else {
          thin.push(entry);
        }
      }
      // Sort each group by maxY descending
      thick.sort((a, b) => b.maxY - a.maxY);
      thin.sort((a, b) => b.maxY - a.maxY);
      // Assign legendrank: thick group first, then thin group
      let rank = 0;
      for (const entry of thick) {
        traces[entry.index].legendrank = rank++;
      }
      for (const entry of thin) {
        traces[entry.index].legendrank = rank++;
      }
    }

    /**
     * Render a Plotly chart with standard configuration
     * @param {Array} traces - Plotly trace data
     * @param {Object} layout - Plotly layout configuration
     * @param {string} path - Dataset path (for storing in currentChartData)
     */
    function renderChart(traces, layout, path) {
      const container = getElement('plotlyChartContainer');
      const config = getPlotlyConfig('chart');
      
      // Restore chart controls (may have been hidden for PDF histograms)
      if (container) {
        const controls = container.querySelector('.chart-controls');
        if (controls) controls.style.display = '';
      }
      const histControls = document.getElementById('histControls');
      if (histControls) histControls.style.display = 'none';

      if (dynamicLegendEnabled) {
        assignLegendRanks(traces);
      }

      currentChartData = { traces, layout, path };
      if (container) {
        container.classList.add('visible');
      }
      
      Plotly.newPlot('plotlyChart', traces, layout, config).then(() => {
        setupDynamicLegend(getElement('plotlyChart'));
      });
    }

    /**
     * Render a PDF histogram in the main chart area (#plotlyChart).
     * Handles both single-distribution and lookup-table (multi-index) cases.
     * @param {Object} data - pdfHistogramData object
     */
    function createPdfHistogram(data) {
      const container = getElement('plotlyChartContainer');
      if (!container) return;

      // Store data globally for re-rendering on theme / log toggle
      currentPdfHistogramData = data;

      // Hide time-series controls, show histogram controls when applicable
      const controls = container.querySelector('.chart-controls');
      if (controls) controls.style.display = 'none';
      const histControls = document.getElementById('histControls');

      // Determine if all sample values are strictly positive (log10 is only meaningful then)
      let allPositive = true;
      if (data.type === 'single') {
        allPositive = data.samples.every(v => v > 0);
      } else if (data.type === 'lookup') {
        allPositive = data.entries.every(e => e.samples.every(v => v > 0));
      }
      if (histControls) histControls.style.display = allPositive ? '' : 'none';

      const useLog = allPositive && document.getElementById('histLogScale') && document.getElementById('histLogScale').checked;

      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#e8ddd0' : '#2d2416';
      const gridColor = isDark ? '#4a3f35' : '#e5ddd5';
      const bgColor  = isDark ? '#2a221b' : '#ffffff';
      const barColor  = isDark ? 'rgba(243,184,123,0.45)' : 'rgba(187,108,93,0.45)';
      const barLine   = isDark ? 'rgba(243,184,123,0.8)'  : 'rgba(187,108,93,0.8)';
      const pdfLineColor = isDark ? 'rgba(255,220,160,1)' : 'rgba(140,60,45,1)';
      const detColor  = isDark ? '#ff6b6b' : '#d63031';

      const palette = [
        { bar: isDark ? 'rgba(243,184,123,0.35)' : 'rgba(187,108,93,0.35)', line: isDark ? 'rgba(243,184,123,0.8)' : 'rgba(187,108,93,0.8)', pdf: isDark ? 'rgba(255,220,160,1)' : 'rgba(140,60,45,1)' },
        { bar: isDark ? 'rgba(123,198,243,0.35)' : 'rgba(65,131,196,0.35)',  line: isDark ? 'rgba(123,198,243,0.8)' : 'rgba(65,131,196,0.8)',  pdf: isDark ? 'rgba(160,220,255,1)' : 'rgba(30,90,160,1)' },
        { bar: isDark ? 'rgba(168,230,160,0.35)' : 'rgba(80,160,72,0.35)',   line: isDark ? 'rgba(168,230,160,0.8)' : 'rgba(80,160,72,0.8)',   pdf: isDark ? 'rgba(190,255,185,1)' : 'rgba(40,120,35,1)' },
        { bar: isDark ? 'rgba(230,168,230,0.35)' : 'rgba(170,80,170,0.35)',  line: isDark ? 'rgba(230,168,230,0.8)' : 'rgba(170,80,170,0.8)',  pdf: isDark ? 'rgba(250,200,250,1)' : 'rgba(130,40,130,1)' },
        { bar: isDark ? 'rgba(243,210,123,0.35)' : 'rgba(200,150,50,0.35)',  line: isDark ? 'rgba(243,210,123,0.8)' : 'rgba(200,150,50,0.8)',  pdf: isDark ? 'rgba(255,230,160,1)' : 'rgba(160,110,20,1)' },
        { bar: isDark ? 'rgba(243,150,150,0.35)' : 'rgba(200,80,80,0.35)',   line: isDark ? 'rgba(243,150,150,0.8)' : 'rgba(200,80,80,0.8)',   pdf: isDark ? 'rgba(255,185,185,1)' : 'rgba(160,40,40,1)' },
      ];

      /** Transform value into display-space (identity or log10) */
      const xform = useLog ? v => Math.log10(v) : v => v;

      let traces = [];
      let shapes = [];

      if (data.type === 'single') {
        const label = data.spec ? pdfLabel(data.spec) : 'raw';

        // Histogram trace (probability density)
        traces.push({
          x: data.samples.map(xform),
          type: 'histogram',
          histnorm: 'probability density',
          marker: { color: barColor, line: { color: barLine, width: 1 } },
          opacity: 0.85,
          name: 'Samples',
        });

        // Analytical PDF overlay line
        const overlay = data.spec ? computePdfOverlay(data.spec) : null;
        if (overlay) {
          if (useLog) {
            // Change of variable: f_log10(log10(x)) = f(x) ¬∑ x ¬∑ ln(10)
            const xLog = [], yLog = [];
            for (let k = 0; k < overlay.x.length; k++) {
              const xv = overlay.x[k];
              if (xv > 0) {
                xLog.push(Math.log10(xv));
                yLog.push(overlay.y[k] * xv * Math.LN10);
              }
            }
            traces.push({ x: xLog, y: yLog, type: 'scatter', mode: 'lines', line: { color: pdfLineColor, width: 2.5 }, name: 'PDF (' + label + ')' });
          } else {
            traces.push({ x: overlay.x, y: overlay.y, type: 'scatter', mode: 'lines', line: { color: pdfLineColor, width: 2.5 }, name: 'PDF (' + label + ')' });
          }
        }

        // Deterministic value vertical line
        if (data.deterministicValue !== null && data.deterministicValue !== undefined && isFinite(data.deterministicValue)) {
          const detX = xform(data.deterministicValue);
          shapes.push({
            type: 'line', x0: detX, x1: detX, y0: 0, y1: 1, yref: 'paper',
            line: { color: detColor, width: 2, dash: 'dashdot' },
          });
          traces.push({
            x: [detX], y: [0], type: 'scatter', mode: 'markers',
            marker: { color: detColor, size: 10, symbol: 'line-ns-open', line: { width: 2, color: detColor } },
            name: 'Deterministic (' + Number(data.deterministicValue.toPrecision(4)) + ')',
            showlegend: true,
          });
        }
      } else if (data.type === 'lookup') {
        data.entries.forEach((entry, i) => {
          const c = palette[i % palette.length];
          const label = entry.spec ? entry.label + ' (' + pdfLabel(entry.spec) + ')' : entry.label;

          traces.push({
            x: entry.samples.map(xform),
            type: 'histogram',
            histnorm: 'probability density',
            marker: { color: c.bar, line: { color: c.line, width: 1 } },
            opacity: 0.7,
            name: label,
          });

          const overlay = entry.spec ? computePdfOverlay(entry.spec) : null;
          if (overlay) {
            if (useLog) {
              const xLog = [], yLog = [];
              for (let k = 0; k < overlay.x.length; k++) {
                const xv = overlay.x[k];
                if (xv > 0) { xLog.push(Math.log10(xv)); yLog.push(overlay.y[k] * xv * Math.LN10); }
              }
              traces.push({ x: xLog, y: yLog, type: 'scatter', mode: 'lines', line: { color: c.pdf, width: 2 }, name: 'PDF ' + entry.label, showlegend: false });
            } else {
              traces.push({ x: overlay.x, y: overlay.y, type: 'scatter', mode: 'lines', line: { color: c.pdf, width: 2 }, name: 'PDF ' + entry.label, showlegend: false });
            }
          }

          if (entry.deterministicValue !== null && entry.deterministicValue !== undefined && isFinite(entry.deterministicValue)) {
            const detX = xform(entry.deterministicValue);
            shapes.push({
              type: 'line', x0: detX, x1: detX, y0: 0, y1: 1, yref: 'paper',
              line: { color: c.line, width: 1.5, dash: 'dashdot' },
            });
          }
        });
      }

      const layout = {
        barmode: data.type === 'lookup' ? 'overlay' : undefined,
        paper_bgcolor: bgColor,
        plot_bgcolor: bgColor,
        font: { color: textColor },
        xaxis: {
          title: useLog ? 'log\u2081\u2080(Value)' : 'Value',
          gridcolor: gridColor,
          zerolinecolor: gridColor,
          color: textColor,
        },
        yaxis: {
          title: 'Probability Density',
          gridcolor: gridColor,
          zerolinecolor: gridColor,
          color: textColor,
          rangemode: 'tozero',
        },
        margin: { t: 20, r: 30, b: 60, l: 60 },
        showlegend: true,
        legend: { font: { color: textColor } },
        shapes: shapes,
      };

      const config = getPlotlyConfig('pdf_histogram');

      currentPdfHistogram = true;
      currentChartData = null;
      container.classList.add('visible');

      Plotly.newPlot('plotlyChart', traces, layout, config);
    }

    /**
     * Toggle log\u2081\u2080 scale on the PDF histogram x-axis.
     * Re-renders the histogram from stored data.
     */
    function toggleHistLog() {
      if (currentPdfHistogramData) {
        createPdfHistogram(currentPdfHistogramData);
      }
    }


    /* ==========================================================================
       3. HDF5 DATA ACCESS
       ========================================================================== */
    
    /**
     * Check if a dataset or group exists at the given path in an HDF5 file.
     * Safely handles exceptions from invalid paths.
     * 
     * @param {Object} file - h5wasm File object
     * @param {string} path - HDF5 path to check (e.g., '/group/dataset')
     * @returns {boolean} True if the path exists and is accessible
     */
    function checkDatasetExistsInFile(file, path) {
      try {
        const dataset = file.get(path);
        return dataset !== null && dataset !== undefined;
      } catch (e) {
        return false;
      }
    }
    
    /**
     * Check if a path exists in a file referenced by filename.
     * Looks up the file in loadedFiles by name before checking.
     * 
     * @param {string} fileName - Key in loadedFiles object
     * @param {string} path - HDF5 path to check
     * @returns {boolean} True if file exists in loadedFiles and path is valid
     */
    function checkIfPathExistsInFile(fileName, path) {
      try {
        const file = loadedFiles[fileName];
        if (!file) return false;
        const node = file.get(path);
        return node !== null && node !== undefined;
      } catch (e) {
        return false;
      }
    }

    /**
     * Retrieve time axis data from the standard '/time' dataset.
     * This is the x-axis data for time-dependent plots.
     * 
     * @param {Object} file - h5wasm File object
     * @returns {number[]|null} Array of time values, or null if not found
     */
    function getTimeData(file) {
      try {
        const timeDataset = file.get('/time');
        if (timeDataset && typeof timeDataset.value !== 'undefined') {
          let timeData = timeDataset.value;
          if (timeData && typeof timeData === 'object' && timeData.length !== undefined) {
            return Array.from(timeData);
          }
          return [timeData];
        }
      } catch (e) {
        console.warn('Could not read /time dataset:', e.message);
      }
      return null;
    }

    /**
     * Get the unit string from the '/time' dataset's 'unit' attribute.
     * Used for labeling the x-axis on time-dependent charts.
     * 
     * @param {Object} file - h5wasm File object
     * @returns {string} Time unit string (e.g., 'years', 's'), or empty string if not found
     */
    function getTimeUnit(file) {
      try {
        const timeDataset = file.get('/time');
        if (timeDataset && timeDataset.attrs && typeof timeDataset.attrs === 'object') {
          for (const attrName in timeDataset.attrs) {
            if (attrName === 'unit') {
              const attrObj = timeDataset.attrs[attrName];
              if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                return attrObj.value;
              }
            }
          }
        }
      } catch (e) {
        console.warn('Could not read time unit:', e);
      }
      return '';
    }

    /**
     * Check if a dataset has the 'time_dependent' attribute set to a truthy value.
     * Datasets marked as time-dependent are eligible for time-series plotting.
     * 
     * @param {Object} dataset - h5wasm Dataset object with attrs property
     * @returns {boolean} True if the dataset has time_dependent=true/1/'TRUE'/'True'
     */
    function isTimeDependent(dataset) {
      try {
        if (dataset.attrs && typeof dataset.attrs === 'object') {
          for (const attrName in dataset.attrs) {
            if (attrName === 'time_dependent') {
              const attrObj = dataset.attrs[attrName];
              if (attrObj && typeof attrObj.value !== 'undefined') {
                const value = attrObj.value;
                return value === true || value === 1 || value === 'TRUE' || value === 'True';
              }
            }
          }
        }
      } catch (e) {
        console.warn('Error checking time_dependent attribute:', e);
      }
      return false;
    }
    
    /**
     * Check if a group contains radionuclide data suitable for special charting.
     * A radionuclides group must have:
     * - IndexLists attribute containing 'Radionuclides'
     * - time_dependent attribute set to true
     * 
     * These groups get special treatment: all child datasets are plotted together
     * with isotope-specific line styles and colors.
     * 
     * @param {Object} file - h5wasm File object
     * @param {string} path - HDF5 path to the group
     * @returns {boolean} True if the group is a radionuclides data container
     */
    function checkGroupForRadionuclides(file, path) {
      try {
        const group = file.get(path);
        if (!group || group.type.toLowerCase() !== 'group') {
          return false;
        }
        
        let hasRadionuclidesIndex = false;
        let isTimeDependentGroup = false;
        
        if (group.attrs && typeof group.attrs === 'object') {
          for (const attrName in group.attrs) {
            if (attrName === 'IndexLists') {
              const attrObj = group.attrs[attrName];
              if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                const value = attrObj.value;
                if (Array.isArray(value) && value.includes('Radionuclides')) {
                  hasRadionuclidesIndex = true;
                } else if (typeof value === 'string' && value === 'Radionuclides') {
                  hasRadionuclidesIndex = true;
                }
              }
            }
            
            if (attrName === 'time_dependent') {
              const attrObj = group.attrs[attrName];
              if (attrObj && typeof attrObj.value !== 'undefined') {
                const value = attrObj.value;
                isTimeDependentGroup = value === true || value === 1 || value === 'TRUE' || value === 'True';
              }
            }
          }
        }
        
        return hasRadionuclidesIndex && isTimeDependentGroup;
      } catch (e) {
        console.warn('Error checking group for radionuclides:', e);
        return false;
      }
    }


    /* ==========================================================================
       4. FILE MANAGEMENT
       ========================================================================== */
    
    /**
     * Get list of filenames for currently enabled (visible) files.
     * Maintains the order from fileOrder array.
     * 
     * @returns {string[]} Array of enabled filenames in display order
     */
    function getEnabledFiles() {
      return fileOrder.filter(key => fileStates[key]);
    }
    
    /**
     * Get the filename of the first enabled file.
     * This file's structure is used to render the tree view.
     * 
     * @returns {string|null} Filename of first enabled file, or null if none enabled
     */
    function getTreeFile() {
      const enabledFiles = getEnabledFiles();
      return enabledFiles.length > 0 ? enabledFiles[0] : null;
    }

    /**
     * Check if intersect mode is active.
     * @returns {boolean}
     */
    function isIntersectMode() {
      const cb = document.getElementById('intersectCheckbox');
      return cb && cb.checked && getEnabledFiles().length > 1;
    }

    /**
     * Get the list of files to use for info/charts.
     * In non-intersect mode with a specific file selected, returns just that file.
     * In intersect mode, returns all enabled files.
     * @returns {string[]}
     */
    function getEffectiveFiles() {
      if (isIntersectMode()) {
        return getEnabledFiles();
      }
      if (selectedFileKey && loadedFiles[selectedFileKey]) {
        return [selectedFileKey];
      }
      return getEnabledFiles();
    }

    /**
     * Toggle a file's enabled/disabled state and update the UI.
     * Enabled files contribute data to charts; disabled files are hidden.
     * 
     * @param {string} fileName - The filename to toggle
     */
    function toggleFileState(fileName) {
      fileStates[fileName] = !fileStates[fileName];
      updateTabs();
    }

    /**
     * Remove a file completely from the viewer.
     * Cleans up all references and updates the UI. If this was the last
     * file, resets the viewer to its initial empty state.
     * 
     * @param {string} fileName - The filename to remove
     * @returns {Promise<void>}
     */
    async function removeFile(fileName) {
      delete loadedFiles[fileName];
      delete fileStates[fileName];
      fileOrder = fileOrder.filter(k => k !== fileName);
      
      const enabledFiles = getEnabledFiles();
      
      updateTabs();
      
      if (enabledFiles.length === 0) {
        // No enabled files - clear UI
        currentTreeFile = null;
        const tree = document.getElementById('tree');
        tree.innerHTML = '<div class="loading">Drop HDF5 files or click "+ Add Files" to start...</div>';
        tree.classList.add('loading');
        resetInfoPanel();
        hideChart();
        selectedDatasetPath = null;
        selectedIsRadionuclidesGroup = false;
        
        document.querySelector('.search-container').classList.remove('visible');
        
        const hint = document.getElementById('multiSelectHint');
        if (hint) {
          hint.style.display = 'none';
        }
      }
    }
    
    /**
     * Refresh the info panel and chart display after file selection changes.
     * Verifies the selected path still exists in the current tree file.
     * If the path no longer exists, clears the selection.
     * 
     * @returns {void}
     */
    function refreshInfoAndChart() {
      if (!selectedDatasetPath) {
        return;
      }

      // Use selectedFileKey if available, otherwise first enabled file
      const checkFile = selectedFileKey || getTreeFile();
      
      if (!checkFile || !checkIfPathExistsInFile(checkFile, selectedDatasetPath)) {
        // Clear selection if path doesn't exist
        resetInfoPanel();
        hideChart();
        selectedDatasetPath = null;
        selectedIsRadionuclidesGroup = false;
        selectedFileKey = null;
        
        document.querySelectorAll('.tree-item.dataset').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.tree-item.group').forEach(el => el.classList.remove('expanded'));
        return;
      }

      // Path exists, refresh display
      if (selectedIsRadionuclidesGroup) {
        showNodeAttributes(selectedDatasetPath, true);
        createRadionuclidesChart(selectedDatasetPath);
      } else {
        showNodeAttributes(selectedDatasetPath, false);
        
        try {
          const file = loadedFiles[checkFile];
          const dataset = file.get(selectedDatasetPath);
          if (dataset && dataset.type.toLowerCase() === 'dataset' && isTimeDependent(dataset)) {
            createPlotlyChart(selectedDatasetPath);
          }
        } catch (e) {
          console.warn('Error checking if dataset is time-dependent:', e);
        }
      }
    }


    /* ==========================================================================
       5. TAB MANAGEMENT
       ========================================================================== */
    
    /**
     * Update the file tabs display and reinitialize drag-drop sorting.
     * Renders a tab for each loaded file, handles click-to-toggle and
     * drag-to-reorder functionality via SortableJS.
     * 
     * Tab states:
     * - enabled: File data included in charts (blue indicator)
     * - disabled: File loaded but hidden from charts (gray)
     * 
     * @returns {void}
     */
    function updateTabs() {
      const tabsContainer = document.getElementById('fileTabs');
      const previousTreeFile = currentTreeFile;
      
      // Render tabs
      tabsContainer.innerHTML = fileOrder.map(key => {
        const isEnabled = fileStates[key];
        return `
          <div class="file-tab ${isEnabled ? 'enabled' : 'disabled'}" data-file="${escapeHtml(key)}">
            <div class="file-tab-name" title="${escapeHtml(key)}">${escapeHtml(key)}</div>
            <div class="file-tab-close" onclick="event.stopPropagation(); removeFile('${key.replace(/'/g, "\\'")}')">√ó</div>
          </div>
        `;
      }).join('');
      
      // Add click handlers for toggle
      document.querySelectorAll('.file-tab').forEach(tab => {
        const fileName = tab.getAttribute('data-file');
        tab.addEventListener('click', (e) => {
          if (!e.target.classList.contains('file-tab-close')) {
            toggleFileState(fileName);
          }
        });
      });
      
      // Initialize SortableJS for drag reordering
      if (window.Sortable && tabsContainer.children.length > 0) {
        Sortable.create(tabsContainer, {
          animation: 150,
          ghostClass: 'sortable-ghost',
          dragClass: 'sortable-drag',
          onEnd: function(evt) {
            const previousFirst = currentTreeFile;
            
            const newOrder = Array.from(tabsContainer.children).map(
              tab => tab.getAttribute('data-file')
            );
            fileOrder = newOrder;
            
            const newTreeFile = getTreeFile();
            currentTreeFile = newTreeFile;
            
            const treeFileChanged = previousFirst !== newTreeFile;
            
            console.log('Drag ended - Previous:', previousFirst, 'New:', newTreeFile, 'Changed:', treeFileChanged);
            
            if (treeFileChanged) {
              refreshTreeStructure();
            }
            
            refreshInfoAndChart();
          }
        });
      }
      
      // Check if tree file changed
      const newTreeFile = getTreeFile();
      const treeFileChanged = previousTreeFile !== newTreeFile;
      currentTreeFile = newTreeFile;
      
      // Show/hide Intersect checkbox based on number of enabled files
      const intersectLabel = document.getElementById('intersectLabel');
      if (intersectLabel) {
        const enabledCount = getEnabledFiles().length;
        intersectLabel.style.display = enabledCount > 1 ? 'flex' : 'none';
        // Uncheck if only one file left
        if (enabledCount <= 1) {
          const cb = document.getElementById('intersectCheckbox');
          if (cb) cb.checked = false;
        }
      }
      
      console.log('updateTabs - Previous:', previousTreeFile, 'New:', newTreeFile, 'Changed:', treeFileChanged);
      
      // Always refresh tree: in multi-file mode the set of visible roots changes,
      // and in intersect mode the intersection set changes when files are toggled.
      refreshTreeStructure();
      
      refreshInfoAndChart();
    }


    /* ==========================================================================
       6. TREE VIEW
       ========================================================================== */
    
    /**
     * Toggle the expand/collapse state of a group node in the tree.
     * Called when clicking the triangle toggle icon.
     * Does NOT select the group or trigger chart updates.
     * 
     * @param {Event} event - Click event on the toggle icon
     * @param {string} path - HDF5 path of the group
     * @returns {void}
     */
    function toggleGroupExpansion(event, path) {
      event.stopPropagation();
      
      const toggle = event.currentTarget;
      const groupItem = toggle.closest('.tree-item.group');
      const childrenDiv = groupItem.nextElementSibling;
      
      if (childrenDiv && childrenDiv.classList.contains('tree-group-children')) {
        const isExpanded = childrenDiv.classList.contains('expanded');
        
        if (isExpanded) {
          childrenDiv.classList.remove('expanded');
          toggle.classList.add('collapsed');
          groupItem.classList.remove('expanded');
        } else {
          childrenDiv.classList.add('expanded');
          toggle.classList.remove('collapsed');
        }
      }
    }
    
    /**
     * Handle dataset selection in single or multi-select mode.
     * 
     * Single-click: Selects one dataset, shows its info and chart.
     * Ctrl/Cmd+click: Adds/removes dataset from multi-selection,
     *                 shows combined info and comparison chart.
     * 
     * @param {string} path - HDF5 path to the dataset
     * @param {Event} [evt] - Click event (used to detect Ctrl/Cmd key)
     * @returns {void}
     */
    function selectDataset(path, evt) {
      evt?.stopPropagation();
      
      const isCtrlKey = evt?.ctrlKey || evt?.metaKey;
      const datasetElement = evt?.target?.closest('.tree-item.dataset');
      
      // Determine which file this tree node belongs to
      const nodeFileKey = datasetElement?.getAttribute('data-file') || null;
      
      if (isCtrlKey) {
        // Multi-select mode ‚Äî allow cross-file selection
        multiSelectMode = true;
        selectedFileKey = null; // clear single-file scope
        
        const index = selectedDatasets.findIndex(d => d.path === path && d.fileKey === nodeFileKey);
        if (index > -1) {
          selectedDatasets.splice(index, 1);
          datasetElement?.classList.remove('selected');
        } else {
          selectedDatasets.push({ path, fileKey: nodeFileKey });
          datasetElement?.classList.add('selected');
        }
        
        selectedIsRadionuclidesGroup = false;
        document.querySelectorAll('.tree-item.group').forEach(el => {
          el.classList.remove('expanded');
        });
        
        if (selectedDatasets.length > 0) {
          showMultipleDatasetAttributes(selectedDatasets);
        } else {
          resetInfoPanel();
          document.getElementById('plotlyChartContainer').classList.remove('visible');
          currentChartData = null;
        }
      } else {
        // Single select mode
        multiSelectMode = false;
        selectedFileKey = nodeFileKey;
        selectedDatasets = [{ path, fileKey: nodeFileKey }];
        selectedDatasetPath = path;
        selectedIsRadionuclidesGroup = false;
        
        document.querySelectorAll('.tree-item.dataset').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.tree-item.group').forEach(el => el.classList.remove('expanded'));
        
        datasetElement?.classList.add('selected');
        
        showNodeAttributes(path, false);
      }
    }
    
    /**
     * Handle group selection to show group info and radionuclides chart.
     * Clicking on a group (not its toggle icon) selects it for display.
     * If the group contains radionuclides data, triggers special charting.
     * 
     * @param {Event} event - Click event on the group element
     * @returns {void}
     */
    function toggleGroup(event) {
      event.stopPropagation();
      const groupItem = event.currentTarget;
      
      if (event.target.classList.contains('tree-toggle')) {
        return;
      }
      
      const path = groupItem.getAttribute('data-path');
      if (path) {
        multiSelectMode = false;
        selectedDatasets = [];
        
        // Determine which file this tree node belongs to
        const nodeFileKey = groupItem.getAttribute('data-file') || null;
        selectedFileKey = nodeFileKey;
        
        selectedDatasetPath = path;
        selectedIsRadionuclidesGroup = true;
        
        document.querySelectorAll('.tree-item.dataset.selected').forEach(el => {
          el.classList.remove('selected');
        });
        
        document.querySelectorAll('.tree-item.group').forEach(el => {
          el.classList.remove('expanded');
        });
        
        groupItem.classList.add('expanded');
        
        showNodeAttributes(path, true);
      }
    }

    /**
     * Toggle the Intersect checkbox and rebuild the tree.
     */
    function toggleIntersect() {
      // Clear per-file selection when switching modes
      selectedFileKey = null;
      selectedDatasetPath = null;
      selectedIsRadionuclidesGroup = false;
      selectedDatasets = [];
      multiSelectMode = false;
      resetInfoPanel();
      hideChart();
      refreshTreeStructure();
    }

    /**
     * Recursively collect all paths (groups and datasets) from an HDF5 file.
     * @param {Object} group - h5wasm Group object
     * @param {string} prefix - Current path prefix
     * @returns {Set<string>} Set of all paths in the group
     */
    function collectAllPaths(group, prefix = '') {
      const paths = new Set();
      try {
        let keys = [];
        if (typeof group.keys === 'function') {
          keys = Array.from(group.keys());
        }
        for (const key of keys) {
          const path = prefix ? `${prefix}/${key}` : `/${key}`;
          paths.add(path);
          try {
            const obj = group.get(key);
            if (obj && String(obj.type).toLowerCase() === 'group') {
              for (const subPath of collectAllPaths(obj, path)) {
                paths.add(subPath);
              }
            }
          } catch (e) { /* skip */ }
        }
      } catch (e) { /* skip */ }
      return paths;
    }

    /**
     * Get the set of paths that exist in ALL enabled files.
     * @returns {Set<string>|null} Intersected paths, or null if intersect is off
     */
    function getIntersectedPaths() {
      const checkbox = document.getElementById('intersectCheckbox');
      if (!checkbox || !checkbox.checked) return null;
      
      const enabledFiles = getEnabledFiles();
      if (enabledFiles.length < 2) return null;
      
      let intersection = null;
      for (const fileKey of enabledFiles) {
        const file = loadedFiles[fileKey];
        if (!file) continue;
        const filePaths = collectAllPaths(file);
        if (intersection === null) {
          intersection = filePaths;
        } else {
          // Keep only paths present in both sets
          for (const p of intersection) {
            if (!filePaths.has(p)) intersection.delete(p);
          }
        }
      }
      return intersection || new Set();
    }

    /**
     * Refresh the tree view from the first enabled file's structure.
     * Rebuilds the entire tree HTML and applies any active search filter.
     * Shows loading state during refresh and handles errors gracefully.
     * 
     * @returns {Promise<void>}
     */
    async function refreshTreeStructure() {
      const tree = document.getElementById('tree');
      const searchContainer = document.querySelector('.search-container');
      const enabledFiles = getEnabledFiles();
      
      if (enabledFiles.length === 0) {
        tree.innerHTML = '<div class="loading">Drop HDF5 files or click "+ Add Files" to start...</div>';
        tree.classList.add('loading');
        resetInfoPanel();
        hideChart();
        searchContainer.classList.remove('visible');
        return;
      }
      
      try {
        const intersectedPaths = getIntersectedPaths();
        let treeHtml = '';
        
        if (intersectedPaths) {
          // Intersect mode: single tree from first file, filtered to common paths
          const file = loadedFiles[enabledFiles[0]];
          treeHtml = await buildTree(file, '', false, 'Intersection', intersectedPaths, null);
        } else {
          // Non-intersect: one tree per enabled file
          for (const fileKey of enabledFiles) {
            const file = loadedFiles[fileKey];
            treeHtml += await buildTree(file, '', false, fileKey, null, fileKey);
          }
        }
        
        tree.innerHTML = treeHtml || '<div style="color:#999;">No items found</div>';
        tree.classList.remove('loading');
        searchContainer.classList.add('visible');
      } catch (err) {
        tree.innerHTML = `<div class="error">Error loading tree: ${escapeHtml(err.message)}</div>`;
        console.error(err);
        searchContainer.classList.remove('visible');
      }
    }
    
    // Decorator: Show multi-select hint after tree refresh
    const originalRefreshTreeStructure2 = refreshTreeStructure;
    refreshTreeStructure = async function() {
      await originalRefreshTreeStructure2();
      const hint = document.getElementById('multiSelectHint');
      const tree = document.getElementById('tree');
      
      if (hint) {
        const hasEnabledFiles = getEnabledFiles().length > 0;
        const isNotLoading = !tree.classList.contains('loading');
        const hasTreeContent = tree.querySelector('.tree-item') !== null;
        
        if (hasEnabledFiles && isNotLoading && hasTreeContent) {
          hint.style.display = 'flex';
        } else {
          hint.style.display = 'none';
        }
      }
    };
    
    /**
     * Recursively build HTML tree structure from an HDF5 group.
     * Creates collapsible group nodes and selectable dataset nodes.
     * Preserves selection state when rebuilding.
     * 
     * @param {Object} group - h5wasm Group object to traverse
     * @param {string} [prefix=''] - Path prefix for nested items
     * @param {boolean} [isNested=false] - Whether this is a nested call (not root)
     * @returns {Promise<string>} HTML string for the tree structure
     */
    async function buildTree(group, prefix = '', isNested = false, fileName = '', intersectedPaths = null, fileKey = null) {
      const childrenHtml = [];
      const fileAttr = fileKey ? ` data-file="${escapeHtml(fileKey)}"` : '';
      
      // Add root group item only at top level
      if (prefix === '') {
        const isRootSelected = selectedDatasetPath === '/' && selectedIsRadionuclidesGroup;
        const rootLabel = fileName ? fileName : 'root';
        const rootHtml = `<div class="tree-item group root-node ${isRootSelected ? 'expanded' : ''}" onclick="toggleGroup(event)" data-path="/"${fileAttr}>
          <div class="tree-toggle ${isRootSelected ? '' : 'collapsed'}" onclick="event.stopPropagation(); toggleGroupExpansion(event, '/')">‚ñ∂</div>
          <div class="tree-icon folder"></div>
          <div class="tree-label">/ (${escapeHtml(rootLabel)})</div>
        </div>`;
        childrenHtml.push(rootHtml);
        
        const rootChildrenStart = `<div class="tree-group-children ${isRootSelected ? 'expanded' : ''}" style="margin-left: 20px;">`;
        childrenHtml.push(rootChildrenStart);
      }
      
      try {
        let keys = [];
        try {
          if (typeof group.keys === 'function') {
            keys = Array.from(group.keys());
          }
          keys.sort();
        } catch (e) {
          console.error('Error getting keys:', e.message);
          if (prefix === '') {
            childrenHtml.push('</div>');
          }
          return childrenHtml.join('');
        }
        
        if (keys.length === 0) {
          if (prefix === '') {
            childrenHtml.push('<div style="color:#999;padding:8px;font-size:12px;">(empty)</div>');
            childrenHtml.push('</div>');
          }
          return childrenHtml.join('');
        }
        
        for (const key of keys) {
          try {
            const obj = group.get(key);
            if (!obj) continue;
            
            const path = prefix ? `${prefix}/${key}` : `/${key}`;
            const objType = String(obj.type).toLowerCase();
            
            // Skip this node if intersect is active and path is not in the intersection
            if (intersectedPaths && !intersectedPaths.has(path)) continue;
            
            // Detect link info for badge
            const linkInfo = getLinkInfo(group, path, obj);
            const linkBadge = buildLinkBadge(linkInfo);
            
            // Handle broken soft links ‚Äî cannot be traversed
            if (objType === 'brokensoftlink') {
              const isSelected = selectedDatasetPath === path && !selectedIsRadionuclidesGroup;
              const brokenHtml = `<div class="tree-item broken-link ${isSelected ? 'selected' : ''}" onclick="selectDataset('${path.replace(/'/g, "\\'")}', event)" data-path="${escapeHtml(path)}"${fileAttr}>
                <div class="tree-icon broken-link"></div>
                <div class="tree-label">${escapeHtml(key)}${linkBadge}</div>
                <div class="tree-meta" style="color:var(--color-kvot-accent);">broken link</div>
              </div>`;
              childrenHtml.push(brokenHtml);
              continue;
            }
            
            // Handle external links ‚Äî show external file reference
            if (objType === 'externallink') {
              const isSelected = selectedDatasetPath === path && !selectedIsRadionuclidesGroup;
              const extLabel = linkInfo ? linkInfo.filename : '?';
              const externalHtml = `<div class="tree-item external-link ${isSelected ? 'selected' : ''}" onclick="selectDataset('${path.replace(/'/g, "\\'")}', event)" data-path="${escapeHtml(path)}"${fileAttr}>
                <div class="tree-icon external-link"></div>
                <div class="tree-label">${escapeHtml(key)}${linkBadge}</div>
                <div class="tree-meta">\u2192 ${escapeHtml(extLabel)}</div>
              </div>`;
              childrenHtml.push(externalHtml);
              continue;
            }
            
            if (objType === 'group') {
              const isSelected = selectedDatasetPath === path && selectedIsRadionuclidesGroup;
              const groupHtml = `<div class="tree-item group ${isSelected ? 'expanded' : ''}" onclick="toggleGroup(event)" data-path="${escapeHtml(path)}"${fileAttr}>
                  <div class="tree-toggle ${isSelected ? '' : 'collapsed'}" onclick="event.stopPropagation(); toggleGroupExpansion(event, '${path.replace(/'/g, "\\'")}')">‚ñ∂</div>
                  <div class="tree-icon folder"></div>
                  <div class="tree-label">${escapeHtml(key)}${linkBadge}</div>
                </div>`;
              childrenHtml.push(groupHtml);
              
              try {
                const subItems = await buildTree(obj, path, true, '', intersectedPaths, fileKey);
                const childrenWrapper = `<div class="tree-group-children ${isSelected ? 'expanded' : ''}">${subItems || '<div style="color:#999;padding:8px;font-size:12px;">(empty)</div>'}</div>`;
                childrenHtml.push(childrenWrapper);
              } catch (subErr) {
                console.error('Error getting sub-items for', key, subErr);
                const errorWrapper = `<div class="tree-group-children"><div style="color:red;padding:8px;font-size:12px;">(error: ${escapeHtml(subErr.message)})</div></div>`;
                childrenHtml.push(errorWrapper);
              }
            } else if (objType === 'dataset') {
              const shape = obj.shape?.length ? `${obj.shape.join('√ó')}` : 'scalar';
              const formattedDtype = formatDataType(obj.dtype);
              const isSelected = selectedDatasetPath === path && !selectedIsRadionuclidesGroup;
              const datasetHtml = `<div class="tree-item dataset ${isSelected ? 'selected' : ''}" onclick="selectDataset('${path.replace(/'/g, "\\'")}', event)" data-path="${escapeHtml(path)}"${fileAttr}>
                <div class="tree-icon dataset"></div>
                <div class="tree-label">${escapeHtml(key)}${linkBadge}</div>
                <div class="tree-meta">${escapeHtml(formattedDtype)} [${escapeHtml(shape)}]</div>
              </div>`;
              childrenHtml.push(datasetHtml);
            }
          } catch (e) {
            console.error('Error with key', key, ':', e.message);
            childrenHtml.push(`<div class="tree-item" style="color:red;font-size:12px;">‚ö†Ô∏è ${escapeHtml(key)}</div>`);
          }
        }
      } catch (e) {
        console.error('buildTree error:', e);
      }
      
      if (prefix === '') {
        childrenHtml.push('</div>');
      }
      
      return childrenHtml.join('');
    }


    /* ==========================================================================
       7. RADIONUCLIDE LINE STYLES
       ========================================================================== */
    
    /**
     * Get the line style (color, dash pattern) for a radionuclide isotope.
     * 
     * Predefined styles are provided for common isotopes in categories:
     * - Actinides (Ac, Am, Cm, Np, Pa, Pu, Th, U)
     * - Fission products (Ag, Cs, I, Pd, Se, Sm, Sn, Sr, Tc, Zr)
     * - Activation products (Be, C, Cl, Co, H, Ni, Nb, Mo)
     * - Other radionuclides (various)
     * 
     * Colors are chosen for visual distinction on both light backgrounds
     * and when multiple isotopes are plotted together.
     * 
     * @param {string} name - Isotope name (e.g., 'U-238', 'Cs-137', 'C-14-org')
     * @returns {{color: string|null, dash: string, width: number}} Line style object
     * 
     * @example
     * getLineStyle('U-238')  // { color: 'rgb(255,0,0)', dash: 'solid', width: 2 }
     * getLineStyle('unknown') // { color: null, dash: 'solid', width: 2 }
     */
    function getLineStyle(name) {
      const lineStyles = {
        // Actinides
        'Ac-227': { color: 'rgb(128,0,0)', dash: 'solid' },
        'Am-241': { color: 'rgb(72,209,204)', dash: 'dashdot' },
        'Am-242m': { color: 'rgb(72,209,204)', dash: 'dash' },
        'Am-243': { color: 'rgb(72,209,204)', dash: 'solid' },
        'Cm-242': { color: 'rgb(175,238,238)', dash: 'dash' },
        'Cm-243': { color: 'rgb(175,238,238)', dash: 'solid' },
        'Cm-244': { color: 'rgb(175,238,238)', dash: 'dot' },
        'Cm-245': { color: 'rgb(175,238,238)', dash: 'dash' },
        'Cm-246': { color: 'rgb(175,238,238)', dash: 'dashdot' },
        'Np-237': { color: 'rgb(218,165,32)', dash: 'solid' },
        'Pa-231': { color: 'rgb(85,107,47)', dash: 'solid' },
        'Pu-238': { color: 'rgb(0,255,255)', dash: 'dot' },
        'Pu-239': { color: 'rgb(0,255,255)', dash: 'solid' },
        'Pu-240': { color: 'rgb(0,255,255)', dash: 'dash' },
        'Pu-241': { color: 'rgb(0,255,255)', dash: 'dashdot' },
        'Pu-242': { color: 'rgb(0,255,255)', dash: 'dash' },
        'Th-228': { color: 'rgb(75,0,130)', dash: 'dash' },
        'Th-229': { color: 'rgb(75,0,130)', dash: 'dot' },
        'Th-230': { color: 'rgb(75,0,130)', dash: 'solid' },
        'Th-232': { color: 'rgb(75,0,130)', dash: 'dash' },
        'U-232': { color: 'rgb(255,0,0)', dash: 'longdash' },
        'U-233': { color: 'rgb(255,0,0)', dash: 'dash' },
        'U-234': { color: 'rgb(255,0,0)', dash: 'dot' },
        'U-235': { color: 'rgb(255,0,0)', dash: 'dash' },
        'U-236': { color: 'rgb(255,0,0)', dash: 'dashdot' },
        'U-238': { color: 'rgb(255,0,0)', dash: 'solid' },
        
        // Fission products
        'Ag-108m': { color: 'rgb(128,128,0)', dash: 'solid' },
        'Cs-135': { color: 'rgb(0,128,0)', dash: 'solid' },
        'Cs-137': { color: 'rgb(0,128,0)', dash: 'dash' },
        'I-129': { color: 'rgb(30,144,255)', dash: 'solid' },
        'Pd-107': { color: 'rgb(216,191,216)', dash: 'solid' },
        'Se-79': { color: 'rgb(112,128,144)', dash: 'solid' },
        'Sm-151': { color: 'rgb(138,43,226)', dash: 'solid' },
        'Sn-126': { color: 'rgb(0,0,0)', dash: 'solid' },
        'Sr-90': { color: 'rgb(255,215,0)', dash: 'solid' },
        'Tc-99': { color: 'rgb(0,0,128)', dash: 'solid' },
        'Zr-93': { color: 'rgb(144,238,144)', dash: 'solid' },
        
        // Activation products
        'Be-10': { color: 'rgb(65,105,225)', dash: 'solid' },
        'C-14': { color: 'rgb(0,0,255)', dash: 'solid' },
        'C-14-org': { color: 'rgb(0,0,255)', dash: 'solid' },
        'C-14-ind': { color: 'rgb(0,0,255)', dash: 'dash' },
        'C-14-inorg': { color: 'rgb(0,0,255)', dash: 'dot' },
        'Cl-36': { color: 'rgb(210,105,30)', dash: 'solid' },
        'Co-60': { color: 'rgb(0,255,127)', dash: 'solid' },
        'H-3': { color: 'rgb(0,0,205)', dash: 'solid' },
        'Ni-59': { color: 'rgb(255,0,255)', dash: 'solid' },
        'Ni-63': { color: 'rgb(255,0,255)', dash: 'dash' },
        'Nb-93m': { color: 'rgb(210,180,140)', dash: 'solid' },
        'Nb-94': { color: 'rgb(210,180,140)', dash: 'dash' },
        'Mo-93': { color: 'rgb(0,255,0)', dash: 'solid' },
        
        // Other radionuclides
        'Ar-39': { color: 'rgb(152,251,152)', dash: 'solid' },
        'Ba-133': { color: 'rgb(70,130,180)', dash: 'solid' },
        'Ca-41': { color: 'rgb(128,0,128)', dash: 'solid' },
        'Cd-113m': { color: 'rgb(124,252,0)', dash: 'solid' },
        'Eu-150': { color: 'rgb(205,133,63)', dash: 'dash' },
        'Eu-152': { color: 'rgb(205,133,63)', dash: 'solid' },
        'Gd-148': { color: 'rgb(255,255,0)', dash: 'solid' },
        'Ho-166m': { color: 'rgb(100,149,237)', dash: 'solid' },
        'K-40': { color: 'rgb(139,69,19)', dash: 'solid' },
        'La-137': { color: 'rgb(255,248,220)', dash: 'solid' },
        'Pb-210': { color: 'rgb(148,0,211)', dash: 'dash' },
        'Po-210': { color: 'rgb(148,0,211)', dash: 'dot' },
        'Ra-226': { color: 'rgb(148,0,211)', dash: 'solid' },
        'Ra-228': { color: 'rgb(148,0,211)', dash: 'dash' },
        'Re-186m': { color: 'rgb(255,160,122)', dash: 'solid' },
        'Si-32': { color: 'rgb(255,228,181)', dash: 'solid' },
        'Tb-157': { color: 'rgb(221,160,221)', dash: 'solid' },
        'Tb-158': { color: 'rgb(221,160,221)', dash: 'dash' },
        'Ti-44': { color: 'rgb(218,112,214)', dash: 'solid' }
      };
      
      const defaultStyle = { color: null, dash: 'solid', width: 2 };
      
      if (name in lineStyles) {
        return { ...defaultStyle, ...lineStyles[name] };
      }
      
      return defaultStyle;
    }


    /* ==========================================================================
       8. CHART CONTROLS
       ========================================================================== */
    
    /**
     * Update the chart axis scales based on dropdown selections.
     * Applies new scale types (linear/log) without rebuilding the entire chart.
     * 
     * @returns {void}
     */
    function updateChartScales() {
      if (!currentChartData) return;
      
      const xScale = document.getElementById('xAxisScale').value;
      const yScale = document.getElementById('yAxisScale').value;
      
      const update = {
        'xaxis.type': xScale,
        'yaxis.type': yScale
      };
      
      Plotly.relayout('plotlyChart', update);
    }

    /**
     * Apply preset axis ranges optimized for viewing release data.
     * Sets both axes to log scale with ranges suitable for radionuclide releases.
     * X-axis: 100 - 100,000 (years)
     * Y-axis: 10,000 - 1e9 (activity units)
     * 
     * @returns {void}
     */
    function applyReleasePresetView() {
      if (!currentChartData) return;
      
      document.getElementById('xAxisScale').value = 'log';
      document.getElementById('yAxisScale').value = 'log';
      
      const update = {
        'xaxis.type': 'log',
        'xaxis.range': [Math.log10(100), Math.log10(100000)],
        'yaxis.type': 'log',
        'yaxis.range': [Math.log10(10000), Math.log10(1e9)]
      };
      
      Plotly.relayout('plotlyChart', update);
    }

    /**
     * Apply preset axis ranges optimized for viewing dose data.
     * Sets both axes to log scale with ranges suitable for dose rates.
     * X-axis: 1,000 - 100,000 (years)
     * Y-axis: 1e-10 - 1e-5 (Sv/year or similar units)
     * 
     * @returns {void}
     */
    function applyDosePresetView() {
      if (!currentChartData) return;
      
      document.getElementById('xAxisScale').value = 'log';
      document.getElementById('yAxisScale').value = 'log';
      
      const update = {
        'xaxis.type': 'log',
        'xaxis.range': [Math.log10(1000), Math.log10(1e5)],
        'yaxis.type': 'log',
        'yaxis.range': [Math.log10(1e-10), Math.log10(1e-5)]
      };
      
      Plotly.relayout('plotlyChart', update);
    }

    /**
     * Export current chart data to a CSV file.
     * Creates a downloadable file with columns: Series, X, Y.
     * Each trace in the chart becomes a series in the CSV.
     * 
     * @returns {void}
     */
    function downloadChartData() {
      if (!currentChartData) {
        alert('No chart data available');
        return;
      }
      
      let csv = 'Series,X,Y\n';
      
      for (const trace of currentChartData.traces) {
        const name = trace.name;
        for (let i = 0; i < trace.x.length; i++) {
          csv += `"${name}",${trace.x[i]},${trace.y[i]}\n`;
        }
      }
      
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `chart_data_${Date.now()}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    /**
     * Export current chart data to an Excel file (.xlsx).
     * Creates a workbook with two sheets:
     * - "Chart": Contains a native Excel scatter chart with the same look as Plotly
     * - "Data": Contains the chart data with time column and one column per trace
     * 
     * Uses xlsxwrite.js for native Excel chart creation with full feature support.
     * Creates a chart that matches the Plotly chart styling:
     * - Same axis type (log/linear) with proper logarithmic scale support
     * - Same line colors from traces
     * - Same dash patterns (solid, dash, dot, dashdot, longdash)
     * - Gridlines matching the Plotly style
     * - Lines without markers
     * 
     * @returns {Promise<void>}
     */
    async function downloadChartDataAsExcel() {
      if (!currentChartData) {
        alert('No chart data available');
        return;
      }
      
      // Check if xlsxwrite.js is ready
      if (!window.xlsxReady || !window.XlsxWriter) {
        alert('Excel export library is not loaded. Please refresh the page.');
        return;
      }
      
      try {
        const allTraces = currentChartData.traces;
        const layout = currentChartData.layout;
        
        // Get current state from the actual Plotly chart element
        const chartDiv = document.getElementById('plotlyChart');
        const plotlyTraces = chartDiv && chartDiv.data ? chartDiv.data : allTraces;
        const plotlyLayout = chartDiv && chartDiv.layout ? chartDiv.layout : layout;
        
        // Check if Dynamic Legend is enabled and we should filter by viewport
        const dynamicLegendCheckbox = document.getElementById('dynamicLegend');
        const isDynamicLegendEnabled = dynamicLegendCheckbox && dynamicLegendCheckbox.checked;
        
        let traces;
        
        if (isDynamicLegendEnabled && plotlyLayout.xaxis && plotlyLayout.yaxis) {
          // Filter traces based on whether they have data points in the current viewport
          const xRange = plotlyLayout.xaxis.range;
          const yRange = plotlyLayout.yaxis.range;
          
          if (xRange && yRange) {
            const xIsLog = plotlyLayout.xaxis.type === 'log';
            const yIsLog = plotlyLayout.yaxis.type === 'log';
            
            const xMin = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
            const xMax = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
            const yMin = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
            const yMax = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
            
            traces = plotlyTraces.filter(trace => {
              // Check if trace has any data points in the current viewport
              for (let j = 0; j < trace.x.length; j++) {
                const x = trace.x[j];
                const y = trace.y[j];
                if (x !== null && x !== undefined && y !== null && y !== undefined) {
                  if (x >= xMin && x <= xMax && y >= yMin && y <= yMax) {
                    return true;
                  }
                }
              }
              return false;
            });
          } else {
            traces = plotlyTraces;
          }
        } else {
          // Dynamic Legend off - export all traces (or filter by visible property)
          traces = plotlyTraces.filter(trace => {
            const visible = trace.visible;
            return visible === undefined || visible === true;
          });
        }
        
        if (traces.length === 0) {
          alert('No visible traces to export. Please show at least one trace in the chart.');
          return;
        }
        
        // Find the longest x array to determine row count
        const maxLength = Math.max(...traces.map(t => t.x ? t.x.length : 0));
        
        // Extract chart metadata
        const chartTitle = layout && layout.title && layout.title.text 
          ? layout.title.text 
          : 'Chart Data';
        const xAxisTitle = layout && layout.xaxis && layout.xaxis.title && layout.xaxis.title.text
          ? layout.xaxis.title.text
          : 'Time';
        const yAxisTitle = layout && layout.yaxis && layout.yaxis.title && layout.yaxis.title.text
          ? layout.yaxis.title.text
          : 'Value';
        
        // Detect axis types from Plotly layout
        const xAxisType = plotlyLayout && plotlyLayout.xaxis && plotlyLayout.xaxis.type ? plotlyLayout.xaxis.type : 'linear';
        const yAxisType = plotlyLayout && plotlyLayout.yaxis && plotlyLayout.yaxis.type ? plotlyLayout.yaxis.type : 'linear';
        
        // Helper function to parse rgb color string to [R, G, B] array
        const parseRgbColor = (colorStr) => {
          if (!colorStr) return null;
          // Handle rgb(r,g,b) format
          const rgbMatch = colorStr.match(/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i);
          if (rgbMatch) {
            return [parseInt(rgbMatch[1]), parseInt(rgbMatch[2]), parseInt(rgbMatch[3])];
          }
          // Handle hex format #RRGGBB or RRGGBB
          const hexMatch = colorStr.match(/#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
          if (hexMatch) {
            return [parseInt(hexMatch[1], 16), parseInt(hexMatch[2], 16), parseInt(hexMatch[3], 16)];
          }
          // Handle short hex format #RGB
          const shortHexMatch = colorStr.match(/^#?([a-f\d])([a-f\d])([a-f\d])$/i);
          if (shortHexMatch) {
            return [
              parseInt(shortHexMatch[1] + shortHexMatch[1], 16),
              parseInt(shortHexMatch[2] + shortHexMatch[2], 16),
              parseInt(shortHexMatch[3] + shortHexMatch[3], 16)
            ];
          }
          return null;
        };
        
        // Map Plotly dash type to Excel dash type (using sys variants for standard Excel look)
        const mapDashType = (plotlyDash) => {
          if (!plotlyDash || plotlyDash === 'solid') return 'solid';
          switch (plotlyDash) {
            case 'dash': return 'sysDash';
            case 'dot': return 'sysDot';
            case 'dashdot': return 'sysDashDot';
            case 'longdash': return 'lgDash';
            case 'longdashdot': return 'lgDashDot';
            default: return 'solid';
          }
        };
        
        // Fallback Plotly-like color palette (brighter colors)
        const plotlyColors = [
          [0x1F, 0x77, 0xB4], // blue
          [0xFF, 0x7F, 0x0E], // orange
          [0x2C, 0xA0, 0x2C], // green
          [0xD6, 0x27, 0x28], // red
          [0x94, 0x67, 0xBD], // purple
          [0x8C, 0x56, 0x4B], // brown
          [0xE3, 0x77, 0xC2], // pink
          [0x7F, 0x7F, 0x7F], // gray
          [0xBC, 0xBD, 0x22], // olive
          [0x17, 0xBE, 0xCF]  // cyan
        ];
        
        // Create workbook using xlsxwrite.js
        const xlsx = new XlsxWriter();
        
        // Plotly-like gridline color (light gray)
        const gridColor = 'E5ECF6';
        const minorGridColor = 'EEF2F8';
        
        // ============ CREATE CHART ============
        // Configure chart with axis settings
        const chartConfig = {
          width: 800,
          height: 500,
          scatterStyle: 'line',  // Line without markers
          showBorder: false,     // Remove chart border
          xAxis: {
            title: { text: xAxisTitle },
            numberFormat: '[>1000]### ### ### ##0;General',
            fontSize: 9,
            majorGridlines: { color: gridColor, width: 0.75 }
          },
          yAxis: {
            title: { text: yAxisTitle, customAngle: -90 },
            numberFormat: '0E+0',
            fontSize: 9,
            majorGridlines: { color: gridColor, width: 0.75 }
          },
          legend: { position: 'r', fontSize: 8 }
        };
        
        // Set logarithmic scale if Plotly uses it, and add minor gridlines/ticks
        if (xAxisType === 'log') {
          chartConfig.xAxis.logBase = 10;
          chartConfig.xAxis.minorGridlines = { color: minorGridColor, width: 0.5 };
          chartConfig.xAxis.minorTickMark = 'out';
        }
        if (yAxisType === 'log') {
          chartConfig.yAxis.logBase = 10;
          chartConfig.yAxis.minorGridlines = { color: minorGridColor, width: 0.5 };
          chartConfig.yAxis.minorTickMark = 'out';
        }
        
        // Set axis min/max to match current Plotly view
        // For log scale: always set limits (needed for proper scaling)
        // For linear scale: only set limits if user has zoomed (autorange is false)
        if (plotlyLayout.xaxis && plotlyLayout.xaxis.range) {
          const xRange = plotlyLayout.xaxis.range;
          const xIsLog = xAxisType === 'log';
          const xIsZoomed = plotlyLayout.xaxis.autorange === false;
          if (xIsLog || xIsZoomed) {
            chartConfig.xAxis.minimum = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
            chartConfig.xAxis.maximum = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
          }
        }
        if (plotlyLayout.yaxis && plotlyLayout.yaxis.range) {
          const yRange = plotlyLayout.yaxis.range;
          const yIsLog = yAxisType === 'log';
          const yIsZoomed = plotlyLayout.yaxis.autorange === false;
          if (yIsLog || yIsZoomed) {
            chartConfig.yAxis.minimum = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
            chartConfig.yAxis.maximum = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
          }
        }
        
        const chart = xlsx.newChart(chartConfig);
        
        // Get x values from the first trace
        const xValues = traces.length > 0 && traces[0].x ? traces[0].x : [];
        
        // Add series to chart
        traces.forEach((trace, idx) => {
          // Get color from trace or use fallback
          let color = plotlyColors[idx % plotlyColors.length];
          const traceColor = trace.line?.color || trace.marker?.color || null;
          if (traceColor) {
            const parsedColor = parseRgbColor(traceColor);
            if (parsedColor) {
              color = parsedColor;
            }
          }
          
          // Get dash type from trace
          const dashType = mapDashType(trace.line?.dash);
          
          // Get line width from trace (default to 2 if not specified)
          const lineWidth = trace.line?.width || 2;
          
          // Filter out null/undefined values
          const yVals = trace.y || [];
          const xVals = trace.x || xValues;
          
          // Create series with xlsxwrite.js
          const series = xlsx.newSeries({
            name: { text: trace.name || `Series ${idx + 1}` },
            x: { values: xVals.map(v => v === null || v === undefined ? NaN : v) },
            y: { values: yVals.map(v => v === null || v === undefined ? NaN : v) },
            length: Math.max(xVals.length, yVals.length),
            line: {
              color: { option: 'Solid', value: color },
              width: lineWidth,
              dashType: dashType,
              capType: 'rnd',
              compoundType: 'sng',
              joinType: 'round',
              beginType: 'none',
              endType: 'none'
            },
            marker: { option: 'NoMarker' }
          });
          
          chart.series.push(series);
        });
        
        // ============ PREPARE DATA ============
        // Build data array with headers
        const headers = ['Time', ...traces.map((t, i) => t.name || `Series ${i + 1}`)];
        const dataRows = [];
        
        for (let i = 0; i < maxLength; i++) {
          const row = [xValues[i] !== undefined ? xValues[i] : null];
          traces.forEach(trace => {
            row.push(trace.y && trace.y[i] !== undefined ? trace.y[i] : null);
          });
          dataRows.push(row);
        }
        
        // Position chart to the right of the data (after all data columns)
        chart.x = (traces.length + 2) * 64;  // Offset by number of columns + margin
        chart.y = 0;
        
        // Write Data sheet with both data AND chart
        xlsx.writeData([headers, ...dataRows], 'Data', { chart: chart });
        
        // Generate filename
        const safeTitle = chartTitle.replace(/[^a-z0-9]/gi, '_').substring(0, 50);
        const filename = `${safeTitle}_${Date.now()}.xlsx`;
        
        // Save and download the file
        await xlsx.saveAs(filename);
        
      } catch (err) {
        console.error('Excel export failed:', err);
        alert('Failed to export to Excel: ' + err.message);
      }
    }
    
    /**
     * Handle "Show Total" checkbox toggle for radionuclides charts.
     * When checked, adds a trace showing the sum of all radionuclide activities.
     * Only applicable when viewing a radionuclides group.
     * 
     * @returns {void}
     */
    function toggleShowTotal() {
      if (selectedIsRadionuclidesGroup && selectedDatasetPath) {
        const savedAxis = captureAxisState();
        createRadionuclidesChart(selectedDatasetPath, savedAxis);
      }
    }

    /**
     * Handle "Show Ratio" checkbox toggle for radionuclides charts.
     * When checked, appends the ratio of max values (thick/thin) to the legend
     * name of thick-line traces.
     * 
     * @returns {void}
     */
    function toggleShowRatio() {
      if (selectedIsRadionuclidesGroup && selectedDatasetPath) {
        const savedAxis = captureAxisState();
        createRadionuclidesChart(selectedDatasetPath, savedAxis);
      }
    }


    /* ==========================================================================
       9. CHART CREATION
       ========================================================================== */
    
    /**
     * Create a Plotly chart for a single time-dependent dataset.
     * Plots the dataset from all enabled files as separate traces,
     * allowing comparison across files.
     * 
     * @param {string} path - HDF5 path to the dataset
     * @returns {void}
     */
    function createPlotlyChart(path) {
      const plotDiv = getElement('plotlyChart');
      const chartContainer = getElement('plotlyChartContainer');
      plotDiv.innerHTML = '';
      
      // Hide "Show Total" and "Show Ratio" checkboxes (only for radionuclides groups)
      setShowTotalVisible(false);
      setShowRatioVisible(false);
      
      const traces = [];
      const enabledFiles = getEffectiveFiles();
      
      let timeUnit = '';
      let yAxisUnit = '';
      let yAxisName = path.split('/').pop();
      
      if (enabledFiles.length > 0) {
        const firstFile = loadedFiles[enabledFiles[0]];
        timeUnit = getTimeUnit(firstFile);
        
        // Get y-axis unit from dataset
        try {
          const dataset = firstFile.get(path);
          if (dataset && dataset.attrs && typeof dataset.attrs === 'object') {
            for (const attrName in dataset.attrs) {
              if (attrName === 'unit') {
                const attrObj = dataset.attrs[attrName];
                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                  yAxisUnit = attrObj.value;
                }
              }
            }
          }
        } catch (e) {
          console.warn('Could not read unit from dataset:', e);
        }
      }
      
      // Build traces for each enabled file
      for (const fileKey of enabledFiles) {
        const file = loadedFiles[fileKey];
        
        if (!checkDatasetExistsInFile(file, path)) {
          continue;
        }
        
        try {
          const dataset = file.get(path);
          
          if (!isTimeDependent(dataset)) {
            continue;
          }
          
          const timeData = getTimeData(file);
          if (!timeData) {
            console.warn(`No /time dataset found in ${fileKey}`);
            continue;
          }
          
          let yData;
          if (typeof dataset.value !== 'undefined') {
            yData = dataset.value;
          } else if (typeof dataset.toArray === 'function') {
            yData = dataset.toArray();
          }
          
          if (yData) {
            let yArray = normalizeDataArray(yData);
            
            // Handle probabilistic data (take mean)
            if (checkIsProbabilistic(dataset)) {
              yArray = computeProbabilisticMean(yArray, timeData);
            }

            // Handle length mismatch
            const minLength = Math.min(timeData.length, yArray.length);
            if (timeData.length !== yArray.length) {
              console.warn(`Time data length (${timeData.length}) doesn't match data length (${yArray.length}) for ${fileKey}`);
            }
            
            traces.push({
              x: timeData.slice(0, minLength),
              y: yArray.slice(0, minLength),
              mode: 'lines',
              name: fileKey,
              type: 'scatter'
            });
          }
        } catch (e) {
          console.error(`Error creating trace for ${fileKey}:`, e);
        }
      }
      
      // Render chart if we have data
      if (traces.length > 0) {
        const { xScale, yScale } = getChartScales();
        const yAxisTitle = yAxisUnit ? `${yAxisName} (${yAxisUnit})` : yAxisName;
        
        const layout = createBaseLayout({
          title: path,
          xAxisTitle: timeUnit ? `Time (${timeUnit})` : 'Time',
          yAxisTitle,
          xScale,
          yScale
        });

        renderChart(traces, layout, path);
      } else {
        hideChart();
      }
    }

    /**
     * Create a Plotly chart comparing multiple selected datasets.
     * Each selection item carries its own fileKey so cross-file comparisons work.
     * 
     * Used in multi-select mode (Ctrl+click on datasets, possibly from different files).
     * 
     * @param {{path: string, fileKey: string|null}[]} items - Array of selected dataset items
     * @returns {void}
     */
    function createMultiDatasetChart(items) {
      const plotDiv = getElement('plotlyChart');
      const chartContainer = getElement('plotlyChartContainer');
      plotDiv.innerHTML = '';
      
      // Hide "Show Total" and "Show Ratio" checkboxes (only for radionuclides groups)
      setShowTotalVisible(false);
      setShowRatioVisible(false);
      
      const traces = [];
      const yAxisUnits = new Set();
      let timeUnit = '';
      
      // Normalize items: if fileKey is null (intersect mode), expand to all enabled files
      const normalizedItems = [];
      for (const item of items) {
        if (item.fileKey && loadedFiles[item.fileKey]) {
          normalizedItems.push(item);
        } else {
          // Intersect mode ‚Äî expand to all enabled files
          for (const fk of getEnabledFiles()) {
            normalizedItems.push({ path: item.path, fileKey: fk });
          }
        }
      }
      
      // Collect unique file keys from items
      const uniqueFileKeys = [...new Set(normalizedItems.map(d => d.fileKey).filter(Boolean))];
      if (uniqueFileKeys.length === 0) return hideChart();
      
      // Use first file for time unit
      const firstFile = loadedFiles[uniqueFileKeys[0]];
      if (firstFile) timeUnit = getTimeUnit(firstFile);
      
      // Color palette for different datasets
      const colors = [
        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
        '#1abc9c', '#e67e22', '#34495e', '#c0392b', '#2980b9',
        '#27ae60', '#f1c40f', '#8e44ad', '#16a085', '#d35400'
      ];
      
      // Unique paths for color assignment
      const uniquePaths = [...new Set(normalizedItems.map(d => d.path))];
      const multiFile = uniqueFileKeys.length > 1;
      const multiPath = uniquePaths.length > 1;
      
      for (const [itemIndex, item] of normalizedItems.entries()) {
        const { path, fileKey } = item;
        const datasetName = path.split('/').pop();
        const pathIdx = uniquePaths.indexOf(path);
        const baseColor = colors[pathIdx % colors.length];
        
        const file = loadedFiles[fileKey];
        if (!file || !checkDatasetExistsInFile(file, path)) continue;
        
        try {
          const dataset = file.get(path);
          if (!isTimeDependent(dataset)) continue;
          
          // Get unit
          let yAxisUnit = '';
          if (dataset.attrs && typeof dataset.attrs === 'object') {
            for (const attrName in dataset.attrs) {
              if (attrName === 'unit') {
                const attrObj = dataset.attrs[attrName];
                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                  yAxisUnit = attrObj.value;
                  yAxisUnits.add(yAxisUnit);
                }
              }
            }
          }
          
          const timeData = getTimeData(file);
          if (!timeData) {
            console.warn(`No /time dataset found in ${fileKey}`);
            continue;
          }
          
          let yData;
          if (typeof dataset.value !== 'undefined') {
            yData = dataset.value;
          } else if (typeof dataset.toArray === 'function') {
            yData = dataset.toArray();
          }
          
          if (yData) {
            let yArray = normalizeDataArray(yData);
            
            // Handle probabilistic data (take mean)
            if (checkIsProbabilistic(dataset)) {
              yArray = computeProbabilisticMean(yArray, timeData);
            }

            const minLength = Math.min(timeData.length, yArray.length);
            const trimmedTimeData = timeData.slice(0, minLength);
            const trimmedYData = yArray.slice(0, minLength);
            
            // Build trace name ‚Äî show file label when multiple files, path when multiple paths
            let traceName = datasetName;
            let lineWidth = 2;
            let lineDash = 'solid';
            
            if (multiFile && multiPath) {
              const diffLabel = filenameDiff(uniqueFileKeys[0], fileKey);
              traceName = `${datasetName} (${diffLabel})`;
            } else if (multiFile) {
              traceName = fileKey;
            }
            // else just datasetName for single-file multi-path
            
            if (multiFile) {
              const fileIdx = uniqueFileKeys.indexOf(fileKey);
              const dashStyles = ['solid', 'dash', 'dot', 'dashdot'];
              lineDash = dashStyles[fileIdx % dashStyles.length];
              lineWidth = 1.5;
            }
            
            traces.push({
              x: trimmedTimeData,
              y: trimmedYData,
              mode: 'lines',
              name: traceName,
              line: {
                color: baseColor,
                dash: lineDash,
                width: lineWidth
              },
              type: 'scatter',
              hovertemplate: `<b>${traceName}</b><br>Time: %{x}<br>Value: %{y}<extra></extra>`
            });
          }
        } catch (e) {
          console.error(`Error creating trace for ${path} in ${fileKey}:`, e);
        }
      }
      
      if (traces.length > 0) {
        const { xScale, yScale } = getChartScales();
        
        let yAxisTitle = 'Value';
        if (yAxisUnits.size === 1) {
          yAxisTitle = `Value (${Array.from(yAxisUnits)[0]})`;
        } else if (yAxisUnits.size > 1) {
          yAxisTitle = `Value (${Array.from(yAxisUnits).join(', ')})`;
        }
        
        const paths = normalizedItems.map(d => d.path);
        const layout = createBaseLayout({
          title: `Comparing ${normalizedItems.length} dataset${normalizedItems.length > 1 ? 's' : ''}`,
          xAxisTitle: timeUnit ? `Time (${timeUnit})` : 'Time',
          yAxisTitle,
          xScale,
          yScale
        });
        layout.margin.r = 200; // Extra room for longer legend names
        
        const config = getPlotlyConfig('multi_dataset_chart');

        currentChartData = { traces, layout, paths };
        const container = getElement('plotlyChartContainer');
        if (container) container.classList.add('visible');
        if (dynamicLegendEnabled) {
          assignLegendRanks(traces);
        }
        Plotly.newPlot('plotlyChart', traces, layout, config).then(() => {
          setupDynamicLegend(getElement('plotlyChart'));
        });
      } else {
        hideChart();
      }
    }

    /**
     * Create a Plotly chart for a radionuclides data group.
     * Plots all child datasets (isotopes) with predefined line styles.
     * 
     * Features:
     * - Each isotope uses its characteristic color and dash pattern
     * - "Show Total" checkbox adds a summed trace
     * - Supports multi-file comparison with thinner lines for secondary files
     * 
     * @param {string} path - HDF5 path to the radionuclides group
     * @returns {void}
     */
    function createRadionuclidesChart(path, savedAxisState) {
      const plotDiv = getElement('plotlyChart');
      const chartContainer = getElement('plotlyChartContainer');
      plotDiv.innerHTML = '';
      
      // Show "Show Total" checkbox for radionuclides groups
      setShowTotalVisible(true);
      
      const traces = [];
      const enabledFiles = getEffectiveFiles();
      
      // Show "Show Ratio" checkbox only when exactly 2 files are enabled (thick + thin lines)
      // and secondary file has data for this path ‚Äî will be set after building traces
      const hasTwoFiles = enabledFiles.length === 2;
      setShowRatioVisible(false);
      
      // Store data for computing total
      const totalDataByFile = {};
      
      // Track the starting index of each file's traces in the traces array
      const fileTraceStartIndex = {};

      let timeUnit = '';
      let yAxisUnit = '';
      let yAxisName = path.split('/').pop();
      
      if (enabledFiles.length > 0) {
        const firstFile = loadedFiles[enabledFiles[0]];
        timeUnit = getTimeUnit(firstFile);
      }
      
      // Build traces for each file and each radionuclide
      for (const fileKey of enabledFiles) {
        const file = loadedFiles[fileKey];
        
        // Record where this file's traces begin
        fileTraceStartIndex[fileKey] = traces.length;
        
        if (!checkDatasetExistsInFile(file, path)) {
          continue;
        }
        
        try {
          const group = file.get(path);
          if (!group || group.type.toLowerCase() !== 'group') {
            continue;
          }
          
          const timeData = getTimeData(file);
          if (!timeData) {
            console.warn(`No /time dataset found in ${fileKey}`);
            continue;
          }
          
          let datasetKeys = [];
          try {
            if (typeof group.keys === 'function') {
              datasetKeys = Array.from(group.keys());
            }
          } catch (e) {
            console.error('Error getting dataset keys:', e);
            continue;
          }
          
          for (const datasetKey of datasetKeys) {
            try {
              const dataset = group.get(datasetKey);
              if (!dataset || dataset.type.toLowerCase() !== 'dataset') {
                continue;
              }
              
              let yData;
              if (typeof dataset.value !== 'undefined') {
                yData = dataset.value;
              } else if (typeof dataset.toArray === 'function') {
                yData = dataset.toArray();
              }
              
              if (yData) {
                let yArray = normalizeDataArray(yData);
                
                // Handle probabilistic data
                if (checkIsProbabilistic(dataset)) {
                  yArray = computeProbabilisticMean(yArray, timeData);
                }

                const minLength = Math.min(timeData.length, yArray.length);
                const trimmedTimeData = timeData.slice(0, minLength);
                const trimmedYData = yArray.slice(0, minLength);
                
                // Store data for computing total
                if (!totalDataByFile[fileKey]) {
                  totalDataByFile[fileKey] = { timeData: trimmedTimeData, dataArrays: [] };
                }
                totalDataByFile[fileKey].dataArrays.push(trimmedYData);
                
                // Get line style for this radionuclide
                const lineStyle = getLineStyle(datasetKey);
                let traceName = datasetKey;
                let lineWidth = lineStyle.width;
                
                if (enabledFiles.length > 1 && enabledFiles.indexOf(fileKey) > 0) {
                  traceName = `${datasetKey} (${filenameDiff(enabledFiles[0], fileKey)})`;
                  lineWidth = lineWidth / 2;
                }
                
                traces.push({
                  x: trimmedTimeData,
                  y: trimmedYData,
                  mode: 'lines',
                  name: traceName,
                  line: {
                    color: lineStyle.color,
                    dash: lineStyle.dash,
                    width: lineWidth
                  },
                  type: 'scatter'
                });
              }
            } catch (e) {
              console.error(`Error creating trace for ${datasetKey} in ${fileKey}:`, e);
            }
          }
        } catch (e) {
          console.error(`Error processing group for ${fileKey}:`, e);
        }
      }
      
      // Now that traces are built, show "Show Ratio" only if both files contributed data
      if (hasTwoFiles) {
        const secondaryFile = enabledFiles[1];
        const secondaryStart = fileTraceStartIndex[secondaryFile] != null ? fileTraceStartIndex[secondaryFile] : traces.length;
        const secondaryHasTraces = secondaryStart < traces.length;
        setShowRatioVisible(secondaryHasTraces);
      }

      // Collect max values per radionuclide per file (needed for ratio display)
      const showRatioCheckbox = getElement('showRatio');
      const showRatioChecked = hasTwoFiles && showRatioCheckbox && showRatioCheckbox.checked;
      const maxByFileAndName = {}; // { datasetKey: { fileKey: maxVal } }
      if (showRatioChecked) {
        for (const fileKey of enabledFiles) {
          const fileData = totalDataByFile[fileKey];
          if (!fileData) continue;
          const file = loadedFiles[fileKey];
          const group = file.get(path);
          let datasetKeys = [];
          try {
            if (typeof group.keys === 'function') {
              datasetKeys = Array.from(group.keys());
            }
          } catch (e) { /* ignore */ }
          // Match datasetKeys to dataArrays by index
          for (let i = 0; i < datasetKeys.length && i < fileData.dataArrays.length; i++) {
            const key = datasetKeys[i];
            const arr = fileData.dataArrays[i];
            const maxVal = Math.max(...arr);
            if (!maxByFileAndName[key]) maxByFileAndName[key] = {};
            maxByFileAndName[key][fileKey] = maxVal;
          }
        }
      }

      const primaryFile = enabledFiles[0];
      const secondaryFile = hasTwoFiles ? enabledFiles[1] : null;

      /**
       * Format a ratio value to a display string (3 significant digits).
       * @param {number} ratio
       * @returns {string}
       */
      function formatRatio(ratio) {
        if (ratio === 0 || !isFinite(ratio)) return ratio.toString();
        return ratio.toPrecision(3);
      }

      // Add total traces, each at the top of its corresponding file's group in the legend
      const showTotalCheckbox = getElement('showTotal');
      if (showTotalCheckbox && showTotalCheckbox.checked) {
        // Compute total per file and collect total max values for ratio
        const totalMaxByFile = {}; // { fileKey: maxTotalValue }
        const totalTracesByFile = {}; // { fileKey: traceObject }
        for (const fileKey of Object.keys(totalDataByFile)) {
          const fileData = totalDataByFile[fileKey];
          if (fileData.dataArrays.length > 0) {
            const timeData = fileData.timeData;
            const totalY = new Array(timeData.length).fill(0);
            
            // Sum all data arrays
            for (const dataArray of fileData.dataArrays) {
              for (let i = 0; i < Math.min(dataArray.length, totalY.length); i++) {
                totalY[i] += dataArray[i];
              }
            }
            
            totalMaxByFile[fileKey] = Math.max(...totalY);

            let traceName = 'Total';
            let lineWidth = 2;
            
            if (enabledFiles.length > 1 && enabledFiles.indexOf(fileKey) > 0) {
              traceName = `Total (${filenameDiff(enabledFiles[0], fileKey)})`;
              lineWidth = 1;
            }
            
            totalTracesByFile[fileKey] = {
              x: timeData,
              y: totalY,
              mode: 'lines',
              name: traceName,
              line: {
                color: '#000000',
                dash: 'solid',
                width: lineWidth
              },
              type: 'scatter'
            };
          }
        }

        // If Show Ratio is checked, append ratio to the primary Total trace name
        if (showRatioChecked && secondaryFile) {
          const t = totalTracesByFile[primaryFile];
          if (t && t.name === 'Total') {
            const maxPrimary = totalMaxByFile[primaryFile];
            const maxSecondary = totalMaxByFile[secondaryFile];
            if (maxSecondary != null && maxSecondary !== 0) {
              t.name = `Total (${formatRatio(maxPrimary / maxSecondary)})`;
            } else if (maxSecondary === 0 && maxPrimary > 0) {
              t.name = `Total (‚àû)`;
            }
          }
        }

        // Insert each total trace at the beginning of its file's group.
        // Process files in reverse order so earlier splice positions stay valid.
        const filesWithTotals = enabledFiles.filter(fk => totalTracesByFile[fk]);
        for (let i = filesWithTotals.length - 1; i >= 0; i--) {
          const fk = filesWithTotals[i];
          const insertIdx = fileTraceStartIndex[fk] != null ? fileTraceStartIndex[fk] : traces.length;
          traces.splice(insertIdx, 0, totalTracesByFile[fk]);
        }
      }

      // Update thick-line trace names with ratio of max values if "Show Ratio" is checked
      if (showRatioChecked) {
        for (const trace of traces) {
          // Thick-line traces are those from the primary file (no fileKey suffix, not Total)
          for (const datasetKey of Object.keys(maxByFileAndName)) {
            if (trace.name === datasetKey) {
              const maxPrimary = maxByFileAndName[datasetKey][primaryFile];
              const maxSecondary = maxByFileAndName[datasetKey][secondaryFile];
              if (maxSecondary != null && maxSecondary !== 0) {
                trace.name = `${datasetKey} (${formatRatio(maxPrimary / maxSecondary)})`;
              } else if (maxSecondary === 0 && maxPrimary > 0) {
                trace.name = `${datasetKey} (‚àû)`;
              }
              break;
            }
          }
        }
        
        // Hide thin-line (secondary file) traces from legend ‚Äî keep them visible in chart.
        // Secondary file traces have halved line widths compared to primary ones.
        for (const trace of traces) {
          const w = trace.line && trace.line.width;
          // Thick (primary) traces have width >= 2, thin (secondary) have width < 2
          // Total traces: primary=2, secondary=1. Radionuclide traces: primary=original, secondary=original/2.
          // We keep ratio-annotated traces and primary Total in the legend.
          if (w != null && w < 2) {
            trace.showlegend = false;
            trace._hiddenFromLegend = true; // preserve across dynamic legend updates
          }
        }
      }
      
      // Render chart if we have traces
      if (traces.length > 0) {
        // Get unit from group
        const firstFile = loadedFiles[enabledFiles[0]];
        try {
          const group = firstFile.get(path);
          if (group && group.attrs && typeof group.attrs === 'object') {
            for (const attrName in group.attrs) {
              if (attrName === 'unit') {
                const attrObj = group.attrs[attrName];
                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                  yAxisUnit = attrObj.value;
                }
              }
            }
          }
        } catch (e) {
          console.warn('Could not read unit from group:', e);
        }
        
        const { xScale, yScale } = getChartScales();
        const yAxisTitle = yAxisUnit ? `${yAxisName} (${yAxisUnit})` : yAxisName;
        
        const layout = createBaseLayout({
          title: path,
          xAxisTitle: timeUnit ? `Time (${timeUnit})` : 'Time',
          yAxisTitle,
          xScale,
          yScale
        });
        
        // Preserve axis ranges when toggling controls (Show Total, Show Ratio)
        applyAxisState(layout, savedAxisState);
        
        renderChart(traces, layout, path);
      } else {
        hideChart();
      }
    }
    
    /**
     * Get standard Plotly configuration with custom toolbar buttons.
     * Configures the mode bar with:
     * - Copy to clipboard button (PNG export)
     * - Download CSV button (data export)
     * - Download Excel button (xlsx export)
     * - Standard Plotly zoom/pan/reset tools
     * - SVG export configuration
     * 
     * @param {string} filename - Base filename for exported images/data
     * @returns {Object} Plotly config object
     */
    function getPlotlyConfig(filename) {
      return {
        displayLogo: false,
        scrollZoom: true,
        showLink: false,
        plotlyServerURL: "https://chart-studio.plotly.com",
        modeBarButtonsToAdd: [
          'v1hovermode',
          {
            name: 'Copy chart to clipboard',
            icon: {
              width: 500,
              height: 600,
              path: 'M224 0c-35.3 0-64 28.7-64 64V288v64 64c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V288 160 64c0-35.3-28.7-64-64-64H224zm0 64H448V160H224V64zM160 448c0 17.7-14.3 32-32 32H64c-17.7 0-32-14.3-32-32V384H160v64zm0-96H32V288H160v64zM32 240V176H160v64H32zM160 128V64h32v64H160z'
            },
            click: function(gd) {
              copyChartToClipboard();
            }
          },
          {
            name: 'Download data as CSV',
            icon: {
              width: 512,
              height: 512,
              path: 'M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zm368 56a24 24 0 1 1 0 48 24 24 0 1 1 0-48z'
            },
            click: function(gd) {
              downloadChartData();
            }
          },
          {
            name: 'Download data as Excel',
            icon: {
              width: 384,
              height: 512,
              path: 'M64 0C28.7 0 0 28.7 0 64V448c0 35.3 28.7 64 64 64H320c35.3 0 64-28.7 64-64V160H256c-17.7 0-32-14.3-32-32V0H64zM256 0V128H384L256 0zM155.7 250.2L192 302.1l36.3-51.9c7.6-10.9 22.6-13.5 33.4-5.9s13.5 22.6 5.9 33.4L221.3 344l46.4 66.2c7.6 10.9 5 25.8-5.9 33.4s-25.8 5-33.4-5.9L192 385.8l-36.3 51.9c-7.6 10.9-22.6 13.5-33.4 5.9s-13.5-22.6-5.9-33.4L162.7 344l-46.4-66.2c-7.6-10.9-5-25.8 5.9-33.4s25.8-5 33.4 5.9z'
            },
            click: function(gd) {
              downloadChartDataAsExcel();
            }
          }
        ],
        responsive: true,
        toImageButtonOptions: {
          format: 'svg',
          filename: filename,
          height: 600,
          width: 800,
          scale: 1
        }
      };
    }


    /* ==========================================================================
       10. DYNAMIC LEGEND
       ========================================================================== */
    
    /**
     * Toggle dynamic legend filtering on/off.
     * When enabled, only traces with data points visible in the current
     * viewport are shown in the legend. When disabled, all traces are shown.
     * 
     * @returns {void}
     */
    function toggleDynamicLegend() {
      dynamicLegendEnabled = document.getElementById('dynamicLegend').checked;
      
      const plotDiv = document.getElementById('plotlyChart');
      if (!plotDiv || !plotDiv.data || !plotDiv.layout) {
        return;
      }
      
      if (!dynamicLegendEnabled) {
        // Show all legend items (except those explicitly hidden, e.g. by Show Ratio)
        const showlegendValues = plotDiv.data.map(trace => !trace._hiddenFromLegend);
        
        Plotly.restyle(plotDiv, { showlegend: showlegendValues }).then(() => {
          const statusEl = document.getElementById('legendStatus');
          if (statusEl) {
            statusEl.style.display = 'none';
          }
        });
      } else {
        // Re-apply dynamic filtering based on current view
        const layout = plotDiv.layout;
        
        // Re-apply legend sorting by max Y value
        assignLegendRanks(plotDiv.data);

        let xRange = layout.xaxis?.range;
        let yRange = layout.yaxis?.range;
        
        if (!xRange || !yRange) {
          return;
        }
        
        const xIsLog = layout.xaxis?.type === 'log';
        const yIsLog = layout.yaxis?.type === 'log';
        
        const xMin = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
        const xMax = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
        const yMin = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
        const yMax = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
        
        let visibleCount = 0;
        const showlegendValues = plotDiv.data.map((trace) => {
          let isVisible = false;
          
          for (let j = 0; j < trace.x.length; j++) {
            const x = trace.x[j];
            const y = trace.y[j];
            
            if (x === null || x === undefined || y === null || y === undefined) {
              continue;
            }
            
            if (x >= xMin && x <= xMax && y >= yMin && y <= yMax) {
              isVisible = true;
              break;
            }
          }
          
          // Never show in legend if explicitly hidden (e.g. by Show Ratio)
          const legendVisible = trace._hiddenFromLegend ? false : isVisible;
          if (legendVisible) visibleCount++;
          
          return legendVisible;
        });
        
        const legendrankValues = plotDiv.data.map(t => t.legendrank);
        Plotly.restyle(plotDiv, { showlegend: showlegendValues, legendrank: legendrankValues }).then(() => {
          const totalCount = plotDiv.data.length;
          const statusEl = document.getElementById('legendStatus');
          
          if (statusEl) {
            if (visibleCount < totalCount) {
              statusEl.textContent = `Showing ${visibleCount}/${totalCount} traces`;
              statusEl.style.display = 'block';
            } else {
              statusEl.style.display = 'none';
            }
          }
        });
      }
    }
    
    /**
     * Set up dynamic legend filtering on zoom/pan events.
     * Attaches a plotly_relayout listener that updates legend visibility
     * based on which traces have data points in the current viewport.
     * 
     * This helps reduce legend clutter when zoomed in on charts with many traces.
     * A status indicator shows "Showing X/Y traces" when filtering is active.
     * 
     * @param {HTMLElement} plotDiv - The Plotly chart DOM element
     * @returns {void}
     */
    function setupDynamicLegend(plotDiv) {
      plotDiv.on('plotly_relayout', function(eventData) {
        if (!dynamicLegendEnabled) return;
        
        if (!eventData || (!eventData['xaxis.range[0]'] && !eventData['xaxis.range'] && !eventData['xaxis.autorange'])) {
          return;
        }
        
        const fullData = plotDiv.data;
        const layout = plotDiv.layout;
        
        let xRange, yRange;
        
        if (eventData['xaxis.autorange'] || eventData['yaxis.autorange']) {
          // Autorange - show all traces (except those explicitly hidden, e.g. by Show Ratio)
          const visibility = fullData.map(trace => !trace._hiddenFromLegend);
          Plotly.restyle(plotDiv, { showlegend: visibility });
          
          const statusEl = document.getElementById('legendStatus');
          if (statusEl) {
            statusEl.style.display = 'none';
          }
          return;
        }
        
        // Get axis ranges
        if (eventData['xaxis.range[0]'] !== undefined) {
          xRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
        } else if (eventData['xaxis.range']) {
          xRange = eventData['xaxis.range'];
        } else if (layout.xaxis && layout.xaxis.range) {
          xRange = layout.xaxis.range;
        }
        
        if (eventData['yaxis.range[0]'] !== undefined) {
          yRange = [eventData['yaxis.range[0]'], eventData['yaxis.range[1]']];
        } else if (eventData['yaxis.range']) {
          yRange = eventData['yaxis.range'];
        } else if (layout.yaxis && layout.yaxis.range) {
          yRange = layout.yaxis.range;
        }
        
        if (!xRange || !yRange) return;
        
        // Convert log scale ranges
        const xIsLog = layout.xaxis && layout.xaxis.type === 'log';
        const yIsLog = layout.yaxis && layout.yaxis.type === 'log';
        
        const xMin = xIsLog ? Math.pow(10, xRange[0]) : xRange[0];
        const xMax = xIsLog ? Math.pow(10, xRange[1]) : xRange[1];
        const yMin = yIsLog ? Math.pow(10, yRange[0]) : yRange[0];
        const yMax = yIsLog ? Math.pow(10, yRange[1]) : yRange[1];
        
        // Check each trace for visibility (respect _hiddenFromLegend flag)
        const visibility = fullData.map((trace, i) => {
          if (trace._hiddenFromLegend) return false;
          for (let j = 0; j < trace.x.length; j++) {
            const x = trace.x[j];
            const y = trace.y[j];
            
            if (x === null || x === undefined || y === null || y === undefined) {
              continue;
            }
            
            if (x >= xMin && x <= xMax && y >= yMin && y <= yMax) {
              return true;
            }
          }
          return false;
        });
        
        Plotly.restyle(plotDiv, { showlegend: visibility }).then(() => {
          const visibleCount = visibility.filter(v => v).length;
          const totalCount = fullData.length;
          const statusEl = document.getElementById('legendStatus');
          
          if (statusEl) {
            if (visibleCount < totalCount) {
              statusEl.textContent = `Showing ${visibleCount}/${totalCount} traces`;
              statusEl.style.display = 'block';
            } else {
              statusEl.style.display = 'none';
            }
          }
        });
      });
    }


    /* ==========================================================================
       11. DATASET INFORMATION DISPLAY
       ========================================================================== */
    
    /**
     * Display node attributes and information for a selected path
     * Shows data preview, attributes table, and triggers chart if time-dependent
     * @param {string} path - HDF5 path to the node
     * @param {boolean} isGroup - Whether the node is a group (vs dataset)
     */
    function showNodeAttributes(path, isGroup = false) {
      const infoDiv = document.getElementById('info');
      infoDiv.innerHTML = '<div class="loading">Loading...</div>';
      
      const jsonReplacer = (key, value) => {
        if (typeof value === 'bigint') {
          return Number(value);
        }
        if (value && typeof value === 'object' && value.length !== undefined) {
          return Array.from(value);
        }
        return value;
      };
      
      try {
        const enabledFiles = getEffectiveFiles();
        let html = '';
        let hasTimeDependentData = false;
        let isRadionuclidesGroup = false;
        let pdfHistogramData = null;
        
        // Check if this is a radionuclides group
        if (isGroup && enabledFiles.length > 0) {
          const firstFile = loadedFiles[enabledFiles[0]];
          isRadionuclidesGroup = checkGroupForRadionuclides(firstFile, path);
          selectedIsRadionuclidesGroup = isRadionuclidesGroup;
        } else {
          selectedIsRadionuclidesGroup = false;
        }
        
        // Build HTML for each enabled file
        for (const fileKey of enabledFiles) {
          const file = loadedFiles[fileKey];
          
          if (!checkDatasetExistsInFile(file, path)) {
            continue;
          }
          
          const node = file.get(path);
          if (!node) continue;
          
          const isFirstFile = fileKey === enabledFiles[0];
          const fileColor = isFirstFile ? '#0066cc' : '#10b981';
          const nodeType = String(node.type);
          
          // Detect link info
          const linkInfo = getLinkInfo(file, path, node);
          
          html += `<div class="file-data-section" style="border-left-color: ${fileColor};">`;
          html += `<h4>${escapeHtml(fileKey)}</h4>`;
          
          // Handle broken soft links
          if (nodeType === 'BrokenSoftLink') {
            html += `<div class="info-section">
              <div class="info-label">Path</div>
              <div class="info-content">${escapeHtml(path)}</div>
            </div>`;
            html += `<div class="info-section">
              <div class="info-label">Type</div>
              <div class="info-content">Broken Soft Link</div>
            </div>`;
            html += `<div class="info-section link-info broken">
              <div class="info-label">üîó Link Target</div>
              <div class="info-content">${escapeHtml(node.target || '?')} <span style="color:var(--color-kvot-accent);">(target not found)</span></div>
            </div>`;
            html += '</div>';
            continue;
          }
          
          // Handle external links
          if (nodeType === 'ExternalLink') {
            html += `<div class="info-section">
              <div class="info-label">Path</div>
              <div class="info-content">${escapeHtml(path)}</div>
            </div>`;
            html += `<div class="info-section">
              <div class="info-label">Type</div>
              <div class="info-content">External Link</div>
            </div>`;
            html += `<div class="info-section link-info external">
              <div class="info-label">üîó External File</div>
              <div class="info-content">${escapeHtml(node.filename || '?')}</div>
            </div>`;
            html += `<div class="info-section link-info external">
              <div class="info-label">üîó External Path</div>
              <div class="info-content">${escapeHtml(node.obj_path || '?')}</div>
            </div>`;
            html += '</div>';
            continue;
          }
          
          // Show path, type, dtype, shape only for first file
          if (isFirstFile) {
            html += `<div class="info-section">
              <div class="info-label">Path</div>
              <div class="info-content">${escapeHtml(path)}</div>
            </div>`;
            
            html += `<div class="info-section">
              <div class="info-label">Type</div>
              <div class="info-content">${escapeHtml(nodeType)}</div>
            </div>`;
            
            // Show link info for resolved soft links
            if (linkInfo && linkInfo.type === 'soft') {
              html += `<div class="info-section link-info soft">
                <div class="info-label">üîó Soft Link</div>
                <div class="info-content">Target: ${escapeHtml(linkInfo.target)}</div>
              </div>`;
            }
            
            if (!isGroup && node.dtype) {
              const readableDtype = formatDataType(node.dtype);
              html += `<div class="info-section">
                <div class="info-label">Data Type</div>
                <div class="info-content">${escapeHtml(readableDtype)}</div>
              </div>`;
            }
            
            if (node.shape && Array.isArray(node.shape)) {
              html += `<div class="info-section">
                <div class="info-label">Shape</div>
                <div class="info-content">${node.shape.join(', ')}</div>
              </div>`;
            }
          }
          
          // Show data preview for datasets (not groups)
          if (!isGroup) {
            if (isTimeDependent(node)) {
              hasTimeDependentData = true;
            }
            
            try {
              let data;
              if (typeof node.value !== 'undefined') {
                data = node.value;
              } else if (typeof node.toArray === 'function') {
                data = node.toArray();
              }
              
              if (data !== undefined) {
                let preview;
                let itemCount;
                let fullData;
                
                if (Array.isArray(data)) {
                  preview = data.slice(0, 100);
                  itemCount = data.length;
                  fullData = data;
                } else if (data && typeof data === 'object' && data.length !== undefined) {
                  preview = Array.from(data).slice(0, 100);
                  itemCount = data.length;
                  fullData = Array.from(data);
                } else {
                  preview = [data];
                  itemCount = 1;
                  fullData = [data];
                }
                
                const isScalar = itemCount === 1;
                const downloadBtnId = `downloadData_${fileKey.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`;
                
                const previewLabel = isScalar ? 'Data Preview' : `Data Preview (first ${preview.length}/${itemCount} items)`;
                let previewText;
                if (isScalar) {
                  // Single value: show without brackets or quotes
                  let val = preview[0];
                  if (typeof val === 'bigint') val = Number(val);
                  previewText = String(val);
                } else {
                  previewText = JSON.stringify(preview, jsonReplacer, 2);
                }

                html += `<div class="info-section">
                  <div class="info-label" style="display: flex; align-items: center; justify-content: space-between;">
                    <span>${previewLabel}</span>
                    ${!isScalar ? `<button 
                      id="${downloadBtnId}" 
                      class="download-data-btn" 
                      style="padding: 4px 8px; background: var(--color-kvot-background); color: var(--color-kvot-bright); border: none; border-radius: 3px; cursor: pointer; font-size: 11px; font-weight: 500; transition: all 0.2s;"
                      onmouseover="this.style.background='var(--color-kvot-primary)'" 
                      onmouseout="this.style.background='var(--color-kvot-background)'"
                      title="Download full dataset as CSV">
                      ‚¨á Download CSV
                    </button>` : ''}
                  </div>
                  <div class="info-content">${escapeHtml(previewText)}</div>
                </div>`;
                
                // Setup download button handler
                if (!isScalar) {
                  setTimeout(() => {
                    const downloadBtn = document.getElementById(downloadBtnId);
                    if (downloadBtn) {
                      downloadBtn.addEventListener('click', () => {
                        downloadDatasetAsCSV(node, fullData, path, fileKey);
                      });
                    }
                  }, 0);
                }
              }
            } catch (e) {
              console.warn('Could not read data:', e.message);
            }
          }
          
          // Show attributes table
          const attrs = {};
          let hasAttributes = false;
          
          try {
            if (node.attrs && typeof node.attrs === 'object') {
              for (const attrName in node.attrs) {
                if (!attrName.startsWith('_') && typeof node.attrs[attrName] === 'object') {
                  try {
                    const attrObj = node.attrs[attrName];
                    let attrValue;
                    
                    if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                      attrValue = attrObj.value;
                    } else {
                      attrValue = attrObj;
                    }
                    
                    attrs[attrName] = attrValue;
                    hasAttributes = true;
                  } catch (e) {
                    attrs[attrName] = `(unreadable: ${e.message})`;
                  }
                }
              }
            }
          } catch (e) {
            console.warn('Error reading attributes:', e.message);
          }
          
          if (hasAttributes && Object.keys(attrs).length > 0) {
            html += buildAttributesTable(attrs, jsonReplacer);
          }
          
          // Collect PDF histogram data (only from the first file that has a pdf attr)
          if (!isGroup && attrs.pdf && !pdfHistogramData) {
            try {
              let pdfRaw = attrs.pdf;
              // Parse JSON string if needed
              if (typeof pdfRaw === 'string') {
                pdfRaw = JSON.parse(pdfRaw);
              }

              const isLookupTable = Array.isArray(pdfRaw);
              const indexAttr = attrs.index;

              if (isLookupTable && indexAttr) {
                // Lookup-table: array of per-index PDF specs
                const indexLabels = Array.isArray(indexAttr) ? indexAttr : Array.from(indexAttr);
                const entries = [];
                for (let i = 0; i < pdfRaw.length; i++) {
                  const spec = pdfRaw[i];
                  if (!spec) {
                    // No pdf for this index ‚Äî use the node value at that index
                    try {
                      let rawData;
                      if (typeof node.value !== 'undefined') rawData = node.value;
                      else if (typeof node.toArray === 'function') rawData = node.toArray();
                      if (rawData !== undefined) {
                        const arr = Array.isArray(rawData) ? rawData : Array.from(rawData);
                        entries.push({ label: String(indexLabels[i] ?? i), samples: [arr[i]], spec: null });
                      }
                    } catch (_) { /* skip */ }
                    continue;
                  }

                  if (spec.type && spec.type.toLowerCase() === 'raw') {
                    // Raw data: column i from the 2D dataset
                    try {
                      let rawData;
                      if (typeof node.value !== 'undefined') rawData = node.value;
                      else if (typeof node.toArray === 'function') rawData = node.toArray();
                      if (rawData !== undefined) {
                        const flat = Array.isArray(rawData) ? rawData : Array.from(rawData);
                        const nCols = pdfRaw.length;
                        const nRows = Math.floor(flat.length / nCols);
                        const shift = (spec.include_deterministic) ? 1 : 0;
                        const detVal = (spec.include_deterministic && nRows > 0) ? flat[0 * nCols + i] : null;
                        const col = [];
                        for (let r = shift; r < nRows; r++) col.push(flat[r * nCols + i]);
                        entries.push({ label: String(indexLabels[i] ?? i), samples: col, spec: spec, deterministicValue: detVal });
                      }
                    } catch (_) { /* skip */ }
                  } else {
                    // Standard distribution ‚Äî read deterministic value from node column
                    let detVal = null;
                    try {
                      let rawData;
                      if (typeof node.value !== 'undefined') rawData = node.value;
                      else if (typeof node.toArray === 'function') rawData = node.toArray();
                      if (rawData !== undefined) {
                        const flat = Array.isArray(rawData) ? rawData : Array.from(rawData);
                        const nCols = pdfRaw.length;
                        if (flat.length >= nCols) detVal = Number(flat[i]);
                      }
                    } catch (_) { /* skip */ }
                    const samples = generatePdfSamples(spec, 1000);
                    if (samples) {
                      entries.push({ label: String(indexLabels[i] ?? i), samples: Array.from(samples), spec: spec, deterministicValue: isFinite(detVal) ? detVal : null });
                    }
                  }
                }
                if (entries.length > 0) {
                  pdfHistogramData = { type: 'lookup', entries, path };
                }
              } else if (!isLookupTable && pdfRaw.type) {
                // Single PDF spec
                if (pdfRaw.type.toLowerCase() === 'raw') {
                  // Raw data from the dataset
                  try {
                    let rawData;
                    if (typeof node.value !== 'undefined') rawData = node.value;
                    else if (typeof node.toArray === 'function') rawData = node.toArray();
                    if (rawData !== undefined) {
                      const flat = Array.isArray(rawData) ? rawData : Array.from(rawData);
                      const shift = (pdfRaw.include_deterministic) ? 1 : 0;
                      const detVal = (pdfRaw.include_deterministic && flat.length > 0) ? flat[0] : null;
                      pdfHistogramData = { type: 'single', samples: flat.slice(shift), spec: pdfRaw, path, deterministicValue: detVal };
                    }
                  } catch (_) { /* skip */ }
                } else {
                  // Standard distribution ‚Äî read deterministic value from the node
                  let detVal = null;
                  try {
                    let rawData;
                    if (typeof node.value !== 'undefined') rawData = node.value;
                    else if (typeof node.toArray === 'function') rawData = node.toArray();
                    if (rawData !== undefined) {
                      if (typeof rawData === 'number') detVal = rawData;
                      else if (rawData && rawData.length !== undefined && rawData.length > 0) detVal = Number(rawData[0]);
                    }
                  } catch (_) { /* skip */ }

                  const samples = generatePdfSamples(pdfRaw, 1000);
                  if (samples) {
                    pdfHistogramData = { type: 'single', samples: Array.from(samples), spec: pdfRaw, path, deterministicValue: isFinite(detVal) ? detVal : null };
                  }
                }
              }
            } catch (e) {
              console.warn('Error parsing pdf attribute:', e.message);
            }
          }
          
          // Add Excel download button for datasets (not groups)
          if (!isGroup) {
            const escapedPath = path.replace(/'/g, "\\'");
            const escapedFileKey = fileKey.replace(/'/g, "\\'");
            html += `<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--color-border);">
              <button onclick="downloadDatasetAsExcel('${escapedPath}', '${escapedFileKey}')" 
                style="padding: 6px 12px; background: #217346; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500; transition: all 0.2s;"
                onmouseover="this.style.background='#1e6b3f'" 
                onmouseout="this.style.background='#217346'"
                title="Download this dataset to Excel">
                üìä Download Excel
              </button>
            </div>`;
          }
          
          html += '</div>';
        }
        
        infoDiv.innerHTML = html || '<div style="color:#999;">No data available for this path</div>';
        
        // Create chart if appropriate
        if (isRadionuclidesGroup) {
          currentPdfHistogram = false;
          createRadionuclidesChart(path);
        } else if (hasTimeDependentData && !isGroup) {
          currentPdfHistogram = false;
          createPlotlyChart(path);
        } else if (pdfHistogramData) {
          createPdfHistogram(pdfHistogramData);
        } else {
          currentPdfHistogram = false;
          document.getElementById('plotlyChartContainer').classList.remove('visible');
          currentChartData = null;
        }
      } catch (e) {
        infoDiv.innerHTML = `<div class="error">Error: ${escapeHtml(e.message)}</div>`;
        console.error(e);
      }
    }

    /**
     * Download dataset data as CSV file
     * @param {Object} node - HDF5 dataset node
     * @param {Array} fullData - Full data array
     * @param {string} path - Dataset path
     * @param {string} fileKey - File name
     */
    function downloadDatasetAsCSV(node, fullData, path, fileKey) {
      // Get index attribute if it exists
      let headerRow = null;
      try {
        if (node.attrs && typeof node.attrs === 'object') {
          for (const attrName in node.attrs) {
            if (attrName === 'index') {
              const attrObj = node.attrs[attrName];
              if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                const indexValue = attrObj.value;
                if (Array.isArray(indexValue)) {
                  headerRow = indexValue;
                } else if (indexValue && typeof indexValue === 'object' && indexValue.length !== undefined) {
                  headerRow = Array.from(indexValue);
                }
              }
            }
          }
        }
      } catch (e) {
        console.warn('Could not read index attribute:', e);
      }
      
      // Determine data shape and build CSV
      let csvContent = '';
      const shape = node.shape || [];
      
      if (shape.length === 1) {
        // 1D array - single column
        if (headerRow && headerRow.length === 1) {
          csvContent += escapeCSV(headerRow[0]) + '\n';
        }
        fullData.forEach(value => {
          csvContent += escapeCSV(value) + '\n';
        });
      } else if (shape.length === 2) {
        // 2D array - rows and columns
        const numRows = shape[0];
        const numCols = shape[1];
        
        if (headerRow && headerRow.length === numCols) {
          csvContent += headerRow.map(h => escapeCSV(h)).join(',') + '\n';
        }
        
        for (let i = 0; i < numRows; i++) {
          const row = [];
          for (let j = 0; j < numCols; j++) {
            row.push(escapeCSV(fullData[i * numCols + j]));
          }
          csvContent += row.join(',') + '\n';
        }
      } else if (shape.length === 0) {
        // Scalar or flat array
        if (headerRow && headerRow.length > 0) {
          csvContent += headerRow.map(h => escapeCSV(h)).join(',') + '\n';
        }
        
        if (headerRow && headerRow.length > 1) {
          const numCols = headerRow.length;
          const numRows = Math.floor(fullData.length / numCols);
          for (let i = 0; i < numRows; i++) {
            const row = [];
            for (let j = 0; j < numCols; j++) {
              row.push(escapeCSV(fullData[i * numCols + j]));
            }
            csvContent += row.join(',') + '\n';
          }
        } else {
          fullData.forEach(value => {
            csvContent += escapeCSV(value) + '\n';
          });
        }
      } else {
        // Higher dimensional - flatten to 2D
        console.warn('Multi-dimensional array, flattening to 2D');
        if (headerRow) {
          csvContent += headerRow.map(h => escapeCSV(h)).join(',') + '\n';
        }
        
        const lastDim = shape[shape.length - 1];
        const numRows = Math.floor(fullData.length / lastDim);
        
        for (let i = 0; i < numRows; i++) {
          const row = [];
          for (let j = 0; j < lastDim; j++) {
            row.push(escapeCSV(fullData[i * lastDim + j]));
          }
          csvContent += row.join(',') + '\n';
        }
      }
      
      // Create and download CSV
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const safePath = path.replace(/[^a-zA-Z0-9]/g, '_');
      const safeFileName = fileKey.replace(/\.[^/.]+$/, '');
      a.download = `${safeFileName}${safePath}_data.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /**
     * Download selected dataset information, attributes, and data as Excel file
     * Uses xlsxwrite.js library
     */
    async function downloadDatasetAsExcel(datasetPath, datasetFileKey) {
      // Use provided parameters or fall back to selected dataset
      const path = datasetPath || selectedDatasetPath;
      if (!path) {
        alert('No dataset selected');
        return;
      }
      
      const enabledFiles = getEffectiveFiles();
      if (enabledFiles.length === 0) {
        alert('No files enabled');
        return;
      }
      
      try {
        // Use specified file or first enabled file
        const fileKey = datasetFileKey || enabledFiles[0];
        const file = loadedFiles[fileKey];
        if (!file) {
          alert('File not found: ' + fileKey);
          return;
        }
        const node = file.get(path);
        
        if (!node) {
          alert('Could not access dataset');
          return;
        }
        
        const isGroup = node.type === 'Group';
        const safeFileName = fileKey.replace(/\.[^/.]+$/, '').replace(/[^a-zA-Z0-9]/g, '_');
        const safePath = path.replace(/[^a-zA-Z0-9]/g, '_');
        
        // Create workbook
        const xlsx = new XlsxWriter(`${safeFileName}${safePath}.xlsx`);
        
        // Create formats
        const headerFormat = xlsx.addFormat({
          bold: true,
          bg_color: '217346',
          font_color: 'FFFFFF',
          align: 'center',
          valign: 'vcenter',
          border: 1
        });
        
        const labelFormat = xlsx.addFormat({
          bold: true,
          bg_color: 'E2EFDA',
          border: 1
        });
        
        const valueFormat = xlsx.addFormat({
          border: 1
        });
        
        const titleFormat = xlsx.addFormat({
          bold: true,
          font_size: 14,
          font_color: '217346'
        });
        
        // ========== SHEET 1: Information ==========
        xlsx.write(0, 0, 'Dataset Information', titleFormat, 'Information');
        xlsx.write(2, 0, 'Property', headerFormat, 'Information');
        xlsx.write(2, 1, 'Value', headerFormat, 'Information');
        xlsx.setColumn(0, 0, 20, null, {}, 'Information');
        xlsx.setColumn(1, 1, 50, null, {}, 'Information');
        
        let row = 3;
        xlsx.write(row, 0, 'File', labelFormat, 'Information');
        xlsx.write(row, 1, fileKey, valueFormat, 'Information');
        row++;
        
        xlsx.write(row, 0, 'Path', labelFormat, 'Information');
        xlsx.write(row, 1, path, valueFormat, 'Information');
        row++;
        
        xlsx.write(row, 0, 'Type', labelFormat, 'Information');
        xlsx.write(row, 1, String(node.type), valueFormat, 'Information');
        row++;
        
        if (!isGroup && node.dtype) {
          xlsx.write(row, 0, 'Data Type', labelFormat, 'Information');
          xlsx.write(row, 1, formatDataType(node.dtype), valueFormat, 'Information');
          row++;
        }
        
        if (node.shape && Array.isArray(node.shape)) {
          xlsx.write(row, 0, 'Shape', labelFormat, 'Information');
          xlsx.write(row, 1, node.shape.join(' √ó '), valueFormat, 'Information');
          row++;
        }
        
        xlsx.write(row, 0, 'Export Date', labelFormat, 'Information');
        xlsx.write(row, 1, new Date().toISOString(), valueFormat, 'Information');
        
        // ========== SHEET 2: Attributes ==========
        const attrs = {};
        if (node.attrs && typeof node.attrs === 'object') {
          for (const attrName in node.attrs) {
            if (!attrName.startsWith('_') && typeof node.attrs[attrName] === 'object') {
              try {
                const attrObj = node.attrs[attrName];
                let attrValue;
                
                if (attrObj && attrObj.value !== null && typeof attrObj.value !== 'undefined') {
                  attrValue = attrObj.value;
                } else {
                  attrValue = attrObj;
                }
                
                attrs[attrName] = attrValue;
              } catch (e) {
                attrs[attrName] = `(unreadable: ${e.message})`;
              }
            }
          }
        }
        
        xlsx.write(0, 0, 'Attributes', titleFormat, 'Attributes');
        xlsx.write(2, 0, 'Name', headerFormat, 'Attributes');
        xlsx.write(2, 1, 'Value', headerFormat, 'Attributes');
        xlsx.setColumn(0, 0, 25, null, {}, 'Attributes');
        xlsx.setColumn(1, 1, 60, null, {}, 'Attributes');
        
        row = 3;
        for (const [key, value] of Object.entries(attrs)) {
          let displayValue;
          if (typeof value === 'string') {
            displayValue = value;
          } else if (Array.isArray(value)) {
            displayValue = `[${value.join(', ')}]`;
          } else if (value === null || value === undefined) {
            displayValue = String(value);
          } else if (typeof value === 'object') {
            if (value.length !== undefined) {
              displayValue = `[${Array.from(value).join(', ')}]`;
            } else {
              displayValue = JSON.stringify(value);
            }
          } else if (typeof value === 'bigint') {
            displayValue = value.toString();
          } else {
            displayValue = String(value);
          }
          
          xlsx.write(row, 0, key, labelFormat, 'Attributes');
          xlsx.write(row, 1, displayValue, valueFormat, 'Attributes');
          row++;
        }
        
        if (Object.keys(attrs).length === 0) {
          xlsx.write(3, 0, '(No attributes)', valueFormat, 'Attributes');
        }
        
        // ========== SHEET 3: Data ==========
        if (!isGroup) {
          let data;
          try {
            if (typeof node.value !== 'undefined') {
              data = node.value;
            } else if (typeof node.toArray === 'function') {
              data = node.toArray();
            }
          } catch (e) {
            console.warn('Could not read data:', e);
          }
          
          if (data !== undefined) {
            let fullData;
            if (Array.isArray(data)) {
              fullData = data;
            } else if (data && typeof data === 'object' && data.length !== undefined) {
              fullData = Array.from(data);
            } else {
              fullData = [data];
            }
            
            xlsx.write(0, 0, 'Data', titleFormat, 'Data');
            
            // Check for index attribute (column headers)
            let headerRow = null;
            try {
              if (node.attrs && node.attrs['index']) {
                const indexAttr = node.attrs['index'];
                const indexValue = indexAttr.value !== undefined ? indexAttr.value : indexAttr;
                if (Array.isArray(indexValue)) {
                  headerRow = indexValue;
                } else if (indexValue && indexValue.length !== undefined) {
                  headerRow = Array.from(indexValue);
                }
              }
            } catch (e) {
              console.warn('Could not read index attribute:', e);
            }
            
            // Try to get time data for time-series datasets
            let timeData = null;
            let timeUnit = '';
            try {
              timeData = getTimeData(file);
              timeUnit = getTimeUnit(file);
            } catch (e) {
              console.warn('Could not read time data:', e);
            }
            
            const shape = node.shape || [];
            
            if (shape.length <= 1) {
              // 1D array - single column (possibly with time column)
              const hasTimeColumn = timeData && timeData.length === fullData.length;
              const colOffset = hasTimeColumn ? 1 : 0;
              
              // Write time header if available
              if (hasTimeColumn) {
                const timeHeader = timeUnit ? `Time (${timeUnit})` : 'Time';
                xlsx.write(2, 0, timeHeader, headerFormat, 'Data');
                xlsx.setColumn(0, 0, 15, null, {}, 'Data');
              }
              
              // Write data header
              if (headerRow && headerRow.length === 1) {
                xlsx.write(2, colOffset, headerRow[0], headerFormat, 'Data');
              } else {
                xlsx.write(2, colOffset, 'Value', headerFormat, 'Data');
              }
              
              // Write data (with time if available)
              for (let i = 0; i < fullData.length; i++) {
                if (hasTimeColumn) {
                  xlsx.write(3 + i, 0, timeData[i], null, 'Data');
                }
                const val = fullData[i];
                xlsx.write(3 + i, colOffset, typeof val === 'number' ? val : String(val), null, 'Data');
              }
              
              xlsx.setColumn(colOffset, colOffset, 15, null, {}, 'Data');
              
            } else if (shape.length === 2) {
              // 2D array (possibly with time column)
              const numRows = shape[0];
              const numCols = shape[1];
              const hasTimeColumn = timeData && timeData.length === numRows;
              const colOffset = hasTimeColumn ? 1 : 0;
              
              // Write time header if available
              if (hasTimeColumn) {
                const timeHeader = timeUnit ? `Time (${timeUnit})` : 'Time';
                xlsx.write(2, 0, timeHeader, headerFormat, 'Data');
              }
              
              // Write headers
              if (headerRow && headerRow.length === numCols) {
                for (let j = 0; j < numCols; j++) {
                  xlsx.write(2, j + colOffset, String(headerRow[j]), headerFormat, 'Data');
                }
              } else {
                for (let j = 0; j < numCols; j++) {
                  xlsx.write(2, j + colOffset, `Col ${j + 1}`, headerFormat, 'Data');
                }
              }
              
              // Write data (with time if available)
              for (let i = 0; i < numRows; i++) {
                if (hasTimeColumn) {
                  xlsx.write(3 + i, 0, timeData[i], null, 'Data');
                }
                for (let j = 0; j < numCols; j++) {
                  const val = fullData[i * numCols + j];
                  xlsx.write(3 + i, j + colOffset, typeof val === 'number' ? val : String(val), null, 'Data');
                }
              }
              
              // Set column widths
              if (hasTimeColumn) {
                xlsx.setColumn(0, 0, 15, null, {}, 'Data');
              }
              for (let j = 0; j < numCols; j++) {
                xlsx.setColumn(j + colOffset, j + colOffset, 12, null, {}, 'Data');
              }
              
            } else {
              // Higher dimensional - flatten with index attribute hints (possibly with time column)
              const numCols = headerRow ? headerRow.length : (shape[shape.length - 1] || 1);
              const numRows = Math.floor(fullData.length / numCols);
              const hasTimeColumn = timeData && timeData.length === numRows;
              const colOffset = hasTimeColumn ? 1 : 0;
              
              // Write time header if available
              if (hasTimeColumn) {
                const timeHeader = timeUnit ? `Time (${timeUnit})` : 'Time';
                xlsx.write(2, 0, timeHeader, headerFormat, 'Data');
              }
              
              // Write headers
              if (headerRow) {
                for (let j = 0; j < headerRow.length; j++) {
                  xlsx.write(2, j + colOffset, String(headerRow[j]), headerFormat, 'Data');
                }
              } else {
                for (let j = 0; j < numCols; j++) {
                  xlsx.write(2, j + colOffset, `Col ${j + 1}`, headerFormat, 'Data');
                }
              }
              
              // Write data (with time if available)
              for (let i = 0; i < numRows; i++) {
                if (hasTimeColumn) {
                  xlsx.write(3 + i, 0, timeData[i], null, 'Data');
                }
                for (let j = 0; j < numCols; j++) {
                  const idx = i * numCols + j;
                  if (idx < fullData.length) {
                    const val = fullData[idx];
                    xlsx.write(3 + i, j + colOffset, typeof val === 'number' ? val : String(val), null, 'Data');
                  }
                }
              }
              
              // Set column widths
              if (hasTimeColumn) {
                xlsx.setColumn(0, 0, 15, null, {}, 'Data');
              }
              for (let j = 0; j < numCols; j++) {
                xlsx.setColumn(j + colOffset, j + colOffset, 12, null, {}, 'Data');
              }
            }
          }
        }
        
        // Save and download
        const content = await xlsx.save();
        
        // Browser download
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${safeFileName}${safePath}.xlsx`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
      } catch (e) {
        console.error('Error creating Excel file:', e);
        alert('Error creating Excel file: ' + e.message);
      }
    }

    /**
     * Build HTML table for node attributes
     * @param {Object} attrs - Attributes object
     * @param {Function} jsonReplacer - JSON replacer for BigInt etc.
     * @returns {string} HTML string for attributes section
     */
    function buildAttributesTable(attrs, jsonReplacer) {
      let attrsHtml = '<table class="attrs-table">';
      attrsHtml += '<tr class="attrs-header"><th>Name</th><th>Value</th></tr>';
      
      for (const [key, value] of Object.entries(attrs)) {
        let displayValue;
        if (typeof value === 'string') {
          displayValue = value;
        } else if (Array.isArray(value)) {
          displayValue = `[${value.join(', ')}]`;
        } else if (value === null) {
          displayValue = 'null';
        } else if (value === undefined) {
          displayValue = 'undefined';
        } else if (typeof value === 'object') {
          if (value.length !== undefined) {
            displayValue = `[${Array.from(value).slice(0, 10).join(', ')}${value.length > 10 ? '...' : ''}]`;
          } else {
            displayValue = JSON.stringify(value, jsonReplacer, 0);
          }
        } else if (typeof value === 'bigint') {
          displayValue = String(Number(value));
        } else {
          displayValue = String(value);
        }
        
        attrsHtml += `<tr class="attrs-row">
          <td><strong>${escapeHtml(key)}</strong></td>
          <td class="attrs-value">${escapeHtml(displayValue)}</td>
        </tr>`;
      }
      
      attrsHtml += '</table>';
      return `<div class="info-section">
        <div class="info-label">Attributes (${Object.keys(attrs).length})</div>
        <div class="info-content" style="padding: 0; overflow-x: auto;">${attrsHtml}</div>
      </div>`;
    }

    /**
     * Display information for multiple selected datasets.
     * Each item carries its own fileKey for cross-file comparisons.
     * @param {{path: string, fileKey: string|null}[]} items - Array of selected dataset items
     */
    function showMultipleDatasetAttributes(items) {
      const infoDiv = document.getElementById('info');
      infoDiv.innerHTML = `<div class="loading">Loading ${items.length} datasets...</div>`;
      
      if (items.length === 0) return;
      
      // Normalize: expand null fileKey (intersect mode) to all enabled files
      const normalizedItems = [];
      for (const item of items) {
        if (item.fileKey && loadedFiles[item.fileKey]) {
          normalizedItems.push(item);
        } else {
          for (const fk of getEnabledFiles()) {
            normalizedItems.push({ path: item.path, fileKey: fk });
          }
        }
      }
      
      let html = `<div style="background: var(--color-kvot-bright); padding: 12px; border-radius: 6px; margin-bottom: 16px; font-weight: 600; color: var(--color-kvot-background);">
        üìä ${normalizedItems.length} datasets selected
      </div>`;
      
      let allTimeDependent = true;
      const combinedPdfEntries = [];   // collect histogram entries across all selected datasets
      
      for (const item of normalizedItems) {
        const { path, fileKey } = item;
        const file = loadedFiles[fileKey];
        if (!file) continue;
        
        html += `<div class="file-data-section" style="border-left-color: var(--color-kvot-accent);">`;
        html += `<h4>${escapeHtml(path)} <span style="font-weight:400;font-size:11px;color:#888;">(${escapeHtml(fileKey)})</span></h4>`;
        
        try {
          const dataset = file.get(path);
          if (!dataset) continue;
          
          const isTimeDep = isTimeDependent(dataset);
          if (!isTimeDep) allTimeDependent = false;
          
          html += `<div class="info-section">
            <div class="info-label">Type</div>
            <div class="info-content">${escapeHtml(String(dataset.type))} ${isTimeDep ? '‚è±Ô∏è (time-dependent)' : ''}</div>
          </div>`;
          
          if (dataset.dtype) {
            const readableDtype = formatDataType(dataset.dtype);
            html += `<div class="info-section">
              <div class="info-label">Data Type</div>
              <div class="info-content">${escapeHtml(readableDtype)}</div>
            </div>`;
          }
          
          if (dataset.shape && Array.isArray(dataset.shape)) {
            html += `<div class="info-section">
              <div class="info-label">Shape</div>
              <div class="info-content">${dataset.shape.join(', ')}</div>
            </div>`;
          }
          
          // Show key attributes
          const attrs = {};
          if (dataset.attrs && typeof dataset.attrs === 'object') {
            for (const attrName in dataset.attrs) {
              if (!attrName.startsWith('_') && typeof dataset.attrs[attrName] === 'object') {
                const attrObj = dataset.attrs[attrName];
                attrs[attrName] = attrObj?.value ?? attrObj;
              }
            }
          }
          
          if (Object.keys(attrs).length > 0) {
            html += `<div class="info-section">
              <div class="info-label">Key Attributes</div>
              <div class="info-content" style="font-size: 11px;">`;
            
            for (const [key, value] of Object.entries(attrs).slice(0, 5)) {
              let displayValue = String(value);
              if (displayValue.length > 50) {
                displayValue = displayValue.substring(0, 50) + '...';
              }
              html += `<strong>${escapeHtml(key)}:</strong> ${escapeHtml(displayValue)}<br>`;
            }
            
            html += `</div></div>`;
          }
          
          // Collect PDF histogram entries for combined chart
          try {
            if (attrs.pdf) {
              const datasetName = path.split('/').pop();
              const shortFile = normalizedItems.length > 1 && new Set(normalizedItems.map(d => d.fileKey)).size > 1
                ? ' (' + fileKey + ')' : '';
              const entryLabel = datasetName + shortFile;
              const pdfEntries = collectPdfEntries(dataset, attrs, entryLabel);
              if (pdfEntries) combinedPdfEntries.push(...pdfEntries);
            }
          } catch (_) {}

          // Add Excel download button for this dataset
          const escapedPath = path.replace(/'/g, "\\'");
          const escapedFileKey = fileKey.replace(/'/g, "\\'");
          html += `<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--color-border);">
            <button onclick="downloadDatasetAsExcel('${escapedPath}', '${escapedFileKey}')" 
              style="padding: 6px 12px; background: #217346; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500; transition: all 0.2s;"
              onmouseover="this.style.background='#1e6b3f'" 
              onmouseout="this.style.background='#217346'"
              title="Download this dataset to Excel">
              üìä Download Excel
            </button>
          </div>`;
          
        } catch (e) {
          html += `<div class="error">Error loading dataset: ${escapeHtml(e.message)}</div>`;
        }
        
        html += `</div>`;
      }
      
      infoDiv.innerHTML = html;
      
      // Create combined chart
      if (allTimeDependent && normalizedItems.length > 0) {
        createMultiDatasetChart(normalizedItems);
      } else if (combinedPdfEntries.length > 0) {
        // Show combined PDF histogram for all selected datasets
        createPdfHistogram({ type: 'lookup', entries: combinedPdfEntries, path: 'Multi-selection' });
      } else {
        document.getElementById('plotlyChartContainer').classList.remove('visible');
        currentChartData = null;
      }
    }


    /* ==========================================================================
       12. SEARCH FUNCTIONALITY
       ========================================================================== */

    /**
     * Convert wildcard pattern to regular expression
     * @param {string} pattern - Wildcard pattern (supports *)
     * @returns {RegExp} Compiled regular expression
     */
    function wildcardToRegex(pattern) {
      const escaped = pattern.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
      const regexPattern = escaped.replace(/\*/g, '.*');
      return new RegExp(regexPattern, 'i');
    }

    /**
     * Highlight matching text in a string
     * @param {string} text - Original text
     * @param {string} searchTerm - Search term to highlight
     * @returns {string} HTML with highlighted matches
     */
    function highlightText(text, searchTerm) {
      if (!searchTerm) return escapeHtml(text);
      
      const regex = wildcardToRegex(searchTerm);
      const match = text.match(regex);
      
      if (!match) return escapeHtml(text);
      
      const matchStart = match.index;
      const matchEnd = matchStart + match[0].length;
      
      const before = escapeHtml(text.substring(0, matchStart));
      const matched = escapeHtml(text.substring(matchStart, matchEnd));
      const after = escapeHtml(text.substring(matchEnd));
      
      return `${before}<span class="search-highlight">${matched}</span>${after}`;
    }

    /**
     * Filter tree view based on search term
     * Shows matching items and their parents, hides non-matching items
     * @param {string} searchTerm - Search term (supports wildcards)
     */
    function filterTree(searchTerm) {
      currentSearchTerm = searchTerm;
      const tree = document.getElementById('tree');
      const allItems = tree.querySelectorAll('.tree-item');
      const allChildren = tree.querySelectorAll('.tree-group-children');
      
      // Clear search - show everything, remove highlights
      if (!searchTerm.trim()) {
        allItems.forEach(item => {
          item.classList.remove('search-hidden', 'search-match');
          const label = item.querySelector('.tree-label');
          if (label) {
            const originalText = label.textContent;
            label.innerHTML = escapeHtml(originalText);
          }
        });
        
        allChildren.forEach(child => {
          child.classList.remove('search-expanded');
          const parentGroup = child.previousElementSibling;
          if (parentGroup && parentGroup.classList.contains('expanded')) {
            child.classList.add('expanded');
          } else {
            child.classList.remove('expanded');
          }
        });
        
        return;
      }
      
      const regex = wildcardToRegex(searchTerm);
      const matchingItems = new Set();
      const itemsToShow = new Set();
      
      // First pass: find all matching items
      allItems.forEach(item => {
        const label = item.querySelector('.tree-label');
        if (!label) return;
        
        const text = label.textContent;
        const matches = regex.test(text);
        
        if (matches) {
          matchingItems.add(item);
          item.classList.add('search-match');
          label.innerHTML = highlightText(text, searchTerm);
        } else {
          item.classList.remove('search-match');
          label.innerHTML = escapeHtml(text);
        }
      });
      
      // Second pass: build set of items to show (matches + their parents)
      matchingItems.forEach(item => {
        itemsToShow.add(item);
        
        let current = item;
        while (current) {
          const parentChildren = current.closest('.tree-group-children');
          if (parentChildren) {
            const parentGroup = parentChildren.previousElementSibling;
            if (parentGroup && parentGroup.classList.contains('tree-item')) {
              itemsToShow.add(parentGroup);
              current = parentGroup;
            } else {
              break;
            }
          } else {
            break;
          }
        }
      });
      
      // Third pass: hide non-matching items, show matching items and parents
      allItems.forEach(item => {
        if (itemsToShow.has(item)) {
          item.classList.remove('search-hidden');
        } else {
          item.classList.add('search-hidden');
        }
      });
      
      // Fourth pass: expand parent groups of matches
      allChildren.forEach(child => {
        const parentGroup = child.previousElementSibling;
        if (parentGroup && itemsToShow.has(parentGroup)) {
          child.classList.add('search-expanded');
          if (parentGroup) {
            const toggle = parentGroup.querySelector('.tree-toggle');
            if (toggle) {
              toggle.classList.remove('collapsed');
            }
            parentGroup.classList.add('expanded');
          }
        } else if (!child.classList.contains('expanded')) {
          child.classList.remove('search-expanded');
        }
      });
    }


    /* ==========================================================================
       13. DRAG & DROP FILE LOADING
       ========================================================================== */

    /**
     * Prevent default browser behavior for drag events.
     * Required to enable custom drop handling for HDF5 files.
     * 
     * @param {Event} e - Drag event to prevent
     * @returns {void}
     */
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    /*
     * Drag & Drop Event Registration
     * 
     * Uses a dragCounter to track nested drag enter/leave events,
     * ensuring the overlay is only hidden when the drag truly leaves
     * the document (not just moving between child elements).
     */
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    document.body.addEventListener('dragenter', (e) => {
      dragCounter++;
      document.getElementById('dropOverlay').classList.add('active');
    });

    document.body.addEventListener('dragleave', (e) => {
      dragCounter--;
      if (dragCounter === 0) {
        document.getElementById('dropOverlay').classList.remove('active');
      }
    });

    document.body.addEventListener('drop', (e) => {
      dragCounter = 0;
      document.getElementById('dropOverlay').classList.remove('active');
      
      const dt = e.dataTransfer;
      const files = dt.files;
      if (files.length > 0) {
        document.getElementById('fileInput').files = files;
        const event = new Event('change', { bubbles: true });
        document.getElementById('fileInput').dispatchEvent(event);
      }
    });


    /* ==========================================================================
       14. CLIPBOARD & EXPORT
       ========================================================================== */
    
    /**
     * Copy the current chart to clipboard as a PNG image.
     * Uses the Clipboard API with ClipboardItem for image data.
     * Falls back to file download if clipboard access is denied or unavailable.
     * 
     * The exported image is rendered at 2x scale (1200x800 at scale 2)
     * for high-quality output suitable for documents and presentations.
     * 
     * @returns {Promise<void>}
     */
    async function copyChartToClipboard() {
      if (!currentChartData) {
        alert('No chart available to copy');
        return;
      }
      
      const plotDiv = document.getElementById('plotlyChart');
      const btn = event.target;
      const originalText = btn.textContent;
      
      try {
        // Check clipboard API availability
        if (!navigator.clipboard || !navigator.clipboard.write) {
          throw new Error('Clipboard API not supported');
        }
        
        // Try to request permission if needed
        try {
          const permissionStatus = await navigator.permissions.query({ name: 'clipboard-write' });
          if (permissionStatus.state === 'denied') {
            throw new Error('Clipboard permission denied');
          }
        } catch (permErr) {
          console.log('Permission query not supported, attempting clipboard write anyway');
        }
        
        // Convert chart to PNG
        const dataUrl = await Plotly.toImage(plotDiv, {
          format: 'png',
          width: 1200,
          height: 800,
          scale: 2
        });
        
        const blob = await fetch(dataUrl).then(r => r.blob());
        
        // Write to clipboard
        await navigator.clipboard.write([
          new ClipboardItem({
            'image/png': blob
          })
        ]);
        
        // Show success feedback
        btn.textContent = '‚úì Copied!';
        btn.style.background = 'var(--color-kvot-accent)';
        
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.background = '';
        }, 2000);
        
      } catch (err) {
        console.error('Clipboard copy failed:', err);
        
        // Fallback to download
        try {
          const dataUrl = await Plotly.toImage(plotDiv, {
            format: 'png',
            width: 1200,
            height: 800,
            scale: 2
          });
          
          const link = document.createElement('a');
          link.href = dataUrl;
          link.download = `chart_${Date.now()}.png`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          // Show download feedback
          btn.textContent = '‚¨á Downloaded';
          btn.style.background = 'var(--color-kvot-accent)';
          
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
          }, 2000);
          
          if (err.message.includes('denied') || err.message.includes('permission')) {
            alert('Clipboard access was denied. The chart has been downloaded instead.');
          }
        } catch (downloadErr) {
          console.error('Download also failed:', downloadErr);
          alert('Failed to copy or download chart: ' + downloadErr.message);
        }
      }
    }


    /* ==========================================================================
       15. EVENT LISTENERS & INITIALIZATION
       ========================================================================== */
    
    /*
     * Application Initialization
     * 
     * The following code runs immediately when the script loads:
     * 1. Initialize DOM element cache for performance
     * 2. Register event handlers for file input, search, resize, etc.
     * 3. Set up keyboard shortcuts and accessibility features
     */
    
    // Initialize cached DOM element references
    initDOMReferences();
    
    /**
     * File input change handler.
     * Processes selected HDF5 files, loads them via h5wasm,
     * and adds them to the file tabs for viewing.
     * 
     * @listens change
     */
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const files = Array.from(e.target.files || []);
      if (files.length === 0) return;
      
      try {
        await waitForH5Wasm();
        
        for (const file of files) {
          try {
            const buffer = await file.arrayBuffer();
            
            const { FS, File } = window.h5wasm;
            if (!FS || !File) throw new Error('h5wasm not ready');
            
            const filename = `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.h5`;
            const data = new Uint8Array(buffer);
            
            FS.writeFile('/' + filename, data);
            const hf = new File('/' + filename, 'r');
            
            loadedFiles[file.name] = hf;
            fileStates[file.name] = true;
            if (!fileOrder.includes(file.name)) {
              fileOrder.push(file.name);
            }
          } catch (err) {
            console.error(`Error loading ${file.name}:`, err);
            alert(`Failed to load ${file.name}`);
          }
        }
        
        updateTabs();
        await refreshTreeStructure();
      } catch (err) {
        alert(`Error: ${err.message}`);
        console.error(err);
      }
      
      e.target.value = '';
    });

    /**
     * Search input handler with 200ms debouncing.
     * Filters the tree view to show only matching items.
     * Shows/hides the clear button based on input state.
     * 
     * @listens input
     */
    document.getElementById('treeSearch').addEventListener('input', (e) => {
      const searchTerm = e.target.value;
      const clearBtn = document.getElementById('clearSearch');
      
      if (searchTerm) {
        clearBtn.classList.add('visible');
      } else {
        clearBtn.classList.remove('visible');
      }
      
      // Debounce the search
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }
      
      searchTimeout = setTimeout(() => {
        filterTree(searchTerm);
      }, 200);
    });

    /**
     * Clear search button handler.
     * Resets search input, removes filter, and refocuses the input.
     * 
     * @listens click
     */
    document.getElementById('clearSearch').addEventListener('click', () => {
      const searchInput = document.getElementById('treeSearch');
      searchInput.value = '';
      document.getElementById('clearSearch').classList.remove('visible');
      filterTree('');
      searchInput.focus();
    });

    /**
     * Keyboard shortcut: Escape key clears the search input.
     * Provides quick way to reset the tree filter.
     * 
     * @listens keydown
     */
    document.getElementById('treeSearch').addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.getElementById('clearSearch').click();
      }
    });

    /**
    /**
     * Decorator: Re-apply search filter after tree structure refresh.
     * Ensures that if the user has an active search term, it persists
     * when the tree is rebuilt (e.g., after file reordering).
     */
    const originalRefreshTreeStructure = refreshTreeStructure;
    refreshTreeStructure = async function() {
      await originalRefreshTreeStructure();
      const searchTerm = document.getElementById('treeSearch').value;
      if (searchTerm) {
        setTimeout(() => filterTree(searchTerm), 50);
      }
    };

    /**
     * Responsive chart resizing using ResizeObserver.
     * Automatically resizes the Plotly chart when its container changes size.
     * Debounced to 100ms to prevent excessive resize operations.
     */
    const plotlyChart = document.getElementById('plotlyChart');
    let resizeTimeout;
    const resizeObserver = new ResizeObserver(entries => {
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = setTimeout(() => {
        for (const entry of entries) {
          if (entry.target === plotlyChart && plotlyChart.data) {
            Plotly.Plots.resize(plotlyChart);
          }
        }
      }, 100);
    });
    
    if (plotlyChart) {
      resizeObserver.observe(plotlyChart);
    }
  </script>

  <script>
    // Panel resize handle
    (function() {
      const handle = document.getElementById('resizeHandle');
      const leftPanel = document.getElementById('leftPanel');
      const container = leftPanel.parentElement;
      let startX, startWidth;

      handle.addEventListener('mousedown', function(e) {
        e.preventDefault();
        e.stopPropagation();
        startX = e.clientX;
        startWidth = leftPanel.getBoundingClientRect().width;
        handle.classList.add('active');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        // Block pointer events on everything else during drag
        container.style.pointerEvents = 'none';
        handle.style.pointerEvents = 'auto';

        function onMouseMove(e) {
          e.preventDefault();
          const dx = e.clientX - startX;
          const maxW = container.getBoundingClientRect().width * 0.6;
          const newWidth = Math.max(150, Math.min(startWidth + dx, maxW));
          leftPanel.style.flex = '0 0 ' + newWidth + 'px';
        }

        function onMouseUp() {
          handle.classList.remove('active');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          container.style.pointerEvents = '';
          handle.style.pointerEvents = '';
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          window.dispatchEvent(new Event('resize'));
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
    })();
  </script>
</body>
</html>