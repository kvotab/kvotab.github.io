<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
  <script src="https://code.jquery.com/jquery-3.6.0.js"></script>
  <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
  <link href="https://unpkg.com/leaflet@1.9.2/dist/leaflet.css" rel="stylesheet">
  <script src="https://unpkg.com/leaflet@1.9.2/dist/leaflet.js"></script>
  <link rel="stylesheet" href="./resources/css/kvot.css">  
  <link rel="icon" type="image/x-icon" href="./resources/images/favicon.ico">
  <style>
    /* combined-tabs UI styles */
    /* hide original jQuery tab headers and only the template content (templates used programmatically) */
    /* templates live under #tabs only (single source of truth) */
    #tabs > ul, /* only hide template panels whose ids start with tabs- */
    #tabs > div[id^="tabs-"] { display: none !important; }
    /* header appearance */
    #tabs-header li { display:inline-block; }
    #tabs-header a { display:inline-block; padding:4px 8px; border-radius:4px; cursor:pointer; text-decoration:none; color:var(--text-primary); border:1px solid transparent; transition:background .15s, color .15s, opacity .15s; }
    #tabs-header a.selected { background:#f3b87b; color:#fff; border-color:#f3b87b; }
    /* disabled state for second-tab choices (visual only; click still handled in JS) */
    #tabs-header a.disabled { opacity:0.45; cursor: not-allowed; }
    /* flash when a disabled header is clicked */
    #tabs-header a.disabled-flash { box-shadow: inset 0 0 0 2px rgba(255,0,0,0.10); }

    /* ensure combined header and metric panels stay visible above the equations table */
    #combined-tabs-header, #metric-panels { position: relative; z-index: 5; }

    /* two-column layout: left = controls, right = equations; responsive stack on small screens */
    #logn .logn-columns { display:flex; gap:18px; align-items:flex-start; }
    #logn .logn-left { flex:1; min-width:0; }

    /* equations: slightly larger, more readable spacing for MathJax and table cells */
    #equations-details .equations-body { position: relative; z-index: 6; background: transparent; padding: 10px 0 6px; font-size: 0.96rem; line-height: 1.45; color: #222; }
    #equations-details .equations-body table td { padding: 6px 10px; vertical-align: middle; }
    /* boost MathJax size slightly so inline formulas align visually with surrounding text */
    #equations-details .equations-body .mjx-chtml { font-size: 1.02rem; }
    @media (max-width: 920px) { #logn .logn-columns { flex-direction: column; } #equations-details { width: auto; } }

    /* chart inside computed results: stack cleanly under the textual output and contain overflow */
    #detailsContainer { display: flex; flex-direction: column; gap: 12px; align-items: stretch; }
    #detailsContainer #ln-output { position: static; z-index: auto; width: 100%; box-sizing: border-box; }
    #detailsContainer #chart { position: static; z-index: auto; min-height:220px; max-height:420px; width:100%; box-sizing:border-box; background: #fff; padding:6px; margin:0; margin-bottom:20px; border-radius:6px; border:1px solid #e6e6e6; box-shadow: 0 1px 4px rgba(0,0,0,0.03); overflow: hidden; }
    /* ensure Plotly canvas never exceeds its container */
    #detailsContainer #chart .plotly, #detailsContainer #chart .js-plotly-plot { width: 100% !important; max-width: 100% !important; box-sizing: border-box !important; }
    #detailsContainer #chart .plotly { height:100% !important; }

    /* make equations visually separated from the computed results */
    #equations-details { width: 100%; max-width: none; margin-top: 18px; border-top: 1px solid #e6e6e6; padding-top: 12px; }
    #equations-details summary.equations-summary { margin-top: 6px; }

    /* unified summary style for Computed results + Equations */
    .equations-summary { cursor: pointer; padding: 6px 8px; background: transparent; border-radius: 4px; font-weight: normal; margin-bottom:6px; }
    .equations-summary::marker { display:none; }
    /* remove right-positioned custom arrow so both summaries match */
    .equations-summary::after { content: ''; }

    /* small visual spacing for metric panels */
    #metric-panels { margin-bottom: 8px; }

    /* animation for templates when moved into a metric panel */
    .attach-anim { animation: popIn .22s ease-out; }
    @keyframes popIn { from { opacity: 0; transform: translateY(6px) scale(0.995); } to { opacity: 1; transform: translateY(0) scale(1); } }

    .metric-panel h4 { font-size:0.95rem; margin:0 0 8px; }
    #metric-note { font-size:0.88rem; color:#666; margin-top:4px; }
    #metric-info { display:none; margin-top:6px; color:#a65a00; background:#fff6e6; padding:6px 8px; border-radius:4px; border:1px solid #f0d6b0; font-size:0.9rem; }
    #metric-info.show { display:block; animation: fadeIn .22s ease-out; }
    @keyframes fadeIn { from { opacity:0; transform: translateY(-4px); } to { opacity:1; transform: translateY(0); } }
    /* focus outline for keyboard navigation */
    #tabs-header a:focus { outline: 2px solid rgba(243,184,123,0.45); box-shadow: 0 0 0 3px rgba(243,184,123,0.08); }

    /* form control styling — unified, roomy inputs */
    .metric-content .arg { width: 100%; padding: 8px 10px; border: 1px solid #e6e6e6; border-radius: 6px; font-size: 0.95rem; color: #222; background: #fff; box-sizing: border-box; transition: box-shadow .12s, border-color .12s; }
    .metric-content .arg:focus { outline: none; box-shadow: 0 0 0 3px rgba(243,184,123,0.08); border-color: #f3b87b; }
    .metric-content textarea.arg { min-height: 140px; resize: vertical; font-family: inherit; }
    /* make computed results easier to scan */
    #ln-output { font-size: 0.95rem; line-height: 1.45; font-family: Menlo, Monaco, 'Courier New', monospace; color: #222; }

    /* keep percentile p/x side-by-side */
    #tabs-1-percentile .arg { display: inline-block; width: 48%; vertical-align: middle; }
    #tabs-1-percentile .arg + .arg { margin-left: 4%; }

    /* data textarea visual hint (monospace for lists) */
    #tabs-1-data .arg { font-family: Menlo, Monaco, 'Courier New', monospace; white-space: pre-wrap; }

    /* reduce number spinner chrome for modern browsers */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type="number"] { -moz-appearance: textfield; appearance: textfield; }

    /* small toggle for ln(x) view */
    .chart-toggle input[type="checkbox"] { width: 16px; height: 16px; }

    /* segmented control for PDF/CDF (roomier + stronger active state) */
    .segmented { display:inline-flex; border-radius:6px; overflow:hidden; border:1px solid #e6e6e6; background:#fff; box-shadow: inset 0 -1px 0 rgba(0,0,0,0.02); }
    .segmented button { appearance:none; -webkit-appearance:none; border:0; background:transparent; padding:8px 14px; margin:0; cursor:pointer; color:#444; font-size:0.92rem; line-height:1; transition: background .12s, color .12s, box-shadow .12s; }
    .segmented button.active { background:#f3b87b; color:#fff; font-weight:600; box-shadow: inset 0 -3px 0 rgba(0,0,0,0.06); }
    .segmented button:focus { outline: 2px solid rgba(243,184,123,0.25); box-shadow: 0 0 0 3px rgba(243,184,123,0.06); }

    /* DOM-based chart legend (keeps Plotly layout unchanged) */
    .chart-legend { display:flex; gap:14px; align-items:center; font-size:0.9rem; color:#555; margin:8px 0 4px 0; }
    .chart-legend .legend-item { display:inline-flex; gap:8px; align-items:center; }
    .chart-legend .swatch { width:12px; height:10px; border-radius:2px; display:inline-block; box-shadow: inset 0 -1px 0 rgba(0,0,0,0.06); border:1px solid rgba(0,0,0,0.04); }
    .chart-legend .swatch.swatch-empirical { background: rgba(96,96,96,0.6); }
    .chart-legend .swatch.swatch-theoretical { background: #f3b87b; }
  </style>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.14.0.min.js"></script>
  <script src="./resources/js/erf.js"></script>
  <title>kvot ab - lognormal conversions</title>
</head>
<body>
  <header></header>
  <div class="content">
    <div id="logn">
      <div class="logn-columns">
        <div class="logn-left">
      <table cellpadding="0px" border="0" style="table-layout: fixed;width:100%">
        <tr><td>
          <div id="tabs">
            <!-- Combined header (single header controls up to two selectable tabs; click toggles selection) -->
            <div id="combined-tabs-header" style="margin-bottom:8px;">
              <ul id="tabs-header" role="tablist" aria-label="Metric selector" style="list-style:none;padding:0;margin:0;display:flex;gap:8px;flex-wrap:wrap;">
                <li><a href="#" data-id="mu">mean(log)</a></li>
                <li><a href="#" data-id="mean">mean</a></li>
                <li><a href="#" data-id="GM">gm</a></li>
                <li><a href="#" data-id="mode">mode</a></li>
                <li><a href="#" data-id="percentile">percentile</a></li>
                <li><a href="#" data-id="data">data</a></li>
                <li><a href="#" data-id="sigma">mean(sd)</a></li>
                <li><a href="#" data-id="SD">sd</a></li>
                <li><a href="#" data-id="GSD">gsd</a></li>
                <li><a href="#" data-id="CV">CV</a></li>
                <li><a href="#" data-id="error">error factor</a></li>
              </ul>
              <div id="metric-note" style="margin-top:6px;font-size:0.88rem;color:#666;">Select up to <strong>two</strong> metrics. Click a selected metric to deselect it.</div>
              <div id="metric-info" role="status" aria-live="polite" style="display:none;margin-top:6px;color:#a65a00;background:#fff6e6;padding:6px 8px;border-radius:4px;border:1px solid #f0d6b0;font-size:0.9rem;"></div>
            </div>
            <!-- metric panels (primary / secondary) -->
            <div id="metric-panels" style="display:flex;gap:12px;margin-top:6px;align-items:flex-start;">
              <div class="metric-panel" id="metric1-panel" role="region" aria-labelledby="metric1-title" style="flex:1;min-width:220px;border:1px solid #eee;padding:8px;border-radius:4px;background:#fff;">
                <h4 id="metric1-title" style="margin:6px 0;"><span>Primary metric</span></h4>
                <div id="metric1-content" class="metric-content" style="min-height:120px;color:#666;padding:6px;border-radius:4px;">No metric selected.</div>
              </div>
              <div class="metric-panel" id="metric2-panel" role="region" aria-labelledby="metric2-title" style="flex:1;min-width:220px;border:1px solid #eee;padding:8px;border-radius:4px;background:#fff;">
                <h4 id="metric2-title" style="margin:6px 0;display:flex;align-items:center;justify-content:space-between;"><span>Secondary metric (optional)</span></h4>
                <div id="metric2-content" class="metric-content" style="min-height:120px;color:#666;padding:6px;border-radius:4px;">No metric selected.</div>
              </div>
            </div>

            <details id="computed-details" open>
              <summary class="equations-summary">Computed results</summary>
              <div class="computed-body">
                <div id="logn-output" style="margin:8px 0 0 0; border-top:1px solid #e6e6e6; padding-top:12px;">
                  <span style="display:inline-flex;align-items:center;gap:8px;margin-right:12px;color:#555;">Select one or two tabs above to choose metric(s)</span>
                  <button id="showDetailsBtn" style="padding:6px 10px;margin-right:8px;">Show details</button>
                  <button id="previewDetailsBtn" style="padding:6px 10px;margin-right:8px;">Preview</button>
                  <button id="copyDetailsBtn" style="padding:6px 10px;margin-right:8px;">Copy</button>
                  <button id="printDetailsBtn" style="padding:6px 10px;margin-right:8px;">Print</button>

                  <label class="chart-toggle" style="margin-left:6px;display:inline-flex;align-items:center;gap:8px;font-size:0.92rem;color:#555;"><input id="lnViewToggle" type="checkbox"> Show ln(x) view</label>
                  <label style="margin-left:10px;font-size:0.92rem;color:#555;display:inline-flex;align-items:center;gap:6px;">View:
                    <div id="chartMode" class="segmented" role="tablist" aria-label="Chart mode">
                      <button type="button" data-mode="pdf" aria-pressed="true" class="active" data-chart-mode>PDF</button>
                      <button type="button" data-mode="cdf" aria-pressed="false" data-chart-mode>CDF</button>
                    </div>
                  </label>

                  <div id="detailsContainer" style="margin-top:12px;display:block;">
                    <pre id="ln-output" style="white-space:pre-wrap;background:#f7f7f8;border:1px solid #e1e1e1;padding:12px;border-radius:4px;min-height:120px;">No distribution computed yet.</pre>
                    <div id="chart" aria-label="Lognormal density chart" style="min-height:220px;"></div>
                  </div>
                </div>
              </div>
            </details>

            <!-- Equations & formulas (full-width) -->
            <details id="equations-details" class="kvot-collapsible" aria-expanded="true">
              <summary class="equations-summary">Equations & formulas</summary>
              <div class="equations-body">
                <table cellpadding="0px" border="0" style="table-layout: fixed;width:100%">
                  <tr>
                    <td colspan="2">Mean of it's natural logarithm (\(\mu\))</td>
                    <td>Standard deviation of it's natural logarithm (\(\sigma\))</td>
                  </tr>
                  <tr><td colspan="2"></td><td></td></tr>
                  <tr>
                    <td colspan="2">Geometric mean (\(\mu_g\))</td>
                    <td>Geometric standard deviation (\(\sigma_g\))</td>
                  </tr>
                  <tr><td colspan="2"></td><td></td></tr>
                  <tr>
                    <td colspan="2">Arithmetic mean (\(\mu_a\))</td>
                    <td>Arithmetic standard deviation (\(\sigma_a\))</td>
                  </tr>
                  <tr><td colspan="2"></td><td></td></tr>
                  <tr>
                    <td colspan="2">Percentile (\(p_1\)) Corresponding value (\(x_1\))</td>
                    <td>Percentile (\(p_2\)) Corresponding value (\(x_2\))</td>
                  </tr>
                  <tr><td colspan="2"></td><td></td></tr>
                  <tr><td style="text-align:right;">\(\mu=\)</td><td colspan="2">\(\ln{\mu_g}\)</td></tr>
                  <tr><td style="text-align:right;">\(=\)</td><td colspan="2">\(\ln{(\mu_a^2/\sqrt{\mu_a^2+\sigma_a^2})}\)</td></tr>
                  <tr><td style="text-align:right;">\(\sigma=\)</td><td colspan="2">\(\ln{\sigma_g}\)</td></tr>
                  <tr><td style="text-align:right;">\(=\)</td><td colspan="2">\(\sqrt{\ln{(1+\sigma_a^2/\mu_a^2)}}\)</td></tr>
                  <tr><td style="text-align:right;">\(\mu_g=\)</td><td colspan="2">\(e^{\mu}\)</td></tr>
                  <tr><td style="text-align:right;">\(=\)</td><td colspan="2">\(e^{\ln{\mu_a}-\ln{(1+\sigma_a^2/\mu_a^2)}/2}\)</td></tr>
                  <tr><td style="text-align:right;">\(\sigma_g=\)</td><td colspan="2">\(e^{\sigma}\)</td></tr>
                  <tr><td style="text-align:right;">\(=\)</td><td colspan="2">\(e^{\sqrt{\ln{(1+\sigma_a^2/\mu_a^2)}}}\)</td></tr>
                  <tr><td style="text-align:right;">\(\mu_a=\)</td><td colspan="2">\(e^{\mu+\sigma^2/2}\)</td></tr>
                  <tr><td style="text-align:right;">\(=\)</td><td colspan="2">\(e^{\ln{\mu_g}+{\ln{\sigma_g}}^2/2}\)</td></tr>
                  <tr><td style="text-align:right;">\(\sigma_a=\)</td><td colspan="2">\(\sqrt{(e^{{\sigma}^2}-1)e^{2\mu+{\sigma}^2}}\)</td></tr>
                  <tr><td style="text-align:right;">\(=\)</td><td colspan="2">\(e^{\mu+\sigma^2/2}(e^{\sigma^2}-1)\)</td></tr>
                  <tr><td style="text-align:right;">\(=\)</td><td colspan="2">\(\sqrt{(e^{{\ln{\sigma_g}}^2}-1)e^{2\ln{\mu_g}+{\ln{\sigma_g}}^2}}\)</td></tr>
                  <tr><td style="text-align:right;">\(=\)</td><td colspan="2">\(CV\mu_a\)</td></tr>
                  <tr><td style="text-align:right;">\(=\)</td><td colspan="2">\(\mu_a\sqrt{e^{\sigma^2}-1}\)</td></tr>
                  <tr><td style="text-align:right;">\(mode=\)</td><td colspan="2">\(e^{\mu-\sigma^2}\)</td></tr>
                  <tr><td style="text-align:right;">\(=\)</td><td colspan="2">\(\mu_ge^{-\sigma^2}\)</td></tr>
                  <tr><td style="text-align:right;">\(CV=\)</td><td colspan="2">\(\sqrt{e^{\sigma^2}-1}\)</td></tr>
                  <tr><td style="text-align:right;">\(=\)</td><td colspan="2">\(\sigma_a/\mu_a\)</td></tr>
                  <tr><td style="text-align:right;">\(skewness=\)</td><td colspan="2">\(CV^3+3CV\)</td></tr>
                  <tr><td style="text-align:right;">\(kurtosis=\)</td><td colspan="2">\(CV^8+6CV^6+15CV^4+16CV^2\)</td></tr>
                  <tr><td style="text-align:right;">\(kurtosis=\)</td><td colspan="2">\(e^{j\mu+j^2\sigma^2/2}\)</td></tr>
                  <tr><td style="text-align:right;">\(entropy=\)</td><td colspan="2">\({(1+\ln{(2\pi\sigma^2)})}/2+\mu\)</td></tr>
                </table>
              </div>
            </details>



            <div id="tabs-mu">
              <p>mu, \(\mu\) [-∞,+∞], is the expected value (or mean) of the variable's natural logarithm</p>
              <p><input class="arg" data-field="mu" type="number" step="any" inputmode="decimal" value="0" name="Mean of it's natural logarithm" title="Please provide the mean of it's natural logarithm."></p>
            </div>
            <div id="tabs-mean">
              <p>mean > 0 is the expected value (or mean) of the variable</p>
              <p><input class="arg" data-field="mean" type="number" min="0" step="any" inputmode="decimal" value="1" name="Arithmetic mean" title="Please provide the arithmetic mean (positive)."></p>
            </div>
            <div id="tabs-GM">
              <p>geometric mean > 0 is the the same as the median value</p>
              <p><input class="arg" data-field="GM" type="number" min="0" step="any" inputmode="decimal" value="1" name="Geometric mean" title="Please provide the geometric mean (positive)."></p>
            </div>
            <div id="tabs-mode">
              <p>mode > 0 is the most likely value of the variable</p>
              <p><input class="arg" data-field="mode" type="number" min="0" step="any" inputmode="decimal" value="1" name="Mode" title="Please provide the mode (positive)."></p>
            </div>
            <div id="tabs-percentile">
              <p><input class="arg" data-field="p" type="number" min="0" max="100" step="any" inputmode="decimal" value="5" name="Percentile" title="Please provide a percentile (0–100).">
                <input class="arg" data-field="x" type="number" min="0" step="any" inputmode="decimal" value="1" name="Value" title="Please provide corresponding positive value."></p>
            </div>
            <div id="tabs-data">
              <p><textarea class="arg" id="data" data-field="data" inputmode="decimal" name="Data" title="Please provide raw numeric data (comma/space separated)" placeholder="e.g. 1.2, 2.3, 3.4 (comma/space separated)" rows="6"></textarea></p>
            </div>
            <div id="tabs-sigma">
              <p>sigma, \(\sigma\) > 0, is the standard deviation of the variable's natural logarithm</p>
              <p><input class="arg" data-field="sigma" type="number" min="0" step="any" inputmode="decimal" value="1" name="Standard deviation of it's natural logarithm" title="Please provide the standard deviation of it's natural logarithm (positive)."></p>
            </div>
            <div id="tabs-SD">
              <p><input class="arg" data-field="SD" type="number" min="0" step="any" inputmode="decimal" value="0" name="Standard deviation" title="Please provide the arithmetic standard deviation (positive)."></p>
            </div>
            <div id="tabs-GSD">
              <p><input class="arg" data-field="GSD" type="number" min="0" step="any" inputmode="decimal" value="1" name="Geometric mean" title="Please provide the geometric standard deviation (positive)."></p>
            </div>
            <div id="tabs-CV">
              <p><input class="arg" data-field="CV" type="number" min="0" step="any" inputmode="decimal" value="1" name="Coefficient of variation" title="Please provide the coefficient of variation (positive)."></p>
            </div>
            <div id="tabs-error">
              <p><input class="arg" data-field="error_factor" type="number" min="0" step="any" inputmode="decimal" value="1" name="Error factor" title="Please provide the error factor (positive)."></p>
            </div>
          </div>
        </td></tr>

      </table>

    </div>



        </div> <!-- .logn-left -->



    <div id="map"></div>
  </div>

  <footer></footer>

  <script src="./resources/js/site.js"></script>
  <script>
    // Render shared components
    KVOT.renderHeader('lognormal conversions');
    KVOT.renderNav('logn.html');
    KVOT.renderFooter();
    KVOT.initMap('map');

    /* Combined single header driving two metric panels.  
       - clicking a tab toggles selection; up to two tabs may be selected
       - templates live under #tabs (single source) and are cloned into metric panels on selection
    */
    const selectedTabs = []; // up to two selected `data-id` values (anchor data-id)
    const _labelToId = {}; // built from header anchors (label text -> template id suffix) — retained for backward mapping
    const _idToLabel = {}; // reverse map (data-id -> label text) — used for display

    // Metric rules: declarative, per-metric constraints and fallbacks (easier to extend).
    // - `exclusive: true` means the metric must be selected alone (e.g. 'data').
    // - `incompatibleWith` lists other metric ids that cannot be combined with this metric.
    // - `fallback` is a directional mapping used to auto-replace a disallowed second metric.
    const metricRules = {
      mu: { incompatibleWith: ['GM'], fallback: { 'GM': 'sigma' } },
      GM: { incompatibleWith: ['mu'], fallback: { 'mu': 'GSD' } },
      mean: { incompatibleWith: ['data'], fallback: { 'GM': 'SD' } },
      mode: { incompatibleWith: ['data'], fallback: { 'mean': 'SD' } },
      percentile: { pairable: true },
      data: { exclusive: true },
      sigma: { incompatibleWith: ['data','sigma','GSD','CV','error'] },
      SD: { incompatibleWith: ['data','SD','GSD','CV','error'] },
      GSD: { incompatibleWith: ['data','sigma','SD','CV','error'] },
      CV: { incompatibleWith: ['data','sigma','SD','GSD','error'] },
      error: { incompatibleWith: ['data','sigma','SD','GSD','CV'] }
    };

    function isPairDisallowed(a,b){
      if (!a || !b) return false;
      const ra = metricRules[a] || {};
      const rb = metricRules[b] || {};
      // exclusive metrics (like 'data') cannot be paired with anything else
      if (ra.exclusive || rb.exclusive) return true;
      if (ra.incompatibleWith && ra.incompatibleWith.includes(b)) return true;
      if (rb.incompatibleWith && rb.incompatibleWith.includes(a)) return true;
      return false;
    }

    function getFallbackForPair(primaryId, disallowedId){
      const r = metricRules[primaryId] || {};
      return (r.fallback && r.fallback[disallowedId]) ? r.fallback[disallowedId] : null;
    }

    function renderSelectedTabs() {
      const anchors = Array.from(document.querySelectorAll('#tabs-header a[data-id]'));
      // selectedTabs now stores data-id values directly
      const selectedIds = selectedTabs.filter(Boolean);
      const primaryId = selectedIds.length ? selectedIds[0] : null;
      // any tab that would form a disallowed pair with one of the already-selected ids is considered disabled
      const disabledForSecond = anchors.map(a => a.dataset.id).filter(id => selectedIds.some(selId => isPairDisallowed(selId, id)));

      // header visual + disabled state (disabled for secondary selections only)
      anchors.forEach(a => {
        const label = a.textContent.trim();
        const id = a.dataset.id;
        const isDisabled = !!(disabledForSecond.includes(id) && !selectedIds.includes(id));
        // selectedTabs stores data-id values now
        a.classList.toggle('selected', selectedTabs.includes(id));
        a.classList.toggle('disabled', isDisabled);
        a.setAttribute('aria-selected', selectedTabs.includes(id) ? 'true' : 'false');
        if (isDisabled) {
          a.setAttribute('aria-disabled','true');
          a.title = `Not allowed in combination with current selection`;
        } else {
          // only remove aria-disabled/title if not disabled by the 'max-selected' rule below
          if ((a.getAttribute('title') || '').startsWith('Not allowed')) a.removeAttribute('title');
          if (!a.classList.contains('disabled')) a.removeAttribute('aria-disabled');
        }
      });

      // If data is selected it must be the only selection — disable all other tabs.
      const hasDataSelected = selectedIds.includes('data');
      const maxSelectable = panelCount();
      if (hasDataSelected) {
        anchors.forEach(a => {
          const id = a.dataset.id;
          if (id !== 'data') {
            a.classList.add('disabled');
            a.setAttribute('aria-disabled','true');
            a.title = 'Data must be selected alone — deselect data to choose other metrics.';
          } else {
            a.classList.remove('disabled');
            a.removeAttribute('aria-disabled');
            if ((a.getAttribute('title') || '').startsWith('Maximum of') || (a.getAttribute('title') || '').startsWith('Not allowed')) a.removeAttribute('title');
          }
        });
      } else if (selectedTabs.length >= maxSelectable) {
        // reached maxSelectable — disable unselected anchors
        anchors.forEach(a => {
          const id = a.dataset.id;
          if (!selectedTabs.includes(id)) {
            a.classList.add('disabled');
            a.setAttribute('aria-disabled','true');
            a.title = `Maximum of ${maxSelectable} metrics selected — deselect one to change.`;
          }
        });
      } else {
        // remove any 'max-selected' disables (but keep constraint-based disables)
        anchors.forEach(a => {
          const id = a.dataset.id;
          const isConstraintDisabled = primaryId && disabledForSecond.includes(id) && id !== primaryId;
          if (!isConstraintDisabled && (a.getAttribute('title') || '').startsWith('Maximum of')) {
            a.classList.remove('disabled');
            a.removeAttribute('aria-disabled');
            a.removeAttribute('title');
          }
        });
      }

      const panels = Array.from(document.querySelectorAll('#metric-panels .metric-panel'));

      // clear any generated content from panels (templates remain under #tabs)
      panels.forEach(panel => {
        const content = panel.querySelector('.metric-content');
        while (content && content.firstChild) {
          const child = content.firstChild;
          // cloned/generated nodes are removed; templates under #tabs are left intact
          content.removeChild(child);
          child.classList && child.classList.remove('attach-anim');
        }
      });

      // if data is present in the selection, only the data slot remains visible (data must be selected alone)
      if (hasDataSelected) {
        panels.forEach((panel, idx) => {
          // leave first panel visible for the data input; hide the other
          if (idx === 0) panel.style.display = '';
          else {
            panel.style.display = 'none';
            if (selectedTabs[idx]) selectedTabs.splice(idx,1);
          }
        });
      } else {
        panels.forEach(panel => panel.style.display = '');
      }

      // ensure selectedTabs length does not exceed panel count
      if (selectedTabs.length > panels.length) selectedTabs.splice(panels.length);

      // enforce pair-based constraints (order-independent). for two selections, resolve conflicts.
      if (selectedTabs.length === 2) {
        const A = selectedTabs[0], B = selectedTabs[1];
        const idA = A, idB = B;
        if (isPairDisallowed(idA, idB)) {
          // try to replace the later selection (B) using fallback for A->B
          const fb1 = getFallbackForPair(idA, idB);
          if (fb1) {
            selectedTabs[1] = fb1;
          } else {
            // try fallback in reverse
            const fb2 = getFallbackForPair(idB, idA);
            if (fb2) selectedTabs[1] = fb2;
            else selectedTabs.splice(1,1); // remove second selection
          }
        }
      }

      // helper: clone template node (from #tabs) and prepare it for insertion
      function cloneTemplate(suf, panelIndex) {
        const tpl = document.getElementById(`tabs-${suf}`);
        if (!tpl) return null;
        const clone = tpl.cloneNode(true);
        // avoid duplicate IDs in the DOM
        if (clone.hasAttribute('id')) clone.removeAttribute('id');
        clone.querySelectorAll('[id]').forEach(el => el.removeAttribute('id'));
        clone.setAttribute('data-cloned-from', suf);
        // attach input listeners for cloned inputs
        attachArgListeners(clone);
        return clone;
      }

      // attach event listeners to .arg inputs within a root element
      function attachArgListeners(root) {
        (root.querySelectorAll ? Array.from(root.querySelectorAll('.arg')) : []).forEach(function(input) {
          // avoid double-binding by checking a marker
          if (input._kvotArgBound) return; input._kvotArgBound = true;
          input.addEventListener('input', function() { updatedInput(); });
        });
      }

      // populate each panel according to selectedTabs (panel index = array index + 1)
      panels.forEach((panel, idx) => {
        const content = panel.querySelector('.metric-content');
        const titleSpan = panel.querySelector('h4 span');
        // allow special case: if primary is 'percentile' and the secondary slot is empty,
        // show a second percentile pair input so the user can enter two percentile pairs.
        const sel = selectedTabs[idx]; // data-id or undefined
        const effectiveSel = sel || ((idx === 1 && selectedTabs[0] === 'percentile') ? 'percentile' : null);

        // title: show metric name (display label) and slot number
        if (titleSpan) {
          if (effectiveSel) {
            const display = _idToLabel[effectiveSel] || effectiveSel;
            if (effectiveSel === 'percentile' && idx === 1 && !sel) titleSpan.textContent = 'percentile (pair 2)';
            else titleSpan.textContent = `${display}`;
          } else {
            titleSpan.textContent = '';
          }
        }

        if (!effectiveSel) { content.textContent = 'No metric selected.'; return; }
        const suf = effectiveSel; // already the id used in template ids
        const clone = cloneTemplate(suf, idx+1);
        if (clone) {
          content.appendChild(clone);
          clone.classList.add('attach-anim');
          setTimeout(() => clone.classList.remove('attach-anim'), 300);
        }
      });
    }

    // helper to show temporary metric-related information near the header
    function showMetricInfo(msg, timeout = 2600) {
      const infoEl = document.getElementById('metric-info');
      if (!infoEl) return;
      infoEl.textContent = msg;
      infoEl.classList.add('show');
      clearTimeout(infoEl._hideTimer);
      infoEl._hideTimer = setTimeout(() => { infoEl.classList.remove('show'); infoEl._hideTimer = null; }, timeout);
    }

    // initialize combined-header behavior
    (function(){
      // build label->id mapping and add accessibility attributes to anchors
      const tabAnchors = Array.from(document.querySelectorAll('#tabs-header a[data-id]'));
      tabAnchors.forEach((a, i) => {
        const label = a.textContent.trim();
        const id = a.dataset.id;
        _labelToId[label] = id;
        _idToLabel[id] = label;
        a.setAttribute('role','tab');
        a.setAttribute('tabindex','0');
        a.setAttribute('aria-selected','false');
        // ensure Enter/Space toggles selection when focused
        a.addEventListener('keydown', function(ev){ if (ev.key === ' ' || ev.key === 'Enter') { ev.preventDefault(); a.click(); } });
      });

      // keyboard navigation for the header (arrow/home/end)
      document.getElementById('tabs-header').addEventListener('keydown', function(ev){
        const focused = document.activeElement.closest && document.activeElement.closest('a[data-id]');
        if (!focused) return;
        const idx = tabAnchors.indexOf(focused);
        if (idx === -1) return;
        if (ev.key === 'ArrowRight' || ev.key === 'ArrowDown') {
          // move to next enabled anchor
          let i = idx; do { i = (i+1) % tabAnchors.length; } while(tabAnchors[i].classList.contains('disabled') && i !== idx);
          tabAnchors[i].focus(); ev.preventDefault();
        } else if (ev.key === 'ArrowLeft' || ev.key === 'ArrowUp') {
          let i = idx; do { i = (i-1+tabAnchors.length) % tabAnchors.length; } while(tabAnchors[i].classList.contains('disabled') && i !== idx);
          tabAnchors[i].focus(); ev.preventDefault();
        } else if (ev.key === 'Home') {
          let i = 0; while(tabAnchors[i].classList.contains('disabled') && i < tabAnchors.length-1) i++;
          tabAnchors[i].focus(); ev.preventDefault();
        } else if (ev.key === 'End') {
          let i = tabAnchors.length-1; while(tabAnchors[i].classList.contains('disabled') && i > 0) i--;
          tabAnchors[i].focus(); ev.preventDefault(); }
      });

      // panels are fixed to two; add/remove controls are disabled in this build

      // header click toggles selection (max = current panel count). respect second-tab constraints.
      document.getElementById('tabs-header').addEventListener('click', function(e){
        const a = e.target.closest('a[data-id]');
        if (!a) return;
        e.preventDefault();
        const label = a.textContent.trim();
        const candidateId = a.dataset.id;

        // Special case: selecting 'data' toggles the data-only selection.
        // - clicking an unselected 'data' makes it the sole selection
        // - clicking it again deselects it and returns to normal selection handling
        if (candidateId === 'data') {
          const idx = selectedTabs.indexOf(candidateId);
          if (idx >= 0) {
            // deselect data
            selectedTabs.splice(idx, 1);
          } else {
            // select data alone
            selectedTabs.length = 0;
            selectedTabs.push(candidateId);
          }
          renderSelectedTabs();
          updatedInput();
          return;
        }

        // If data is already selected, no other selection is allowed
        const hasDataSelected = selectedTabs.includes('data');
        if (hasDataSelected && candidateId !== 'data') {
          a.classList.add('disabled-flash');
          setTimeout(() => a.classList.remove('disabled-flash'), 260);
          showMetricInfo('Data can only be selected by itself. Deselect data to choose other metrics.');
          return;
        }

        // blocked if visually marked disabled and the id isn't already selected
        if (a.classList.contains('disabled') && selectedTabs.indexOf(candidateId) === -1) {
          a.classList.add('disabled-flash');
          setTimeout(() => a.classList.remove('disabled-flash'), 260);
          return;
        }

        const idx = selectedTabs.indexOf(candidateId);
        if (idx >= 0) {
          // deselect
          selectedTabs.splice(idx,1);
        } else {
          const maxSelectable = 2;
          // check for combination conflicts with already-selected metrics (selectedTabs stores ids)
          const conflictWith = selectedTabs.find(selId => isPairDisallowed(selId, candidateId));
          if (conflictWith) {
            a.classList.add('disabled-flash');
            setTimeout(() => a.classList.remove('disabled-flash'), 260);
            showMetricInfo(`Combining "${label}" with "${_idToLabel[conflictWith] || conflictWith}" is not allowed.`);
            return;
          }
          if (selectedTabs.length < maxSelectable) selectedTabs.push(candidateId);
          else { showMetricInfo('Only two metrics can be selected at once. Deselect one to choose another.'); return; }
        }

        // render will auto-correct invalid second selections for the current primary
        renderSelectedTabs();
        updatedInput();
      });

      // defaults: Metric1 = mu, Metric2 = sigma (preserves former behaviour)
      selectedTabs.push('mu','sigma');
      renderSelectedTabs();
      updatedInput();
    })();



    function getMuSigma(args){
      // Order-independent resolver for mu and sigma.
      function has(k){ return Object.prototype.hasOwnProperty.call(args,k); }
      let mu, sigma;

      // two-percentile pair -> direct solve
      if ((has('p1') || has('x1')) && (has('p2') || has('x2'))) {
        sigma = Math.log(args.x1 / args.x2) / (args.p1/100 - args.p2/100);
        mu = Math.log(args.x1) + Math.log(args.x2 / args.x1) * (0-args.p1/100) / (args.p2/100-args.p1/100);
        return [mu,sigma];
      }
      if (has('sigma'))sigma = args.sigma;
      if (has('GSD')) sigma = Math.log(args.GSD);
      if (has('CV')) sigma = Math.sqrt(Math.log((args.CV**2)+1));
      if (has('error_factor')) sigma = Math.log(args.error_factor)/1.645;

      // If mu or GM provided, use it with any other available descriptor
      if (has('mu') || has('GM')) {
        if (has('GM')){
          mu = Math.log(args.GM);
        } else {
          mu = args.mu;
        }
        if (has('mean')) sigma = Math.sqrt((Math.log(args.mean)-mu)*2);
        else if (has('mode')) sigma = Math.sqrt(mu - Math.log(args.mode));
        else if (has('x') && has('p')) sigma = (Math.log(args.x)-mu)/(Math.exp(args.p/100));
        return [mu,sigma];
      }

      // If mean provided
      if (has('mean')) {
        if (has('mode')) sigma = Math.sqrt(2*Math.log(args.mean/args.mode)/3);
        else if (has('x') && has('p')) {
          if (args.mean < args.x) {
            sigma = args.p/100 + Math.sqrt(((args.p/100)**2) + 2 * Math.log(args.mean / args.x));
          } else if (args.mean > args.x) {
            sigma = args.p/100 - Math.sqrt(((args.p/100)**2) + 2 * Math.log(args.mean / args.x));
          }
        }
        else if (has('SD')) sigma = Math.sqrt(Math.log((args.SD**2)/(args.mean**2)+1));
        mu = Math.log(args.mean) - (sigma**2)/2;
        return [mu,sigma];
      }

      // If mode provided
      if (has('mode')) {
        if (has('p') && has('x')) {
          if (args.mode < args.x) {
            sigma = (-args.p/100 - Math.sqrt((args.p/100)**2 - 4 * Math.log(args.mode / args.x))) / 2;
          } else if (args.mode > args.x) {
            sigma = (-args.p/100 + Math.sqrt((args.p/100)**2  - 4 * Math.log(args.mode / args.x))) / 2;
          }
        }
        mu = Math.log(args.mode) + sigma**2;
        return [mu,sigma];
      }

      // fallback: unable to determine
      return [undefined, undefined];
    }

    // Fit a lognormal distribution by MLE.
    // - accepts either a string (comma/space/semicolon separated) or an array of numbers
    // - returns { mu, sigma, n, sampleMeanLog, sampleSdLog } or { error }
    function fitLognormalMLE(data) {
      let arr = Array.isArray(data) ? data.slice() : String(data || '').split(/[\s,;]+/).map(s => parseFloat(s)).filter(n => !Number.isNaN(n));
      // keep only positive values (lognormal defined for x>0)
      arr = arr.filter(v => v > 0);
      const n = arr.length;
      if (n === 0) return { error: 'Please provide at least two positive numeric values (comma/space/newline separated).' };
      const logs = arr.map(v => Math.log(v));
      const meanLog = logs.reduce((a,b) => a + b, 0) / n;                // MLE uses 1/n
      const varianceLog = logs.reduce((a,b) => a + Math.pow(b - meanLog, 2), 0) / n; // MLE divisor n
      const sdLog = Math.sqrt(varianceLog);
      return { mu: meanLog, sigma: sdLog, n, sampleMeanLog: meanLog, sampleSdLog: sdLog, values: arr };
    }

    // Read a field value from a metric panel (panelIndex = 1 for primary, 2 for secondary).
    // Prefers `data-field` attributes (legacy numeric IDs removed).
    function panelValue(panelIndex, key) {
      const panel = document.getElementById(`metric${panelIndex}-content`);
      if (!panel) return null;
      const el = panel.querySelector(`[data-field="${key}"]`);
      return el ? el.value : null;
    }

    // Fixed panels: only two panels supported
    function panelCount() { return 2; }

    function updatedInput(){
      var args = {};
      var mu;
      var sigma;
      // read selected tabs from combined header (selectedTabs is managed by the combined-tab UI)
      const tab1 = (typeof selectedTabs !== 'undefined' && selectedTabs[0]) || 'mu';
      const tab2 = (typeof selectedTabs !== 'undefined' && selectedTabs[1]) || null;
      switch (tab1) {
        case 'percentile':
          // primary percentile pair (panel 1)
          args.p1 = parseFloat(panelValue(1,'p'));
          args.x1 = parseFloat(panelValue(1,'x'));

          // secondary percentile pair: explicitly selected or rendered into panel 2
          const p2val = panelValue(2,'p');
          const x2val = panelValue(2,'x');
          if ((tab2 === 'percentile') || (selectedTabs[0] === 'percentile' && p2val !== null && p2val !== '')) {
            args.p2 = parseFloat(p2val);
            args.x2 = parseFloat(x2val);
          }

          // validation: ensure numeric and percentiles differ when two pairs provided
          if (typeof args.p2 !== 'undefined') {
            if (!isFinite(args.p1) || !isFinite(args.x1) || !isFinite(args.p2) || !isFinite(args.x2) || args.x1 <= 0 || args.x2 <= 0) {
              args._invalidPercentile = 'Please provide two valid percentile/value pairs (positive values).';
            } else if (Math.abs(args.p1 - args.p2) < 1e-9) {
              args._invalidPercentile = 'Percentile probabilities (p1 and p2) must be different to compute mu and sigma.';
            }
          }
          break;

        case 'data': {
          const raw = panelValue(1,'data') || '';
          const fit = fitLognormalMLE(raw);
          if (fit.error || fit.n < 2) {
            // mark invalid so we can render a clear message and abort plotting
            args._invalidData = fit.error || 'Please provide at least two positive numeric values.';
          } else {
            args.mu = fit.mu;
            args.sigma = fit.sigma;
            args._dataStats = { n: fit.n, sampleMeanLog: fit.sampleMeanLog, sampleSdLog: fit.sampleSdLog };
            args._dataValues = fit.values || [];
          }
        } break;

        default:
          // Generic: collect raw argument fields for both panels and let getMuSigma() do the maths.
          const mapField = function(id) {
            return ({ 'mu':'mu', 'GM':'GM', 'mean':'mean', 'mode':'mode', 'sigma':'sigma', 'SD':'SD', 'GSD':'GSD', 'CV':'CV', 'error':'error_factor' })[id] || null;
          };
          const k1 = mapField(tab1);
          if (k1) {
            const v = panelValue(1, k1);
            if (v !== null && v !== '') args[k1] = +v;
          }
          // secondary special-case: percentile as second metric provides p/x; otherwise map normally
          if (tab2 === 'percentile') {
            args.p = +panelValue(2,'p');
            args.x = +panelValue(2,'x');
          } else if (tab2 && tab2 !== 'data') {
            const k2 = mapField(tab2);
            if (k2) {
              const v2 = panelValue(2, k2);
              if (v2 !== null && v2 !== '') args[k2] = +v2;
            }
          }
          break;
      }
      // validate numeric inputs collected from panels (exclude data and internal flags)
      (function(){
        for (const k of Object.keys(args)) {
          if (k.startsWith('_') || k === 'data') continue;
          const v = args[k];
          // coerce string digits to number
          const num = (typeof v === 'string' && v !== '') ? Number(v) : v;
          if (num === '' || num === null || num === undefined) continue;
          if (!isFinite(num)) { args._invalidNumeric = `Invalid numeric value for ${k}`; break; }
          // positive-only checks
          if (['sigma','SD','GSD','CV','error_factor','mean','GM','mode','x','x1','x2'].includes(k) && num <= 0) { args._invalidNumeric = `${k} must be a positive number`; break; }
          // percentile range
          if (['p','p1','p2'].includes(k) && (num < 0 || num > 100)) { args._invalidNumeric = `Percentile must be in range 0–100`; break; }
          args[k] = num; // normalize
        }
      })();
      if (args._invalidNumeric) {
        const outEl = document.getElementById('ln-output');
        if (outEl) outEl.textContent = args._invalidNumeric;
        window._lastLognormal = null;
        return;
      }
      // if primary is data, we either have fitted mu/sigma or an error marker
      if (tab1 === 'data') {
        if (args._invalidData) {
          const outEl = document.getElementById('ln-output');
          if (outEl) outEl.textContent = args._invalidData;
          window._lastLognormal = null;
          return;
        }
        mu = args.mu;
        sigma = args.sigma;
      } else if (tab1 === 'percentile' && args._invalidPercentile) {
        const outEl = document.getElementById('ln-output');
        if (outEl) outEl.textContent = args._invalidPercentile;
        window._lastLognormal = null;
        return;
      } else {
        [mu,sigma] = getMuSigma(args);
      }
      let txt = '';
      const mean = Math.exp(mu+(sigma**2)/2);
      const median = Math.exp(mu);
      const mode = Math.exp(mu-sigma**2);
      const sd = Math.sqrt((Math.exp(sigma**2)-1)*Math.exp(2*mu+(sigma**2)));
      const variance = (Math.exp(sigma**2)-1)*Math.exp(2*mu+(sigma**2));
      const gsd = Math.exp(sigma);
      const CV = Math.sqrt(Math.exp(sigma**2)-1);
      const skewness = (Math.pow(CV,3)+3*CV);
      const kurtosis = (Math.pow(CV,8)+6*Math.pow(CV,6)+15*Math.pow(CV,4)+16*Math.pow(CV,2));
      const entropy = ((1+Math.log(2*Math.PI*sigma**2))/2+mu);
      const error_factor = Math.exp(sigma*1.645);

      txt += `mu: ${mu}\n`;
      txt += `sigma: ${sigma}\n`;
      txt += `Mean: ${mean}\n`;
      txt += `Median: ${median}\n`;
      txt += `Mode: ${mode}\n`;
      txt += `Standard deviation: ${sd}\n`;
      txt += `Variance: ${variance}\n`;
      txt += `Geometric standard deviation: ${gsd}\n`;
      txt += `CV: ${CV}\n`;
      txt += `Skewness: ${skewness}\n`;
      txt += `Kurtosis: ${kurtosis}\n`;
      txt += `Entropy: ${entropy}\n`;
      txt += `Error factor (1.645σ): ${error_factor}\n`;

      if (tab1 === 'data' && args._dataStats) {
        txt += `\nData (n=${args._dataStats.n}) — mean(log): ${args._dataStats.sampleMeanLog}, sd(log) [MLE]: ${args._dataStats.sampleSdLog}\n`;
      }

      // render output to the page
      const outEl = document.getElementById('ln-output');
      if (outEl) outEl.textContent = txt;

      // expose structured result for other scripts/tests (include data stats when available)
      window._lastLognormal = { mu, sigma, mean, median, mode, sd, variance, gsd, CV, skewness, kurtosis, entropy, error_factor, dataStats: args._dataStats || null, dataValues: args._dataValues || null };

      // if user requested CDF view, draw the empirical/theoretical CDF and skip the PDF plotting
      const chartMode = (typeof getChartMode === 'function') ? getChartMode() : 'pdf';
      const lnView = !!(document.getElementById('lnViewToggle') && document.getElementById('lnViewToggle').checked);
      if (chartMode === 'cdf') {
        const CH = document.getElementById('chart');
        const cdfTraces = [];
        const sigmaPlot = (typeof sigma === 'number' && sigma > 0) ? sigma : 1e-6;
        const nPts = 800;

        if (lnView) {
          // empirical ln-CDF
          if (tab1 === 'data' && args._dataValues && args._dataValues.length > 0) {
            const sortedLogs = args._dataValues.map(v => Math.log(v)).sort((a,b)=>a-b);
            const empY = sortedLogs.map((v,i) => (i+1)/sortedLogs.length);
            cdfTraces.push({ x: sortedLogs, y: empY, mode: 'lines', line: { color: 'rgba(96,96,96,0.8)' , shape: 'hv' }, name: 'empirical ln-CDF' });
          }
          // theoretical normal CDF on ln-scale
          const xl = linspace(mu - 4*sigmaPlot, mu + 4*sigmaPlot, nPts);
          const yl = xl.map(z => normcdf(mu, sigmaPlot, z));
          cdfTraces.push({ x: xl, y: yl, mode: 'lines', line: { color: '#f3b87b' }, name: 'theoretical CDF' });

          Plotly.newPlot(CH, cdfTraces, { autosize:true, responsive:true, showlegend:false, xaxis:{ title: { text: 'ln(x)', standoff: 8 }, automargin:true }, yaxis:{ range:[0,1], automargin:true }, margin:{ t:28, r:22, b:56, l:40 } });
          return;
        }

        // standard x-scale CDF
        if (tab1 === 'data' && args._dataValues && args._dataValues.length > 0) {
          const sortedX = args._dataValues.slice().sort((a,b)=>a-b);
          const empY = sortedX.map((v,i)=> (i+1)/sortedX.length);
          cdfTraces.push({ x: sortedX, y: empY, mode: 'lines', line: { color: 'rgba(96,96,96,0.8)' , shape: 'hv' }, name: 'empirical CDF' });
        }
        const xg = linspace(Math.exp(mu - 4*sigmaPlot), Math.exp(mu + 4*sigmaPlot), nPts);
        const yg = xg.map(xx => logncdf(mu, sigmaPlot, xx));
        cdfTraces.push({ x: xg, y: yg, mode: 'lines', line: { color: '#f3b87b' }, name: 'theoretical CDF' });
        Plotly.newPlot(CH, cdfTraces, { autosize:true, responsive:true, showlegend:false, xaxis:{ automargin:true }, yaxis:{ range:[0,1], automargin:true }, margin:{ t:28, r:22, b:56, l:40 } });
        return;
      }

      let n = 1000;
      let p = linspace(0,0.99,n);
      let p5 = linspace(0,0.05,n);
      let p95 = linspace(0.95,0.99,n);
      let x = new Array();
      let y = new Array();
      let x5 = new Array();
      let y5 = new Array();
      let x95 = new Array();
      let y95 = new Array();
      // protect against degenerate sigma (all identical data => sigma === 0)
      const sigmaPlot = (typeof sigma === 'number' && sigma > 0) ? sigma : 1e-6;
      for (let i=1;i<n;i++){
        x[i] = logninv(mu,sigmaPlot,p[i]);
        y[i] = lognpdf(mu,sigmaPlot,x[i]);
        x5[i] = logninv(mu,sigmaPlot,p5[i]);
        y5[i] = lognpdf(mu,sigmaPlot,x5[i]);
        x95[i] = logninv(mu,sigmaPlot,p95[i]);
        y95[i] = lognpdf(mu,sigmaPlot,x95[i]);
      }

      CHART = document.getElementById('chart');
      const traces = []; // lnView/chartMode already handled above

      if (lnView) {
        // ln(x) view — histogram of ln(data) and normal density on ln-axis
        if (tab1 === 'data' && args._dataValues && args._dataValues.length > 0) {
          const logs = args._dataValues.map(v => Math.log(v));
          const bins = Math.min(50, Math.max(5, Math.round(Math.sqrt(args._dataStats ? args._dataStats.n : args._dataValues.length))));
          traces.push({
            x: logs,
            type: 'histogram',
            histnorm: 'probability density',
            opacity: 0.5,
            marker: { color: 'rgba(96,96,96,0.28)' },
            nbinsx: bins,
            hovertemplate: '%{x:.4f}: %{y:.4f}<extra>ln(data)</extra>',
            name: 'Empirical (ln)'
          });
        }

        // normal density on ln-scale
        const xl = linspace(mu - 4*sigmaPlot, mu + 4*sigmaPlot, n);
        const yl = xl.map(z => normpdf(mu, sigmaPlot, z));
        traces.push({ x: xl, y: yl, fill: 'tozeroy', fillcolor: 'rgba(243,184,123,0.5)', line: { color: '#f3b87b' }, type: 'scatter', hoverinfo: 'skip', name: 'Theoretical (normal)' });
        const yMax = Math.max.apply(null, yl) || 0.001;
        traces.push({ x: [mu, mu], y: [0, yMax*0.98], hovertext: 'μ (ln)', mode: 'lines', line: { color: '#f3b87b', dash:'dot' }});

        // responsive margins — increase bottom padding and enable automargin so axis labels are never cropped
        const cw = CHART ? (CHART.clientWidth || CHART.offsetWidth) : window.innerWidth;
        const leftMargin = cw < 420 ? 40 : (cw < 720 ? 52 : 68);
        const rightMargin = cw < 420 ? 20 : 24;
        const bottomMargin = cw < 420 ? 72 : 56;
        const topMargin = 24;

        Plotly.newPlot(CHART, traces, {
          autosize: true,
          responsive: true,
          showlegend: false,
          barmode: 'overlay',
          xaxis: { type: 'lin', range: [xl[0], xl[n-1]], title: { text: 'ln(x)', standoff: 8 }, automargin: true },
          yaxis: { automargin: true },
          margin: { t: topMargin, r: rightMargin, b: bottomMargin, l: leftMargin, autoexpand:false },
          paper_bgcolor: 'rgba(0,0,0,0)',
          plot_bgcolor: 'rgba(0,0,0,0)'
        });

      } else {
        // standard lognormal view (original behaviour)
        if (tab1 === 'data' && args._dataValues && args._dataValues.length > 0) {
          const bins = Math.min(50, Math.max(5, Math.round(Math.sqrt(args._dataStats ? args._dataStats.n : args._dataValues.length))));
          traces.push({
            x: args._dataValues,
            type: 'histogram',
            histnorm: 'probability density',
            opacity: 0.5,
            marker: { color: 'rgba(96,96,96,0.28)' },
            nbinsx: bins,
            hovertemplate: '%{x}: %{y:.4f}<extra>data</extra>',
            name: 'Empirical'
          });
        }

        traces.push(
          { x: x, y: y, fill: 'tozeroy', fillcolor: 'rgba(243,184,123,0.5)', line: { color: '#f3b87b' }, type: 'scatter', hoverinfo: 'skip', name: 'Theoretical' },
          { x: x5, y: y5, fill: 'tozeroy', fillcolor: 'rgba(243,184,123,0.5)', line: { color: '#f3b87b' }, type: 'scatter', hoverinfo: 'skip' },
          { x: x95, y: y95, fill: 'tozeroy', fillcolor: 'rgba(243,184,123,0.5)', line: { color: '#f3b87b' }, type: 'scatter', hoverinfo: 'skip' },
          { x:[Math.exp(mu+(sigma**2)/2),Math.exp(mu+(sigma**2)/2)], y:[0,lognpdf( mu, sigmaPlot, Math.exp(mu+(sigma**2)/2) )], hovertext:'Mean', mode:'lines', line: { color: '#f3b87b', dash:'solid' }},
          { x:[Math.exp(mu),Math.exp(mu)], y:[0,lognpdf( mu, sigmaPlot, Math.exp(mu) )], hovertext:'50%', mode:'lines', line: { color: '#f3b87b', dash:'dot' }}
        );

        // compute responsive margins so axis labels/ticks never get cropped
        const cw = CHART ? (CHART.clientWidth || CHART.offsetWidth) : window.innerWidth;
        const leftMargin = cw < 420 ? 40 : (cw < 720 ? 52 : 68);
        const rightMargin = cw < 420 ? 20 : 24;
        const bottomMargin = cw < 420 ? 72 : 56; // increased bottom space so x-axis labels are visible
        const topMargin = 24;
        Plotly.newPlot(CHART, traces, {
          autosize: true,
          responsive: true,
          showlegend: false,
          barmode: 'overlay',
          xaxis: { type: 'lin', range: [x[0],x[n-1]], automargin: true },
          yaxis: { automargin: true },
          margin: { t: topMargin, r: rightMargin, b: bottomMargin, l: leftMargin, autoexpand:false },
          paper_bgcolor: 'rgba(0,0,0,0)',
          plot_bgcolor: 'rgba(0,0,0,0)'
        });
      }
    }

    // loop through each arg-input and add an input event listener
    document.querySelectorAll(".arg").forEach(function(input) {
      input.addEventListener("input", function() { updatedInput(); });
    });

    // controls for printing/copying/combining
    document.getElementById('showDetailsBtn').addEventListener('click', function() { updatedInput(); document.getElementById('ln-output').scrollIntoView({behavior:'smooth'}); });
    document.getElementById('copyDetailsBtn').addEventListener('click', async function() {
      const text = document.getElementById('ln-output').textContent || '';
      try { await navigator.clipboard.writeText(text); this.textContent = 'Copied'; setTimeout(()=> this.textContent = 'Copy', 1200); } catch (e) { alert('Copy failed: ' + e.message); }
    });
    document.getElementById('printDetailsBtn').addEventListener('click', function() {
      const content = document.getElementById('ln-output').textContent || '';
      const w = window.open('', '_blank');
      w.document.write('<pre style="font-family:monospace;white-space:pre-wrap;">' + (content.replace(/&/g,'&amp;').replace(/</g,'&lt;')) + '</pre>');
      w.document.close();
      w.print();
    });

    // Preview (print-friendly) — opens a new window showing computed output and the equations (renders MathJax)
    document.getElementById('previewDetailsBtn').addEventListener('click', function() {
      updatedInput();
      const outText = document.getElementById('ln-output').textContent || '';
      const outTextEsc = outText.replace(/&/g,'&amp;').replace(/</g,'&lt;');
      const eqEl = document.querySelector('#equations-details .equations-body');
      const eqHtml = eqEl ? eqEl.innerHTML : '';
      const preview = window.open('', '_blank');
      preview.document.write('<!doctype html><html><head><meta charset="utf-8"><title>Lognormal — Preview</title>');
      preview.document.write('<link rel="stylesheet" href="./resources/css/kvot.css">');
      preview.document.write('<style>body{font-family:Arial,Helvetica,sans-serif;padding:18px;color:#222} pre{white-space:pre-wrap;background:#f7f7f8;padding:12px;border-radius:4px;border:1px solid #e1e1e1;font-family:Menlo,monospace;font-size:0.95rem} table{width:100%;border-collapse:collapse} td{padding:8px 10px} .equations-body{font-size:1rem;line-height:1.45} @media print{ body{margin:12mm} pre{font-size:1rem} .equations-body table td{padding:8px 10px} }</style>');
      preview.document.write('<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">' + '</' + 'script>');
      preview.document.write('</head><body>');
      preview.document.write('<h2>Lognormal preview</h2>');
      preview.document.write('<h3>Computed distribution</h3>');
      preview.document.write('<pre>' + outTextEsc + '</pre>');
      preview.document.write('<h3>Equations</h3>');
      preview.document.write(eqHtml);
      preview.document.write('<script>window.onload=function(){ if(window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise(); }<' + '/script>');
      preview.document.write('</body></html>');
      preview.document.close();
    });

    // wire ln(x) toggle to re-run calculation and redraw chart
    const _lnToggle = document.getElementById('lnViewToggle');
    if (_lnToggle) _lnToggle.addEventListener('change', function(){ updatedInput(); });
    // segmented chart mode buttons (PDF / CDF)
    const _chartMode = document.getElementById('chartMode');
    if (_chartMode) {
      Array.from(_chartMode.querySelectorAll('[data-chart-mode]')).forEach(function(btn){
        btn.addEventListener('click', function(){
          _chartMode.querySelectorAll('[data-chart-mode]').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          // update aria-pressed
          _chartMode.querySelectorAll('[data-chart-mode]').forEach(b => b.setAttribute('aria-pressed', b.classList.contains('active') ? 'true' : 'false'));
          updatedInput();
        });
      });
    }

    function getChartMode() {
      const c = document.getElementById('chartMode');
      if (!c) return 'pdf';
      const active = c.querySelector('[data-chart-mode].active');
      return (active && active.getAttribute('data-mode')) || 'pdf';
    }

    // second-metric is now chosen by selecting a second tab in the combined header (no checkbox)
    // updatedInput() will react to header selection state (selectedTabs).

    function unifinv( a, b, p ){ return a+(b-a)*p;}
    function norminv( mu, sigma, p ){ return -Math.sqrt(2)*erfcinv(2*p)*sigma+mu;}
    function normcdf( mu, sigma, x ){ return 0.5*erfc(-(x-mu)/sigma/Math.sqrt(2));}
    function normpdf( mu, sigma, x ){ return Math.exp(-0.5*((x-mu)/sigma)**2)/(Math.sqrt(2*Math.PI)*sigma);}
    function logninv( mu, sigma, p ){ return Math.exp(sigma*(-Math.sqrt(2)*erfcinv(2*p))+mu);}
    function logncdf( mu, sigma, x ){ return 0.5*erfc(-(Math.log(x)-mu)/sigma/Math.sqrt(2));}
    function lognpdf( mu, sigma, x ){ return Math.exp(-0.5*((Math.log(x)-mu)/sigma)**2)/(x*Math.sqrt(2*Math.PI)*sigma);}

    window.onresize = function() {
      Plotly.Plots.resize(CHART);
    };

    function linspace(startValue, stopValue, cardinality) {
      var arr = [];
      var step = (stopValue - startValue) / (cardinality - 1);
      for (var i = 0; i < cardinality; i++) {
        arr.push(startValue + (step * i));
      }
      return arr;
    }
  </script>
</body>
</html>
